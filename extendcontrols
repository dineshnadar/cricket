import { Injectable, signal, computed, Signal } from '@angular/core';
import { FormGroup, FormArray, AbstractControl } from '@angular/forms';

interface ExtendedControlOptions {
  label?: string;
  visible?: boolean;
  editable?: boolean;
  lookup?: string;
  lookupData?: Array<{ label: string; value: any }>;
  regex?: string[];
  fldMax?: number;
  fieldType?: string;
  dfltVal?: any;
  required?: boolean;
}

type ExtendedControlProperties = {
  [K in keyof ExtendedControlOptions]: NonNullable<ExtendedControlOptions[K]>;
};

type ExtendedAbstractControl = AbstractControl & ExtendedControlProperties;

interface CustomComputation {
  compute: (control: AbstractControl, form: FormGroup) => any;
}

interface ReadViewItem {
  label: string;
  value: any;
  editable: boolean;
  visible: boolean;
  computedValue?: any;
  children?: ReadViewItem[];
}

@Injectable({
  providedIn: 'root'
})
export class FormExtensionService {
  private formSignal = signal<FormGroup | null>(null);
  private updateTrigger = signal(0);
  private customComputations = new Map<string, CustomComputation>();

  setForm(form: FormGroup) {
    this.formSignal.set(form);
  }

  extendControl(control: AbstractControl, options: ExtendedControlOptions, path = '') {
    const extendedControl = control as ExtendedAbstractControl;
    let changed = false;

    (Object.keys(options) as Array<keyof ExtendedControlOptions>).forEach(key => {
      if (key === 'regex') {
        if (!this.areRegexArraysEqual(extendedControl[key], options[key])) {
          extendedControl[key] = options[key] as any;
          changed = true;
        }
      } else if (extendedControl[key] !== options[key]) {
        extendedControl[key] = options[key] as any;
        changed = true;
      }
    });

    if (changed) {
      if (control instanceof FormGroup || control instanceof FormArray) {
        this.extendNestedControls(control, path);
      }
      this.triggerUpdate();
    }
  }

  private areRegexArraysEqual(arr1?: string[], arr2?: string[]): boolean {
    if (!arr1 && !arr2) return true;
    if (!arr1 || !arr2) return false;
    if (arr1.length !== arr2.length) return false;
    return arr1.every((regex, index) => regex === arr2[index]);
  }

  updateControlProperty(
    controlPath: string,
    property: keyof ExtendedControlOptions,
    value: ExtendedControlOptions[typeof property]
  ) {
    const form = this.formSignal();
    if (form) {
      const control = this.getControlByPath(form, controlPath) as ExtendedAbstractControl | null;
      if (control) {
        if (property === 'regex') {
          if (!this.areRegexArraysEqual(control[property], value as string[])) {
            control[property] = value as string[];
            this.triggerUpdate();
          }
        } else if (control[property] !== value) {
          control[property] = value;
          this.triggerUpdate();
        }
      }
    }
  }

  private extendNestedControls(control: FormGroup | FormArray, parentPath: string) {
    if (control instanceof FormGroup) {
      Object.keys(control.controls).forEach(key => {
        const childPath = parentPath ? `${parentPath}.${key}` : key;
        this.extendControl(control.get(key)!, {}, childPath);
      });
    } else if (control instanceof FormArray) {
      control.controls.forEach((ctrl, index) => {
        const childPath = parentPath ? `${parentPath}.${index}` : index.toString();
        this.extendControl(ctrl, {}, childPath);
      });
    }
  }

  private getControlByPath(form: FormGroup, path: string): AbstractControl | null {
    return path.split('.').reduce((acc: AbstractControl | null, part: string) => {
      if (acc instanceof FormGroup) {
        return acc.get(part);
      } else if (acc instanceof FormArray) {
        const index = parseInt(part, 10);
        return acc.at(index);
      }
      return null;
    }, form);
  }

  triggerUpdate() {
    this.updateTrigger.update(v => v + 1);
  }

  registerCustomComputation(controlPath: string, computation: CustomComputation) {
    this.customComputations.set(controlPath, computation);
    this.triggerUpdate();
  }

  getReadView(): Signal<ReadViewItem[]> {
    return computed(() => {
      this.updateTrigger();
      const form = this.formSignal();
      if (!form) return [];

      return this.getReadViewForControl(form);
    });
  }

  private getReadViewForControl(control: AbstractControl, path = ''): ReadViewItem[] {
    if (control instanceof FormGroup) {
      return Object.keys(control.controls)
        .map(key => {
          const childPath = path ? `${path}.${key}` : key;
          const childControl = control.get(key)!;
          return this.createReadViewItem(childControl, childPath, key);
        })
        .filter(item => item.visible);
    } else if (control instanceof FormArray) {
      return control.controls.map((ctrl, index) => {
        const childPath = path ? `${path}.${index}` : index.toString();
        return this.createReadViewItem(ctrl, childPath, index.toString());
      }).filter(item => item.visible);
    } else {
      return [this.createReadViewItem(control, path)];
    }
  }

  private createReadViewItem(control: AbstractControl, path: string, key = ''): ReadViewItem {
    const extendedControl = control as ExtendedAbstractControl;
    const rawValue = control.value;
    let transformedValue = this.transformValue(rawValue, extendedControl);

    const item: ReadViewItem = {
      label: extendedControl.label || key,
      value: transformedValue,
      editable: extendedControl.editable ?? true,
      visible: extendedControl.visible ?? true
    };

    const customComputation = this.customComputations.get(path);
    if (customComputation) {
      item.computedValue = customComputation.compute(control, this.formSignal()!);
    }

    if (control instanceof FormGroup || control instanceof FormArray) {
      item.children = this.getReadViewForControl(control, path);
    }

    return item;
  }

  private transformValue(value: any, control: ExtendedAbstractControl): any {
    // Transform based on Y/N values
    if (value === 'Y') return 'Yes';
    if (value === 'N') return 'No';

    // Transform based on lookup data
    if (control.lookupData && Array.isArray(control.lookupData)) {
      const matchingLookup = control.lookupData.find(item => item.value === value);
      if (matchingLookup) return matchingLookup.label;
    }

    return value;
  }

  getComputedValue(controlPath: string): Signal<any | undefined> {
    return computed(() => {
      this.updateTrigger();
      const form = this.formSignal();
      if (!form) return undefined;

      const control = this.getControlByPath(form, controlPath);
      if (!control) return undefined;

      const customComputation = this.customComputations.get(controlPath);
      return customComputation ? customComputation.compute(control, form) : undefined;
    });
  }

  // Utility method to get extended properties of a control
  getExtendedProperties(controlPath: string): Partial<ExtendedControlProperties> | null {
    const form = this.formSignal();
    if (!form) return null;

    const control = this.getControlByPath(form, controlPath) as ExtendedAbstractControl | null;
    if (!control) return null;

    return {
      label: control.label,
      visible: control.visible,
      editable: control.editable,
      lookup: control.lookup,
      lookupData: control.lookupData,
      regex: control.regex,
      fldMax: control.fldMax,
      fieldType: control.fieldType,
      dfltVal: control.dfltVal,
      required: control.required
    };
  }

  // Utility method to apply default values
  applyDefaultValues(form: FormGroup) {
    this.applyDefaultValuesRecursive(form);
    this.triggerUpdate();
  }

  private applyDefaultValuesRecursive(control: AbstractControl) {
    const extendedControl = control as ExtendedAbstractControl;
    
    if (control instanceof FormGroup) {
      Object.keys(control.controls).forEach(key => {
        this.applyDefaultValuesRecursive(control.get(key)!);
      });
    } else if (control instanceof FormArray) {
      control.controls.forEach(ctrl => {
        this.applyDefaultValuesRecursive(ctrl);
      });
    } else if (extendedControl.dfltVal !== undefined && control.value === null) {
      control.setValue(extendedControl.dfltVal);
    }
  }
}
