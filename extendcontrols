import { Injectable, signal, computed, Signal } from '@angular/core';
import { FormGroup, FormArray, AbstractControl } from '@angular/forms';

interface ExtendedControlOptions {
  label?: string;
  fldName?: string;
  visible?: boolean;
  editable?: boolean;
  lookup?: string;
  lookupData?: Array<{ label: string; value: any }>;
  regex?: string[];
  fldMax?: number;
  fieldType?: string;
  dfltVal?: any;
  required?: boolean;
  oldValue?: any;
  expand?: boolean;
  sectionName?: string;
  subSectionName?: string;
  seq?: number;
  reqBorder?: boolean;
  subName?: string;
}

type ExtendedControlProperties = {
  [K in keyof ExtendedControlOptions]: NonNullable<ExtendedControlOptions[K]>;
} & {
  _oldValue?: any;
};

type ExtendedAbstractControl = AbstractControl & ExtendedControlProperties;

interface CustomComputation {
  compute: (control: AbstractControl, form: FormGroup) => any;
}

interface ReadViewItem {
  label: string;
  fldName: string;
  value: any;
  oldValue?: any;
  editable: boolean;
  visible: boolean;
  computedValue?: any;
  expand: boolean;
  sectionName?: string;
  subSectionName?: string;
  children?: ReadViewItem[];
  seq?: number;
  reqBorder?: boolean;
  subName?: string;
}

@Injectable({
  providedIn: 'root'
})
export class FormExtensionService {
  private formSignal = signal<FormGroup | null>(null);
  private updateTrigger = signal(0);
  private customComputations = new Map<string, CustomComputation>();
  private readViewCache = new Map<string, Signal<ReadViewItem[]>>();

  setForm(form: FormGroup) {
    this.formSignal.set(form);
    this.readViewCache.clear();
    this.triggerUpdate();
  }

  extendControl(controlOrPath: AbstractControl | string, options: ExtendedControlOptions) {
    const control = this.resolveControl(controlOrPath);
    if (!control) return;

    const extendedControl = control as ExtendedAbstractControl;
    let changed = false;

    (Object.keys(options) as Array<keyof ExtendedControlOptions>).forEach(key => {
      if (key === 'regex') {
        if (!this.areRegexArraysEqual(extendedControl[key], options[key])) {
          extendedControl[key] = options[key] as any;
          changed = true;
        }
      } else if (extendedControl[key] !== options[key]) {
        extendedControl[key] = options[key] as any;
        changed = true;
      }
    });

    if (changed) {
      if (control instanceof FormGroup || control instanceof FormArray) {
        this.extendNestedControls(control);
      }
      this.triggerUpdate();
    }
  }

  private extendNestedControls(control: FormGroup | FormArray) {
    Object.values(control.controls).forEach(childControl => {
      this.extendControl(childControl, {});
    });
  }

  updateControlProperty<K extends keyof ExtendedControlOptions>(
    controlOrPath: AbstractControl | string,
    property: K,
    value: ExtendedControlOptions[K]
  ) {
    const control = this.resolveControl(controlOrPath);
    if (!control) return;

    const extendedControl = control as ExtendedAbstractControl;
    if (property === 'regex') {
      if (!this.areRegexArraysEqual(extendedControl[property], value as string[])) {
        extendedControl[property] = value as any;
        this.triggerUpdate();
      }
    } else if (extendedControl[property] !== value) {
      extendedControl[property] = value as any;
      this.triggerUpdate();
    }
  }

  private areRegexArraysEqual(arr1?: string[], arr2?: string[]): boolean {
    if (!arr1 && !arr2) return true;
    if (!arr1 || !arr2) return false;
    if (arr1.length !== arr2.length) return false;
    return arr1.every((regex, index) => regex === arr2[index]);
  }

  triggerUpdate() {
    this.updateTrigger.update(v => v + 1);
    this.readViewCache.clear();
  }

  registerCustomComputation(controlOrPath: AbstractControl | string, computation: CustomComputation) {
    const control = this.resolveControl(controlOrPath);
    if (!control) return;

    const path = this.getControlPath(control);
    this.customComputations.set(path, computation);
    this.triggerUpdate();
  }

  getReadView(controlOrPath: AbstractControl | string = ''): Signal<ReadViewItem[]> {
    const control = this.resolveControl(controlOrPath);
    if (!control) return computed(() => []);

    const path = this.getControlPath(control);
    if (!this.readViewCache.has(path)) {
      const readViewSignal = computed(() => {
        this.updateTrigger(); // Depend on the update trigger
        return this.getReadViewForControl(control);
      });
      this.readViewCache.set(path, readViewSignal);
    }
    return this.readViewCache.get(path)!;
  }

  private getReadViewForControl(control: AbstractControl): ReadViewItem[] {
    if (control instanceof FormGroup) {
      const groupItem = this.createReadViewItem(control);
      groupItem.children = Object.entries(control.controls)
        .map(([key, childControl]) => {
          const childItem = this.getReadViewForControl(childControl)[0];
          childItem.fldName = childItem.fldName || key;
          return childItem;
        })
        .filter(item => item.visible);
      return [groupItem];
    } else if (control instanceof FormArray) {
      return control.controls.map((ctrl, index) => {
        const item = this.createReadViewItem(ctrl);
        item.fldName = item.fldName || index.toString();
        return item;
      }).filter(item => item.visible);
    } else {
      return [this.createReadViewItem(control)];
    }
  }

  private createReadViewItem(control: AbstractControl): ReadViewItem {
    const extendedControl = control as ExtendedAbstractControl;
    const rawValue = control.value;
    let transformedValue = this.transformValue(rawValue, extendedControl);

    const item: ReadViewItem = {
      label: extendedControl.label || '',
      fldName: extendedControl.fldName || '',
      value: transformedValue,
      oldValue: extendedControl._oldValue,
      editable: extendedControl.editable ?? true,
      visible: extendedControl.visible ?? true,
      expand: extendedControl.expand ?? false,
      sectionName: extendedControl.sectionName,
      subSectionName: extendedControl.subSectionName,
      seq: extendedControl.seq,
      reqBorder: extendedControl.reqBorder ?? false,
      subName: extendedControl.subName
    };

    const path = this.getControlPath(control);
    const customComputation = this.customComputations.get(path);
    if (customComputation) {
      item.computedValue = customComputation.compute(control, control.root as FormGroup);
    }

    return item;
  }

  private transformValue(value: any, control: ExtendedAbstractControl): any {
    if (value === 'Y') return 'Yes';
    if (value === 'N') return 'No';

    if (control.lookupData && Array.isArray(control.lookupData)) {
      const matchingLookup = control.lookupData.find(item => item.value === value);
      if (matchingLookup) return matchingLookup.label;
    }

    return value;
  }

  getComputedValue(controlOrPath: AbstractControl | string): Signal<any | undefined> {
    return computed(() => {
      this.updateTrigger();
      const control = this.resolveControl(controlOrPath);
      if (!control) return undefined;

      const path = this.getControlPath(control);
      const customComputation = this.customComputations.get(path);
      return customComputation ? customComputation.compute(control, control.root as FormGroup) : undefined;
    });
  }

  applyDefaultValues(controlOrPath: AbstractControl | string, storeOldValue: boolean = false) {
    const control = this.resolveControl(controlOrPath);
    if (!control) return;

    this.applyDefaultValuesRecursive(control, storeOldValue);
    this.triggerUpdate();
  }

  private applyDefaultValuesRecursive(control: AbstractControl, storeOldValue: boolean) {
    const extendedControl = control as ExtendedAbstractControl;
    
    if (control instanceof FormGroup) {
      if (extendedControl.dfltVal !== undefined && this.isFormGroupEmpty(control)) {
        if (this.shouldStoreOldValue(extendedControl, storeOldValue)) {
          extendedControl._oldValue = this.getFormGroupValue(control);
        }
        this.setFormGroupValue(control, extendedControl.dfltVal);
      } else {
        Object.values(control.controls).forEach(childControl => {
          this.applyDefaultValuesRecursive(childControl, storeOldValue);
        });
      }
    } else if (control instanceof FormArray) {
      control.controls.forEach(ctrl => {
        this.applyDefaultValuesRecursive(ctrl, storeOldValue);
      });
    } else if (extendedControl.dfltVal !== undefined && control.value === null) {
      if (this.shouldStoreOldValue(extendedControl, storeOldValue)) {
        extendedControl._oldValue = control.value;
      }
      control.setValue(extendedControl.dfltVal);
    }
  }

  private shouldStoreOldValue(control: ExtendedAbstractControl, globalStoreOldValue: boolean): boolean {
    return globalStoreOldValue || control.oldValue !== undefined;
  }

  private isFormGroupEmpty(group: FormGroup): boolean {
    return Object.values(group.controls).every(control =>
      control.value === null || control.value === ''
    );
  }

  private getFormGroupValue(group: FormGroup): any {
    const value: any = {};
    Object.entries(group.controls).forEach(([key, control]) => {
      value[key] = control.value;
    });
    return value;
  }

  private setFormGroupValue(group: FormGroup, value: any) {
    if (typeof value === 'object' && value !== null) {
      Object.entries(value).forEach(([key, val]) => {
        if (group.get(key)) {
          group.get(key)!.setValue(val);
        }
      });
    }
  }

  getOldValue(controlOrPath: AbstractControl | string): any | undefined {
    const control = this.resolveControl(controlOrPath);
    return control ? (control as ExtendedAbstractControl)._oldValue : undefined;
  }

  getExtendedProperties(controlOrPath: AbstractControl | string): Partial<ExtendedControlProperties> | null {
    const control = this.resolveControl(controlOrPath);
    if (!control) return null;

    const extendedControl = control as ExtendedAbstractControl;
    return {
      label: extendedControl.label,
      fldName: extendedControl.fldName,
      visible: extendedControl.visible,
      editable: extendedControl.editable,
      lookup: extendedControl.lookup,
      lookupData: extendedControl.lookupData,
      regex: extendedControl.regex,
      fldMax: extendedControl.fldMax,
      fieldType: extendedControl.fieldType,
      dfltVal: extendedControl.dfltVal,
      required: extendedControl.required,
      oldValue: extendedControl._oldValue,
      expand: extendedControl.expand,
      sectionName: extendedControl.sectionName,
      subSectionName: extendedControl.subSectionName,
      seq: extendedControl.seq,
      reqBorder: extendedControl.reqBorder,
      subName: extendedControl.subName
    };
  }

  batchUpdates(updates: () => void) {
    updates();
    this.triggerUpdate();
  }

  private resolveControl(controlOrPath: AbstractControl | string): AbstractControl | null {
    if (typeof controlOrPath === 'string') {
      const form = this.formSignal();
      return form ? this.getControlByPath(form, controlOrPath) : null;
    }
    return controlOrPath;
  }

  private getControlByPath(form: FormGroup, path: string): AbstractControl | null {
    return path.split('.').reduce((acc: AbstractControl | null, part: string) => {
      if (acc instanceof FormGroup) {
        return acc.get(part);
      } else if (acc instanceof FormArray) {
        const index = parseInt(part, 10);
        return acc.at(index);
      }
      return null;
    }, form);
  }

  private getControlPath(control: AbstractControl): string {
    let path = '';
    let currentControl: AbstractControl | null = control;
    while (currentControl && currentControl.parent) {
      if (currentControl.parent instanceof FormArray) {
        const index = (currentControl.parent as FormArray).controls.indexOf(currentControl);
        path = `${index}${path ? '.' + path : ''}`;
      } else if (currentControl.parent instanceof FormGroup) {
        const parentGroup = currentControl.parent as FormGroup;
        const key = Object.keys(parentGroup.controls).find(k => parentGroup.get(k) === currentControl);
        if (key) {
          path = `${key}${path ? '.' + path : ''}`;
        }
      }
      currentControl = currentControl.parent;
    }
    return path;
  }
}
