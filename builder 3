import { Injectable, signal, computed, inject, WritableSignal } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { HttpClient } from '@angular/common/http';
import { WIDGET_CONFIG, WidgetConfig, WidgetState, SubMenuItem } from './widget-config';

@Injectable({ providedIn: 'root' })
export class ProfileBuilderService {
  private fb = inject(FormBuilder);
  private http = inject(HttpClient);

  private profiles: WritableSignal<FormGroup[]> = signal([]);
  private activeProfileIndex: WritableSignal<number | null> = signal(null);
  private profileWidgetStates: WritableSignal<Record<string, WidgetState>[]> = signal([]);
  private activeWidgetName: WritableSignal<string | null> = signal(null);
  private isLoading: WritableSignal<boolean> = signal(false);
  private dynamicSubMenus: WritableSignal<Record<string, SubMenuItem[]>> = signal({});

  private initialWidgetState: WidgetState = {
    hasError: false,
    errorMessage: '',
    visited: false,
    acknowledged: false,
    active: false,
    status: 'pending'
  };

  constructor() {
    this.loadDynamicSubMenus();
  }

  private async loadDynamicSubMenus() {
    for (const widget of WIDGET_CONFIG) {
      await this.loadSubMenusRecursively(widget);
    }
  }

  private async loadSubMenusRecursively(item: WidgetConfig | SubMenuItem) {
    if (typeof item.subMenu === 'function') {
      const subMenus = await item.subMenu();
      this.dynamicSubMenus.update(current => ({ ...current, [item.name]: subMenus }));
      for (const subItem of subMenus) {
        await this.loadSubMenusRecursively(subItem);
      }
    } else if (item.subMenu === 'dynamic' || item.subMenu === 'api') {
      const subMenus = await this.fetchDynamicSubMenu(item.name);
      this.dynamicSubMenus.update(current => ({ ...current, [item.name]: subMenus }));
      for (const subItem of subMenus) {
        await this.loadSubMenusRecursively(subItem);
      }
    } else if (Array.isArray(item.subMenu)) {
      for (const subItem of item.subMenu) {
        await this.loadSubMenusRecursively(subItem);
      }
    }
  }

  private async fetchDynamicSubMenu(widgetName: string): Promise<SubMenuItem[]> {
    try {
      const response = await this.http.get<SubMenuItem[]>(`/api/sub-menu/${widgetName}`).toPromise();
      return response || [];
    } catch (error) {
      console.error(`Error fetching dynamic sub-menu for ${widgetName}:`, error);
      return [];
    }
  }

  addNewProfile() {
    const newProfileForm = this.createProfileFormGroup();
    this.profiles.update(profiles => [...profiles, newProfileForm]);

    const newProfileWidgetStates = this.createInitialWidgetStates();
    this.profileWidgetStates.update(states => [...states, newProfileWidgetStates]);

    this.setActiveProfile(this.profiles().length - 1);
  }

  private createProfileFormGroup(): FormGroup {
    return this.fb.group({
      id: [''],
      name: [''],
      // ... other profile fields
    });
  }

  private createInitialWidgetStates(): Record<string, WidgetState> {
    return WIDGET_CONFIG.reduce((acc, widget) => {
      acc[widget.name] = { ...this.initialWidgetState };
      return acc;
    }, {} as Record<string, WidgetState>);
  }

  setActiveProfile(index: number) {
    if (index >= 0 && index < this.profiles().length) {
      this.activeProfileIndex.set(index);
      this.resetWidgetStates();
      this.loadInitialWidget();
    } else {
      console.error('Invalid profile index');
    }
  }

  getActiveProfile(): FormGroup | null {
    const index = this.activeProfileIndex();
    return index !== null ? this.profiles()[index] : null;
  }

  getActiveProfileWidgetStates(): Record<string, WidgetState> | null {
    const index = this.activeProfileIndex();
    return index !== null ? this.profileWidgetStates()[index] : null;
  }

  updateWidgetState(widgetName: string, update: Partial<WidgetState>, profileIndex?: number) {
    const index = profileIndex !== undefined ? profileIndex : this.activeProfileIndex();
    if (index === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[index] };
      profileStates[widgetName] = { ...profileStates[widgetName], ...update };

      // Update parent states
      this.updateParentStates(widgetName, profileStates);

      newAllStates[index] = profileStates;
      return newAllStates;
    });
  }

  private updateParentStates(widgetName: string, profileStates: Record<string, WidgetState>) {
    const parents = this.getParentWidgets(widgetName);
    parents.forEach(parent => {
      const childStates = this.getChildWidgetStates(parent.name, profileStates);
      const allChildrenCompleted = childStates.every(state => state.status === 'completed');
      const anyChildError = childStates.some(state => state.status === 'error');
      const allChildrenAcknowledged = childStates.every(state => state.acknowledged);
      const anyChildVisited = childStates.some(state => state.visited);

      let newStatus: WidgetState['status'] = 'pending';
      if (allChildrenCompleted) newStatus = 'completed';
      else if (anyChildError) newStatus = 'error';
      else if (childStates.some(state => state.status === 'in-progress')) newStatus = 'in-progress';

      profileStates[parent.name] = {
        ...profileStates[parent.name],
        status: newStatus,
        acknowledged: allChildrenAcknowledged,
        visited: anyChildVisited || profileStates[parent.name].visited,
        hasError: anyChildError
      };
    });
  }

  getVisibleWidgets = computed(() => {
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfileWidgetStates) return [];

    return WIDGET_CONFIG
      .filter(widget => widget.visible)
      .map(widget => ({
        ...widget,
        state: activeProfileWidgetStates[widget.name] || this.initialWidgetState
      }));
  });

  getSubMenuItems(item: WidgetConfig | SubMenuItem): SubMenuItem[] {
    if (Array.isArray(item.subMenu)) {
      return item.subMenu;
    } else if (this.dynamicSubMenus()[item.name]) {
      return this.dynamicSubMenus()[item.name];
    }
    return [];
  }

  setActiveWidget(widgetName: string) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[activeProfileIndex] };

      // Deactivate all widgets
      Object.keys(profileStates).forEach(key => {
        profileStates[key] = { ...profileStates[key], active: false };
      });

      // Activate the selected widget and its parents
      this.activateWidgetAndParents(widgetName, profileStates);

      newAllStates[activeProfileIndex] = profileStates;
      return newAllStates;
    });

    this.activeWidgetName.set(widgetName);
  }

  private activateWidgetAndParents(widgetName: string, profileStates: Record<string, WidgetState>) {
    const parents = this.getParentWidgets(widgetName);
    [...parents, { name: widgetName }].forEach(widget => {
      profileStates[widget.name] = {
        ...profileStates[widget.name],
        active: true,
        visited: true,
        status: profileStates[widget.name].status === 'pending' ? 'in-progress' : profileStates[widget.name].status
      };
    });
  }

  resetWidgetStates() {
    const index = this.activeProfileIndex();
    if (index !== null) {
      this.profileWidgetStates.update(allStates => {
        const newAllStates = [...allStates];
        newAllStates[index] = this.createInitialWidgetStates();
        return newAllStates;
      });
    }
  }

  loadInitialWidget() {
    const firstWidget = this.getVisibleWidgets()[0];
    if (firstWidget) {
      this.setActiveWidget(firstWidget.name);
    }
  }

  validateAllWidgets(): boolean {
    const activeProfile = this.getActiveProfile();
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfile || !activeProfileWidgetStates) return false;

    let isValid = true;
    WIDGET_CONFIG.forEach(widget => {
      if (widget.visible) {
        const widgetForm = activeProfile.get(widget.name);
        const widgetValid = widgetForm?.valid ?? false;
        this.updateWidgetState(widget.name, { 
          hasError: !widgetValid, 
          status: widgetValid ? 'completed' : 'error' 
        });
        isValid = isValid && widgetValid;
      }
    });
    return isValid;
  }

  loadAllWidgets() {
    WIDGET_CONFIG.forEach(widget => {
      if (widget.visible) {
        this.updateWidgetState(widget.name, { visited: true, status: 'in-progress' });
      }
    });
  }

  getNextIncompleteWidget(): string | null {
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfileWidgetStates) return null;

    const incompleteWidget = WIDGET_CONFIG.find(widget => 
      widget.visible && activeProfileWidgetStates[widget.name]?.status !== 'completed'
    );
    return incompleteWidget ? incompleteWidget.name : null;
  }

  getCompletionPercentage(): number {
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfileWidgetStates) return 0;

    const visibleWidgets = WIDGET_CONFIG.filter(w => w.visible);
    const completedWidgets = visibleWidgets.filter(w => 
      activeProfileWidgetStates[w.name]?.status === 'completed'
    );
    return (completedWidgets.length / visibleWidgets.length) * 100;
  }

  acknowledgeWidget(widgetName: string) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[activeProfileIndex] };

      // Acknowledge the widget and its children
      this.acknowledgeWidgetRecursively(widgetName, profileStates);

      // Update parent states
      this.updateParentStates(widgetName, profileStates);

      newAllStates[activeProfileIndex] = profileStates;
      return newAllStates;
    });
  }

  private acknowledgeWidgetRecursively(widgetName: string, profileStates: Record<string, WidgetState>) {
    profileStates[widgetName] = {
      ...profileStates[widgetName],
      acknowledged: true
    };

    const widget = this.findWidgetByName(widgetName);
    if (widget) {
      const subItems = this.getSubMenuItems(widget);
      subItems.forEach(subItem => {
        this.acknowledgeWidgetRecursively(subItem.name, profileStates);
      });
    }
  }

  private getParentWidgets(widgetName: string): (WidgetConfig | SubMenuItem)[] {
    const result: (WidgetConfig | SubMenuItem)[] = [];
    const findParent = (items: (WidgetConfig | SubMenuItem)[], parent?: WidgetConfig | SubMenuItem) => {
      for (const item of items) {
        if (item.name === widgetName && parent) {
          result.push(parent);
          return true;
        }
        const subItems = this.getSubMenuItems(item);
        if (subItems.length && findParent(subItems, item)) {
          if (parent) result.push(parent);
          return true;
        }
      }
      return false;
    };
    findParent(WIDGET_CONFIG);
    return result.reverse();
  }

  private getChildWidgetStates(widgetName: string, profileStates: Record<string, WidgetState>): WidgetState[] {
    const result: WidgetState[] = [];
    const widget = this.findWidgetByName(widgetName);
    if (widget) {
      const subItems = this.getSubMenuItems(widget);
      subItems.forEach(item => {
        if (profileStates[item.name]) {
          result.push(profileStates[item.name]);
        }
        result.push(...this.getChildWidgetStates(item.name, profileStates));
      });
    }
    return result;
  }

  private findWidgetByName(name: string): WidgetConfig | SubMenuItem | undefined {
    const find = (items: (WidgetConfig | SubMenuItem)[]): WidgetConfig | SubMenuItem | undefined => {
      for (const item of items) {
        if (item.name === name) return item;
        const subItems = this.getSubMenuItems(item);
        const found = find(subItems);
        if (found) return found;
      }
    };
    return find(WIDGET_CONFIG);
  }

  getIsLoading(): WritableSignal<boolean> {
    return this.isLoading;
  }

  async createOrEditProfile(partyId?: string) {
    this.isLoading.set(true);
    try {
      let profileData: any = {};
      const metadataData = await this.fetchMetadata();

      if (partyId) {
        // Editing existing profile
        profileData = await this.fetchPartyData(partyId);
        const existingProfileIndex = this.findProfileIndexByPartyId(partyId);

        if (existingProfileIndex !== -1) {
          // Update existing profile
          this.updateProfile(existingProfileIndex, profileData, metadataData);
          this.setActiveProfile(existingProfileIndex);
        } else {
          // Profile not found, create new
          this.addNewProfile();
          const newProfileIndex = this.profiles().length -
