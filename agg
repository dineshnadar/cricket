export interface ProcessedField extends LayoutField {
  controlName: string;
  groupPath?: string;
  isNested: boolean;
  invalid?: boolean;
  errors?: ValidationErrors | null;
  touched?: boolean;
  dirty?: boolean;
  status?: string;
  formattedValue?: any;
  cssClass?: string;
}

export interface ProcessedSection extends LayoutSection {
  processedFields?: ProcessedField[];
  nestedGroups?: {
    groupName: string;
    fields: ProcessedField[];
    isArray?: boolean;
  }[];
}

export interface ReadViewModel {
  sections: ProcessedSection[];
}

------

// syn-form-extension.service.ts
import { Injectable, signal, effect } from '@angular/core';
import { FormGroup, FormArray, AbstractControl, ValidatorFn, Validators } from '@angular/forms';
import { FormLayout, LayoutSection, LayoutField, ProcessedSection, ProcessedField, ReadViewModel } from './syn-form-extension.types';

@Injectable({
  providedIn: 'root'
})
export class SynFormExtensionService {
  private formCache = new WeakMap<AbstractControl, ReadViewModel>();
  private layoutCache = new WeakMap<FormGroup, FormLayout>();
  private processedLayoutCache = new WeakMap<FormGroup, ProcessedSection[]>();
  private validatorsCache = new WeakMap<AbstractControl, ValidatorFn[]>();
  
  private triggerUpdate = signal(0);
  private readonly updateDebounceTime = 100;
  private updateTimer: any;

  constructor() {
    effect(() => {
      this.triggerUpdate();
      this.clearCaches();
    });
  }

  getFieldClass(field: LayoutField): string {
    const classes = ['field-container'];
    
    // Column span
    classes.push(field.side === 'full' ? 'col-span-2' : 'col-span-1');
    
    // Alignment
    if (field.align) {
      classes.push(`text-${field.align}`);
    }

    // Required styling
    if (field.required) {
      classes.push('required-field');
    }

    // Field type
    if (field.fieldType) {
      classes.push(`field-type-${field.fieldType}`);
    }

    // Label position
    if (field.labelPosition) {
      classes.push(`label-${field.labelPosition}`);
    }

    // Custom class
    if (field.customClass) {
      classes.push(field.customClass);
    }

    return classes.join(' ');
  }

  setFormGroupLayout(formGroup: FormGroup, layout: FormLayout): void {
    this.layoutCache.set(formGroup, layout);
    this.processLayout(formGroup, layout);
    this.debouncedTriggerUpdate();
  }

  private processLayout(formGroup: FormGroup, layout: FormLayout) {
    const processedSections = layout.sections
      .sort((a, b) => (a.seq ?? 0) - (b.seq ?? 0))
      .map(section => this.processSection(section, formGroup));
    
    this.processedLayoutCache.set(formGroup, processedSections);
  }

  private processSection(section: LayoutSection, formGroup: FormGroup): ProcessedSection {
    return section.type === 'accordion' 
      ? this.processAccordionSection(section, formGroup)
      : this.processRegularSection(section, formGroup);
  }

  private processAccordionSection(section: LayoutSection, formGroup: FormGroup): ProcessedSection {
    const groupedFields = this.groupFieldsByParentWithSequence(section.fields);
    
    return {
      ...section,
      nestedGroups: Object.entries(groupedFields).map(([groupName, fields]) => ({
        groupName,
        fields: fields.map(field => this.processField(field, formGroup, groupName)),
        isArray: formGroup.get(groupName) instanceof FormArray
      }))
    };
  }

  private processRegularSection(section: LayoutSection, formGroup: FormGroup): ProcessedSection {
    return {
      ...section,
      processedFields: this.sortFieldsBySequence(section.fields)
        .map(field => this.processField(field, formGroup))
    };
  }

  private processField(field: LayoutField, formGroup: FormGroup, parentGroup?: string): ProcessedField {
    const pathParts = field.fldName.split('.');
    const controlName = pathParts[pathParts.length - 1];
    const groupPath = parentGroup || (pathParts.length > 1 ? pathParts[0] : '');
    const control = this.getControl(formGroup, field.fldName);

    return {
      ...field,
      controlName,
      groupPath,
      isNested: pathParts.length > 1 || !!parentGroup,
      invalid: control?.invalid,
      errors: control?.errors,
      touched: control?.touched,
      dirty: control?.dirty,
      status: control?.status,
      formattedValue: this.getFormattedValue(control, field),
      cssClass: this.getFieldClass(field)
    };
  }

  private getFormattedValue(control: AbstractControl | null, field: LayoutField): any {
    if (!control?.value) return '';

    switch (field.fieldType) {
      case 'select':
        return this.getLookupValue(control.value, field.lookupData);
      case 'checkbox':
        return control.value ? 'Yes' : 'No';
      case 'date':
        return control.value ? new Date(control.value).toLocaleDateString() : '';
      default:
        return control.value;
    }
  }

  private groupFieldsByParentWithSequence(fields: LayoutField[]): { [key: string]: LayoutField[] } {
    const groups = fields.reduce((acc, field) => {
      const pathParts = field.fldName.split('.');
      const parentGroup = pathParts.length > 1 ? pathParts[0] : '';
      
      if (!acc[parentGroup]) {
        acc[parentGroup] = [];
      }
      acc[parentGroup].push(field);
      return acc;
    }, {} as { [key: string]: LayoutField[] });

    Object.keys(groups).forEach(key => {
      groups[key] = this.sortFieldsBySequence(groups[key]);
    });

    return groups;
  }

  private sortFieldsBySequence(fields: LayoutField[]): LayoutField[] {
    return [...fields].sort((a, b) => (a.seq ?? 0) - (b.seq ?? 0));
  }

  private getLookupValue(value: any, lookupData?: Array<{ label: string; value: any }>): string {
    if (!lookupData) return value;
    const lookup = lookupData.find(item => item.value === value);
    return lookup ? lookup.label : value;
  }

  private getControl(formGroup: FormGroup, path: string): AbstractControl | null {
    return formGroup.get(path);
  }

  private debouncedTriggerUpdate(): void {
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
    }
    this.updateTimer = setTimeout(() => {
      this.triggerUpdate.update(v => v + 1);
    }, this.updateDebounceTime);
  }

  private clearCaches(): void {
    this.formCache = new WeakMap();
    this.processedLayoutCache = new WeakMap();
  }

  // Public methods for form manipulation
  updateFieldValue(formGroup: FormGroup, fieldPath: string, value: any): void {
    const control = this.getControl(formGroup, fieldPath);
    if (control) {
      control.setValue(value);
      this.debouncedTriggerUpdate();
    }
  }

  toggleFieldEditability(formGroup: FormGroup, fieldPath: string): void {
    const control = this.getControl(formGroup, fieldPath);
    if (control) {
      const currentEditability = this.getExtendedProperty(control, 'editable');
      this.updateControlProperty(control, 'editable', !currentEditability);
      this.debouncedTriggerUpdate();
    }
  }

  getExtendedProperty<K extends keyof ExtendedControlOptions>(
    control: AbstractControl,
    property: K
  ): ExtendedControlOptions[K] | undefined {
    return (control as any)[property];
  }

  updateControlProperty<K extends keyof ExtendedControlOptions>(
    control: AbstractControl,
    property: K,
    value: ExtendedControlOptions[K]
  ): void {
    (control as any)[property] = value;
    this.debouncedTriggerUpdate();
  }

  addArrayItem(formArray: FormArray, template?: any): void {
    if (template) {
      formArray.push(this.createFormGroupFromTemplate(template));
    } else {
      formArray.push(new FormControl(null));
    }
    this.debouncedTriggerUpdate();
  }

  private createFormGroupFromTemplate(template: any): FormGroup {
    const group = new FormGroup({});
    Object.keys(template).forEach(key => {
      const value = template[key];
      if (value instanceof FormGroup) {
        group.addControl(key, this.createFormGroupFromTemplate(value.controls));
      } else if (value instanceof FormArray) {
        group.addControl(key, new FormArray([]));
      } else {
        group.addControl(key, new FormControl(null));
      }
    });
    return group;
  }
}


------
// syn-form-template.component.ts
import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import { FormGroup, FormArray } from '@angular/forms';
import { ProcessedSection } from './syn-form-extension.types';
import { SynFormExtensionService } from './syn-form-extension.service';

@Component({
  selector: 'app-syn-form',
  changeDetection: ChangeDetectionStrategy.OnPush,
  templateUrl: './syn-form-template.component.html',
  styleUrls: ['./syn-form-template.component.scss']
})
export class SynFormTemplateComponent {
  @Input() formGroup!: FormGroup;
  @Input() sections: ProcessedSection[] = [];

  constructor(private formService: SynFormExtensionService) {}

  toggleAccordion(section: ProcessedSection): void {
    section.expanded = !section.expanded;
  }

  addArrayItem(arrayName: string): void {
    const array = this.formGroup.get(arrayName) as FormArray;
    if (array) {
      this.formService.addArrayItem(array);
    }
  }
}

----

<!-- syn-form-template.component.html -->
<form [formGroup]="formGroup" class="syn-form">
  <ng-container *ngFor="let section of sections">
    <ng-container [ngSwitch]="section.type">
      
      <!-- Regular Section -->
      <div *ngSwitchCase="'leftHeader'" 
           class="section-container" 
           [class.hidden]="!section.visible">
        <div class="section-header">
          <h2>{{section.leftHeader}}</h2>
        </div>
        
        <div class="grid-layout">
          <ng-container *ngFor="let field of section.processedFields">
            <div [class]="field.cssClass">
              <ng-container *ngTemplateOutlet="fieldTemplate; 
                            context: { $implicit: field }">
              </ng-container>
            </div>
          </ng-container>
        </div>
      </div>

      <!-- Accordion Section -->
      <div *ngSwitchCase="'accordion'" 
           class="accordion-section" 
           [class.hidden]="!section.visible">
        <div class="accordion-header"
             (click)="toggleAccordion(section)">
          <h3>{{section.accordionHeader}}</h3>
          <i class="accordion-icon"
             [class.expanded]="section.expanded"></i>
        </div>

        <div class="accordion-content" 
             [class.expanded]="section.expanded">
          <ng-container *ngFor="let group of section.nestedGroups">
            <div [formGroupName]="group.groupName" 
                 class="nested-group">
              <div class="grid-layout">
                <ng-container *ngFor="let field of group.fields">
                  <div [class]="field.cssClass">
                    <ng-container *ngTemplateOutlet="fieldTemplate; 
                                  context: { $implicit: field }">
                    </ng-container>
                  </div>
                </ng-container>
              </div>

              <div *ngIf="group.isArray" class="array-controls">
                <button type="button" 
                        (click)="addArrayItem(group.groupName)">
                  Add Item
                </button>
              </div>
            </div>
          </ng-container>
        </div>
      </div>

    </ng-container>
  </ng-container>
</form>

<!-- Field Template -->
<ng-template #fieldTemplate let-field>
  <div class="field-wrapper" [class.hidden]="!field.visible">
    <ng-container *ngIf="field.editable; else readOnlyTpl">
      <ng-container [ngSwitch]="field.fieldType">
        <!-- Text Input -->
        <ng-container *ngSwitchCase="'text'">
          <label [for]="field.fldName" 
                 [class.required]="field.required">
            {{field.label}}
          </label>
          <input [id]="field.fldName"
                 [formControlName]="field.controlName"
                 type="text"
                 class="form-input"
                 [class.error]="field.invalid">
          <div *ngIf="field.helpText" class="help-text">
            {{field.helpText}}
          </div>
          <div *ngIf="field.invalid && field.errors" class="error-message">
            <ng-container *ngIf="field.errors['required']">
              {{field.label}} is required
            </ng-container>
            <ng-container *ngIf="field.errors['pattern']">
              Invalid format
            </ng-container>
          </div>
        </ng-container>

        <!-- Select Input -->
        <ng-container *ngSwitchCase="'select'">
          <label [for]="field.fldName"
                 [class.required]="field.required">
            {{field.label}}
          </label>
          <select [id]="field.fldName"
                  [formControlName]="field.controlName"
                  class="form-select"
                  [class.error]="field.invalid">
            <option value="">-None-</option>
            <option *ngFor="let opt of field.lookupData"
                    [value]="opt.value">
              {{opt.label}}
            </option>
          </select>
          <div *ngIf="field.invalid && field.errors" class="error-message">
            <ng-container *ngIf="field.errors['required']">
              Please select {{field.label}}
            </ng-container>
          </div>
        </ng-container>

        <!-- Checkbox Input -->
        <ng-container *ngSwitchCase="'checkbox'">
          <div class="checkbox-wrapper">
            <input [id]="field.fldName"
                   [formControlName]="field.controlName"
                   type="checkbox"
                   class="form-checkbox">
            <label [for]="field.fldName">
              {{field.label}}
            </label>
          </div>
        </ng-container>

        <!-- Date Input -->
        <ng-container *ngSwitchCase="'date'">
          <label [for]="field.fldName"
                 [class.required]="field.required">
            {{field.label}}
          </label>
          <input [id]="field.fldName"
                 [formControlName]="field.controlName"
                 type="date"
                 class="form-input"
                 [class.error]="field.invalid">
          <div *ngIf="field.invalid && field.errors" class="error-message">
            <ng-container *ngIf="field.errors['required']">
              Please select a date
            </ng-container>
          </div>
        </ng-container>
      </ng-container>
    </ng-container>
  </div>
</ng-template>

<!-- Read Only Template -->
<ng-template #readOnlyTpl>
  <div class="read-only-field">
    <label>{{field.label}}</label>
    <div class="field-value" [innerHTML]="field.formattedValue || '-'">
    </div>
    <div *ngIf="field.helpText" class="help-text">
      {{field.helpText}}
    </div>
  </div>
</ng-template>

-----

// syn-form-template.component.scss
.syn-form {
  @apply max-w-7xl mx-auto;

  .section-container {
    @apply bg-white rounded-lg shadow-sm p-6 mb-6;

    .section-header {
      @apply mb-6;
      
      h2 {
        @apply text-xl font-semibold text-gray-800;
      }
    }
  }

  .accordion-section {
    @apply mb-4;

    .accordion-header {
      @apply p-4 bg-gray-50 rounded-t-lg border flex justify-between 
             items-center cursor-pointer;

      h3 {
        @apply text-lg font-medium;
      }

      .accordion-icon {
        @apply transition-transform duration-200;
        
        &:not(.expanded) {
          @apply rotate-0;
        }
        
        &.expanded {
          @apply rotate-180;
        }
      }
    }

    .accordion-content {
      @apply bg-white border-x border-b rounded-b-lg overflow-hidden 
             transition-all duration-200;
      
      &:not(.expanded) {
        @apply max-h-0;
      }
      
      &.expanded {
        @apply max-h-[1000px] p-4;
      }
    }
  }

  .grid-layout {
    @apply grid grid-cols-1 md:grid-cols-2 gap-4;
  }

  .field-wrapper {
    @apply mb-4;

    label {
      @apply block text-sm font-medium text-gray-700 mb-1;
      
      &.required:after {
        content: "*";
        @apply text-red-500 ml-1;
      }
    }

    .form-input,
    .form-select {
      @apply block w-full rounded-md border-gray-300 shadow-sm 
             focus:border-blue-500 focus:ring-blue-500 sm:text-sm;

      &.error {
        @apply border-red-500 focus:border-red-500 focus:ring-red-500;
      }
    }

    .checkbox-wrapper {
      @apply flex items-center;

      input {
        @apply h-4 w-4 text-blue-600 rounded border-gray-300 
               focus:ring-blue-500;
      }

      label {
        @apply ml-2 mb-0;
      }
    }

    .error-message {
      @apply mt-1 text-sm text-red-600;
    }

    .help-text {
      @apply mt-1 text-sm text-gray-500;
    }
  }

  .read-only-field {
    @apply mb-4;

    label {
      @apply block text-sm font-medium text-gray-700 mb-1;
    }

    .field-value {
      @apply mt-1 p-2 bg-gray-50 rounded border border-gray-200 
             text-sm text-gray-700;
    }
  }

  .array-controls {
    @apply mt-4 flex justify-end;

    button {
      @apply px-4 py-2 text-sm font-medium text-blue-700 bg-blue-100 
             rounded-md hover:bg-blue-200 focus:outline-none focus:ring-2 
             focus:ring-offset-2 focus:ring-blue-500;
    }
  }

  // Column span utilities
  .col-span-1 {
    @apply col-span-1;
  }

  .col-span-2 {
    @apply col-span-2;
  }

  // Alignment utilities
  .text-left {
    @apply text-left;
  }

  .text-center {
    @apply text-center;
  }

  .text-right {
    @apply text-right;
  }

  // Field type specific styles
  .field-type-text {
    // Add specific styles for text fields
  }

  .field-type-select {
    // Add specific styles for select fields
  }

  // Label position variants
  .label-top {
    @apply flex flex-col;
  }

  .label-left {
    @apply flex flex-row items-center;
    
    label {
      @apply mr-4 mb-0 w-1/3;
    }
  }

  .label-hidden {
    label {
      @apply sr-only;
    }
  }
}
