import { Component, inject, effect, OnInit, computed, signal } from '@angular/core';
import { AsyncPipe } from '@angular/common';
import { ProfileBuilderService } from './profile-builder.service';
import { LeftMenuComponent } from './left-menu.component';
import { WidgetConfig, ActiveWidget } from './widget-config';

@Component({
  selector: 'app-party-builder',
  standalone: true,
  imports: [AsyncPipe, LeftMenuComponent],
  template: `
    <!-- ... other template parts ... -->
    @if (activeProfile()) {
      <div class="party-builder">
        <app-left-menu />
        <div #widgetContainer></div>
        <div class="widget-navigation">
          <button (click)="loadPreviousWidget()" 
                  [disabled]="isNavigating() || isFirstWidget()">
            Previous
          </button>
          <button (click)="loadNextWidget()" 
                  [disabled]="isNavigating() || isLastWidget()">
            Next
          </button>
        </div>
        <div class="navigation-mode">
          <label>
            <input type="checkbox" [checked]="includeSubItems()" (change)="toggleNavigationMode()">
            Include sub-items in navigation
          </label>
        </div>
      </div>
    }
    <!-- ... other template parts ... -->
  `,
  styles: [/* ... */]
})
export class PartyBuilderComponent implements OnInit {
  private profileBuilder = inject(ProfileBuilderService);

  isNavigating = signal(false);
  includeSubItems = signal(false);

  activeWidget = this.profileBuilder.getActiveWidget;
  visibleWidgets = this.profileBuilder.getVisibleWidgets;

  isFirstWidget = computed(() => {
    const currentWidget = this.activeWidget();
    const widgets = this.visibleWidgets();
    if (!currentWidget || widgets.length === 0) return true;

    if (this.includeSubItems()) {
      return widgets[0].name === currentWidget.widgetName && 
             (!currentWidget.subItemName || 
              (Array.isArray(widgets[0].subMenu) && widgets[0].subMenu[0].name === currentWidget.subItemName));
    } else {
      return widgets[0].name === currentWidget.widgetName;
    }
  });

  isLastWidget = computed(() => {
    const currentWidget = this.activeWidget();
    const widgets = this.visibleWidgets();
    if (!currentWidget || widgets.length === 0) return true;

    const lastWidget = widgets[widgets.length - 1];
    if (this.includeSubItems()) {
      if (lastWidget.name !== currentWidget.widgetName) return false;
      if (Array.isArray(lastWidget.subMenu) && lastWidget.subMenu.length > 0) {
        return currentWidget.subItemName === lastWidget.subMenu[lastWidget.subMenu.length - 1].name;
      }
      return !currentWidget.subItemName;
    } else {
      return lastWidget.name === currentWidget.widgetName;
    }
  });

  async loadPreviousWidget() {
    if (this.isNavigating() || this.isFirstWidget()) return;
    
    this.isNavigating.set(true);
    try {
      const currentWidget = this.activeWidget();
      if (currentWidget) {
        const previousWidget = this.includeSubItems()
          ? await this.profileBuilder.getPreviousWidget(currentWidget)
          : this.getPreviousTopLevelWidget(currentWidget.widgetName);
        
        if (previousWidget) {
          this.profileBuilder.setActiveWidget(
            previousWidget.widgetName, 
            this.includeSubItems() ? previousWidget.subItemName : undefined
          );
        }
      }
    } finally {
      this.isNavigating.set(false);
    }
  }

  async loadNextWidget() {
    if (this.isNavigating() || this.isLastWidget()) return;
    
    this.isNavigating.set(true);
    try {
      const currentWidget = this.activeWidget();
      if (currentWidget) {
        const nextWidget = this.includeSubItems()
          ? await this.profileBuilder.getNextWidget(currentWidget)
          : this.getNextTopLevelWidget(currentWidget.widgetName);
        
        if (nextWidget) {
          this.profileBuilder.setActiveWidget(
            nextWidget.widgetName, 
            this.includeSubItems() ? nextWidget.subItemName : undefined
          );
        }
      }
    } finally {
      this.isNavigating.set(false);
    }
  }

  private getPreviousTopLevelWidget(currentWidgetName: string): ActiveWidget | null {
    const widgets = this.visibleWidgets();
    const currentIndex = widgets.findIndex(w => w.name === currentWidgetName);
    return currentIndex > 0 ? { widgetName: widgets[currentIndex - 1].name } : null;
  }

  private getNextTopLevelWidget(currentWidgetName: string): ActiveWidget | null {
    const widgets = this.visibleWidgets();
    const currentIndex = widgets.findIndex(w => w.name === currentWidgetName);
    return currentIndex < widgets.length - 1 ? { widgetName: widgets[currentIndex + 1].name } : null;
  }

  toggleNavigationMode() {
    this.includeSubItems.update(value => !value);
  }

  // ... other methods ...
}


---------

import { Injectable, inject, signal, computed, type WritableSignal, type Signal } from '@angular/core';
import { WIDGET_CONFIG, WidgetConfig, SubMenuItem } from './widget-config';
import { WidgetStateService } from './widget-state.service';
import { DynamicMenuService } from './dynamic-menu.service';

export interface ActiveWidget {
  widgetName: string;
  subItemName?: string;
}

@Injectable({ providedIn: 'root' })
export class ProfileBuilderService {
  private widgetStateService = inject(WidgetStateService);
  private dynamicMenuService = inject(DynamicMenuService);

  private activeWidgetSignal: WritableSignal<ActiveWidget | null> = signal(null);

  getActiveWidget: Signal<ActiveWidget | null> = computed(() => this.activeWidgetSignal());

  getVisibleWidgets = computed(() => {
    return WIDGET_CONFIG.filter(widget => 
      this.widgetStateService.isWidgetVisible(widget.name)
    );
  });

  setActiveWidget(widgetName: string, subItemName?: string) {
    this.activeWidgetSignal.set({ widgetName, subItemName });
    this.widgetStateService.setWidgetActive(widgetName, true);
    this.widgetStateService.setWidgetVisited(widgetName, true);
    this.widgetStateService.setWidgetStatus(widgetName, 'in-progress');
  }

  async getNextWidget(currentWidget: ActiveWidget): Promise<ActiveWidget | null> {
    const visibleWidgets = this.getVisibleWidgets()();
    const currentWidgetIndex = visibleWidgets.findIndex(w => w.name === currentWidget.widgetName);
    
    if (currentWidgetIndex === -1) return null;

    const currentWidgetConfig = visibleWidgets[currentWidgetIndex];
    
    // Handle sub-items if present
    if (currentWidget.subItemName) {
      const subItems = await this.getSubMenuItems(currentWidgetConfig);
      const currentSubItemIndex = subItems.findIndex(item => item.name === currentWidget.subItemName);
      if (currentSubItemIndex < subItems.length - 1) {
        return { widgetName: currentWidget.widgetName, subItemName: subItems[currentSubItemIndex + 1].name };
      }
    } else {
      // If current widget has sub-items and we're not on a sub-item, go to the first sub-item
      const subItems = await this.getSubMenuItems(currentWidgetConfig);
      if (subItems.length > 0) {
        return { widgetName: currentWidget.widgetName, subItemName: subItems[0].name };
      }
    }

    // Move to the next widget
    if (currentWidgetIndex < visibleWidgets.length - 1) {
      const nextWidget = visibleWidgets[currentWidgetIndex + 1];
      const nextSubItems = await this.getSubMenuItems(nextWidget);
      if (nextSubItems.length > 0) {
        return { widgetName: nextWidget.name, subItemName: nextSubItems[0].name };
      }
      return { widgetName: nextWidget.name };
    }

    return null;
  }

  async getPreviousWidget(currentWidget: ActiveWidget): Promise<ActiveWidget | null> {
    const visibleWidgets = this.getVisibleWidgets()();
    const currentWidgetIndex = visibleWidgets.findIndex(w => w.name === currentWidget.widgetName);
    
    if (currentWidgetIndex === -1) return null;

    const currentWidgetConfig = visibleWidgets[currentWidgetIndex];

    // Handle sub-items if present
    if (currentWidget.subItemName) {
      const subItems = await this.getSubMenuItems(currentWidgetConfig);
      const currentSubItemIndex = subItems.findIndex(item => item.name === currentWidget.subItemName);
      if (currentSubItemIndex > 0) {
        return { widgetName: currentWidget.widgetName, subItemName: subItems[currentSubItemIndex - 1].name };
      }
    }

    // Move to the previous widget
    if (currentWidgetIndex > 0) {
      const previousWidget = visibleWidgets[currentWidgetIndex - 1];
      const previousSubItems = await this.getSubMenuItems(previousWidget);
      if (previousSubItems.length > 0) {
        return { widgetName: previousWidget.name, subItemName: previousSubItems[previousSubItems.length - 1].name };
      }
      return { widgetName: previousWidget.name };
    }

    return null;
  }

  private async getSubMenuItems(widget: WidgetConfig): Promise<SubMenuItem[]> {
    if (Array.isArray(widget.subMenu)) {
      return widget.subMenu;
    } else if (widget.subMenu === 'dynamic' || widget.subMenu === 'api') {
      return await this.dynamicMenuService.loadDynamicSubMenu(widget.name);
    } else if (typeof widget.subMenu === 'function') {
      return await widget.subMenu();
    }
    return [];
  }

  findWidgetByName(name: string): WidgetConfig | undefined {
    return WIDGET_CONFIG.find(widget => widget.name === name);
  }

  // ... other methods ...
}
