import { Injectable, signal, computed, type WritableSignal, type Signal } from '@angular/core';
import { WidgetConfig } from './widget-config';

interface ActiveWidget {
  widgetName: string;
  subItemName?: string;
}

@Injectable({ providedIn: 'root' })
export class ProfileBuilderService {
  private activeWidgetSignal: WritableSignal<ActiveWidget | null> = signal(null);

  getActiveWidget: Signal<ActiveWidget | null> = computed(() => {
    const activeWidget = this.activeWidgetSignal();
    if (!activeWidget) return null;

    // Optionally, you can add more logic here to enrich the active widget information
    // For example, fetching the full WidgetConfig based on the active widget name
    const widgetConfig = this.findWidgetByName(activeWidget.widgetName);
    
    return {
      ...activeWidget,
      displayName: widgetConfig?.displayName || activeWidget.widgetName,
      // Add any other relevant metadata from widgetConfig
    };
  });

  setActiveWidget(widgetName: string, subItemName?: string) {
    this.activeWidgetSignal.set({ widgetName, subItemName });
    // Other logic for setting the active widget (e.g., updating widget states)
  }

  private findWidgetByName(name: string): WidgetConfig | undefined {
    // Implementation to find a widget config by name
    // This would typically search through your WIDGET_CONFIG array
  }

  // Other methods in your service...
}
--------
import { Component, ViewChild, ViewContainerRef, inject, effect, OnInit, computed } from '@angular/core';
import { AsyncPipe } from '@angular/common';
import { ProfileBuilderService } from './profile-builder.service';
import { LeftMenuComponent } from './left-menu.component';

@Component({
  selector: 'app-party-builder',
  standalone: true,
  imports: [AsyncPipe, LeftMenuComponent],
  template: `
    <!-- ... other template parts ... -->
    @if (activeProfile()) {
      <div class="party-builder">
        <app-left-menu />
        <div #widgetContainer></div>
        <div class="widget-navigation">
          <button (click)="loadPreviousWidget()" [disabled]="isNavigating || !hasPreviousWidget()">Previous</button>
          <button (click)="loadNextWidget()" [disabled]="isNavigating || !hasNextWidget()">Next</button>
        </div>
      </div>
    }
    <!-- ... other template parts ... -->
  `,
  styles: [/* ... */]
})
export class PartyBuilderComponent implements OnInit {
  @ViewChild('widgetContainer', { read: ViewContainerRef, static: false })
  widgetContainer!: ViewContainerRef;

  private profileBuilder = inject(ProfileBuilderService);

  isNavigating = false;

  // ... other properties ...

  async loadPreviousWidget() {
    if (this.isNavigating) return;
    this.isNavigating = true;
    const currentWidget = this.profileBuilder.getActiveWidget();
    if (currentWidget) {
      const previousWidget = await this.profileBuilder.getPreviousWidget(currentWidget);
      if (previousWidget) {
        this.profileBuilder.setActiveWidget(previousWidget.widgetName, previousWidget.subItemName);
      }
    }
    this.isNavigating = false;
  }

  async loadNextWidget() {
    if (this.isNavigating) return;
    this.isNavigating = true;
    const currentWidget = this.profileBuilder.getActiveWidget();
    if (currentWidget) {
      const nextWidget = await this.profileBuilder.getNextWidget(currentWidget);
      if (nextWidget) {
        this.profileBuilder.setActiveWidget(nextWidget.widgetName, nextWidget.subItemName);
      }
    }
    this.isNavigating = false;
  }

  // ... other methods ...
}

-----

import { Injectable, inject } from '@angular/core';
import { WIDGET_CONFIG, WidgetConfig, SubMenuItem } from './widget-config';
import { WidgetStateService } from './widget-state.service';
import { DynamicMenuService } from './dynamic-menu.service';

interface ActiveWidget {
  widgetName: string;
  subItemName?: string;
}

@Injectable({ providedIn: 'root' })
export class ProfileBuilderService {
  private widgetStateService = inject(WidgetStateService);
  private dynamicMenuService = inject(DynamicMenuService);

  // ... other properties and methods

  async getNextWidget(currentWidget: ActiveWidget): Promise<ActiveWidget | null> {
    const visibleWidgets = this.getVisibleWidgets()();
    const currentWidgetIndex = visibleWidgets.findIndex(w => w.name === currentWidget.widgetName);
    
    if (currentWidgetIndex === -1) return null;

    const currentWidgetConfig = visibleWidgets[currentWidgetIndex];
    
    // Handle current widget's sub-menu
    if (currentWidget.subItemName) {
      const subItems = await this.getSubMenuItems(currentWidgetConfig);
      const currentSubItemIndex = subItems.findIndex(item => item.name === currentWidget.subItemName);
      if (currentSubItemIndex < subItems.length - 1) {
        return { widgetName: currentWidget.widgetName, subItemName: subItems[currentSubItemIndex + 1].name };
      }
    }

    // Move to the next widget
    if (currentWidgetIndex < visibleWidgets.length - 1) {
      const nextWidget = visibleWidgets[currentWidgetIndex + 1];
      const nextSubItems = await this.getSubMenuItems(nextWidget);
      if (nextSubItems.length > 0) {
        return { widgetName: nextWidget.name, subItemName: nextSubItems[0].name };
      }
      return { widgetName: nextWidget.name };
    }

    return null;
  }

  async getPreviousWidget(currentWidget: ActiveWidget): Promise<ActiveWidget | null> {
    const visibleWidgets = this.getVisibleWidgets()();
    const currentWidgetIndex = visibleWidgets.findIndex(w => w.name === currentWidget.widgetName);
    
    if (currentWidgetIndex === -1) return null;

    const currentWidgetConfig = visibleWidgets[currentWidgetIndex];

    // Handle current widget's sub-menu
    if (currentWidget.subItemName) {
      const subItems = await this.getSubMenuItems(currentWidgetConfig);
      const currentSubItemIndex = subItems.findIndex(item => item.name === currentWidget.subItemName);
      if (currentSubItemIndex > 0) {
        return { widgetName: currentWidget.widgetName, subItemName: subItems[currentSubItemIndex - 1].name };
      }
    }

    // Move to the previous widget
    if (currentWidgetIndex > 0) {
      const previousWidget = visibleWidgets[currentWidgetIndex - 1];
      const previousSubItems = await this.getSubMenuItems(previousWidget);
      if (previousSubItems.length > 0) {
        return { widgetName: previousWidget.name, subItemName: previousSubItems[previousSubItems.length - 1].name };
      }
      return { widgetName: previousWidget.name };
    }

    return null;
  }

  private async getSubMenuItems(widget: WidgetConfig): Promise<SubMenuItem[]> {
    if (Array.isArray(widget.subMenu)) {
      return widget.subMenu;
    } else if (widget.subMenu === 'dynamic' || widget.subMenu === 'api') {
      return await this.dynamicMenuService.loadDynamicSubMenu(widget.name);
    } else if (typeof widget.subMenu === 'function') {
      return await widget.subMenu();
    }
    return [];
  }

  // ... other methods
}
