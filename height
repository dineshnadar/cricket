import { Directive, ElementRef, Input, effect, signal, computed, untracked, inject, DestroyRef, AfterViewInit, Renderer2 } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { fromEvent, animationFrameScheduler } from 'rxjs';
import { debounceTime, throttleTime, observeOn } from 'rxjs/operators';

@Directive({
  selector: '[appSetHeight]',
  standalone: true
})
export class SetHeightDirective implements AfterViewInit {
  private el = inject(ElementRef);
  private renderer = inject(Renderer2);
  private destroyRef = inject(DestroyRef);

  @Input({ required: true }) set appSetHeight(value: number) {
    this.heightRatio.set(value);
  }
  @Input() set heightOffset(value: number | string) {
    this.offset.set(this.parseOffset(value));
  }
  @Input() siblingSelector: string = '';

  private windowHeight = signal(window.innerHeight);
  private heightRatio = signal(1);
  private offset = signal(0);
  private siblingHeight = signal(0);

  private computedHeight = computed(() => 
    Math.max(0, this.windowHeight() * this.heightRatio() - this.offset() - this.siblingHeight())
  );

  constructor() {
    effect(() => {
      const height = `${this.computedHeight()}px`;
      untracked(() => {
        animationFrameScheduler.schedule(() => {
          this.renderer.setStyle(this.el.nativeElement, 'height', height);
        });
      });
    }, { allowSignalWrites: true });
  }

  ngAfterViewInit() {
    this.setupResizeListener();
    this.updateSiblingHeight();

    if (this.siblingSelector) {
      const sibling = this.el.nativeElement.parentElement.querySelector(this.siblingSelector);
      if (sibling) {
        const observer = new MutationObserver(() => this.updateSiblingHeight());
        observer.observe(sibling, { childList: true, subtree: true, attributes: true });
        this.destroyRef.onDestroy(() => observer.disconnect());
      }
    }
  }

  private setupResizeListener() {
    fromEvent(window, 'resize')
      .pipe(
        throttleTime(16),
        debounceTime(100),
        observeOn(animationFrameScheduler),
        takeUntilDestroyed(this.destroyRef)
      )
      .subscribe(() => {
        this.windowHeight.set(window.innerHeight);
        this.updateSiblingHeight();
      });
  }

  private updateSiblingHeight() {
    if (this.siblingSelector) {
      const sibling = this.el.nativeElement.parentElement.querySelector(this.siblingSelector);
      if (sibling) {
        animationFrameScheduler.schedule(() => {
          this.siblingHeight.set(sibling.offsetHeight);
        });
      }
    }
  }

  private parseOffset(value: number | string): number {
    if (typeof value === 'number') return value;
    if (typeof value === 'string') {
      if (value.endsWith('px')) return parseInt(value, 10);
      if (value.endsWith('%')) return (parseInt(value, 10) / 100) * this.windowHeight();
    }
    return 0;
  }
}


----------

import { ComponentFixture, TestBed } from '@angular/core/testing';
import { Component, DebugElement, Renderer2 } from '@angular/core';
import { By } from '@angular/platform-browser';
import { SetHeightDirective } from './set-height.directive';

@Component({
  template: `<div [appSetHeight]="ratio" [heightOffset]="offset">Test</div>`
})
class TestComponent {
  ratio = 1;
  offset = '0px';
}

describe('SetHeightDirective', () => {
  let component: TestComponent;
  let fixture: ComponentFixture<TestComponent>;
  let divElement: DebugElement;
  let renderer: Renderer2;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [TestComponent],
      imports: [SetHeightDirective],
      providers: [
        {
          provide: Renderer2,
          useValue: {
            setStyle: jest.fn()
          }
        }
      ]
    }).compileComponents();

    fixture = TestBed.createComponent(TestComponent);
    component = fixture.componentInstance;
    divElement = fixture.debugElement.query(By.css('div'));
    renderer = TestBed.inject(Renderer2);
    fixture.detectChanges();
  });

  it('should create an instance', () => {
    const directive = divElement.injector.get(SetHeightDirective);
    expect(directive).toBeTruthy();
  });

  it('should set full height when ratio is 1', () => {
    component.ratio = 1;
    fixture.detectChanges();
    
    jest.runAllTimers();
    
    expect(renderer.setStyle).toHaveBeenCalledWith(
      divElement.nativeElement,
      'height',
      `${window.innerHeight}px`
    );
  });

  it('should set half height when ratio is 0.5', () => {
    component.ratio = 0.5;
    fixture.detectChanges();
    
    jest.runAllTimers();
    
    expect(renderer.setStyle).toHaveBeenCalledWith(
      divElement.nativeElement,
      'height',
      `${window.innerHeight * 0.5}px`
    );
  });

  it('should apply pixel offset correctly', () => {
    component.ratio = 1;
    component.offset = '50px';
    fixture.detectChanges();
    
    jest.runAllTimers();
    
    expect(renderer.setStyle).toHaveBeenCalledWith(
      divElement.nativeElement,
      'height',
      `${window.innerHeight - 50}px`
    );
  });

  it('should apply percentage offset correctly', () => {
    component.ratio = 1;
    component.offset = '10%';
    fixture.detectChanges();
    
    jest.runAllTimers();
    
    expect(renderer.setStyle).toHaveBeenCalledWith(
      divElement.nativeElement,
      'height',
      `${window.innerHeight * 0.9}px`
    );
  });

  it('should update height on window resize', () => {
    const originalHeight = window.innerHeight;
    const newHeight = originalHeight + 100;
    
    // Mock window resize
    Object.defineProperty(window, 'innerHeight', { value: newHeight, configurable: true });
    
    // Trigger resize event
    window.dispatchEvent(new Event('resize'));
    
    // We need to manually trigger the debounced resize handler
    jest.runAllTimers();
    
    expect(renderer.setStyle).toHaveBeenCalledWith(
      divElement.nativeElement,
      'height',
      `${newHeight}px`
    );
    
    // Reset window.innerHeight
    Object.defineProperty(window, 'innerHeight', { value: originalHeight, configurable: true });
  });
});
