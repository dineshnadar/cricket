import { Injectable, inject } from '@angular/core';
import { FormGroup } from '@angular/forms';
import { ValidationService, FieldRule, ValidationController } from './enhanced-validation.service';

export interface AddressValidationConfig {
  // Simple boolean flag for whether address is required
  isRequired?: boolean;
  
  // Country code values (customizable)
  countryValues?: {
    usa?: string;
    canada?: string;
  };
  
  // Custom field names if different from default
  fieldNames?: {
    addressLine1?: string;
    addressLine2?: string;
    city?: string;
    stateCode?: string;
    zip?: string;
    provinceCode?: string;
    postalCode?: string;
    countryCode?: string;
  };
}

@Injectable({
  providedIn: 'root'
})
export class AddressValidationService {
  private validationService = inject(ValidationService);
  
  private defaultFieldNames = {
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    stateCode: 'stateCode',
    zip: 'zip',
    provinceCode: 'provinceCode',
    postalCode: 'postalCode',
    countryCode: 'countryCode'
  };
  
  private defaultCountryValues = {
    usa: 'USA',
    canada: 'CANADA'
  };

  /**
   * Register address validation rules for a FormGroup
   */
  registerAddressValidation(
    formId: string,
    addressForm: FormGroup,
    config: AddressValidationConfig = {}
  ): ValidationController {
    // Merge configuration with defaults
    const fieldNames = { ...this.defaultFieldNames, ...config.fieldNames };
    const countryValues = { ...this.defaultCountryValues, ...config.countryValues };
    
    // Create validation rules
    const addressRules = this.createAddressValidationRules(fieldNames, countryValues, config);
    
    // Register with validation service using the default method
    const controller = this.validationService.registerRules(formId, addressForm, addressRules);
    
    return controller;
  }

  /**
   * Create address validation rules based on configuration
   */
  private createAddressValidationRules(
    fieldNames: any,
    countryValues: any,
    config: AddressValidationConfig
  ): Record<string, FieldRule[]> {
    
    // Helper function to create "address line is not empty" condition
    const addressLineNotEmptyCondition = {
      operator: 'or' as const,
      conditions: [
        {
          field: fieldNames.addressLine1,
          fieldOperator: 'isNotEmpty' as const
        },
        {
          field: fieldNames.addressLine2,
          fieldOperator: 'isNotEmpty' as const
        }
      ]
    };

    const addressRules: Record<string, FieldRule[]> = {};

    // Country Code - always visible
    addressRules[fieldNames.countryCode] = [];
    
    if (config.isRequired) {
      // If address is always required, country code is always required
      addressRules[fieldNames.countryCode].push({
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    } else {
      // Country code is required only if address lines are not empty
      addressRules[fieldNames.countryCode].push({
        conditions: [addressLineNotEmptyCondition],
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    }

    // Address Line 1 - always visible
    addressRules[fieldNames.addressLine1] = [
      {
        visibility: { value: true }
      }
    ];
    
    // If address is required, make address line 1 required
    if (config.isRequired) {
      addressRules[fieldNames.addressLine1].push({
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    }

    // Address Line 2 - always visible, never required
    addressRules[fieldNames.addressLine2] = [
      {
        visibility: { value: true }
      }
    ];

    // City - visible based on country code
    addressRules[fieldNames.city] = [
      // Visibility rule - visible for all countries
      {
        conditions: [
          {
            operator: 'or',
            conditions: [
              { field: fieldNames.countryCode, fieldOperator: 'isEmpty' },
              { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.usa },
              { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.canada },
              {
                operator: 'and',
                conditions: [
                  { field: fieldNames.countryCode, fieldOperator: 'isNotEmpty' },
                  { field: fieldNames.countryCode, fieldOperator: 'notEquals', value: countryValues.usa },
                  { field: fieldNames.countryCode, fieldOperator: 'notEquals', value: countryValues.canada }
                ]
              }
            ]
          }
        ],
        visibility: { value: true, clearOnHide: true }
      }
    ];

    // Add required rule for city based on configuration
    if (config.isRequired) {
      // If address is always required, city is always required
      addressRules[fieldNames.city].push({
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    } else {
      // City is required only if address lines are not empty
      addressRules[fieldNames.city].push({
        conditions: [addressLineNotEmptyCondition],
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    }

    // State Code - visible only for USA or empty country
    addressRules[fieldNames.stateCode] = [
      // Visibility rule
      {
        conditions: [
          {
            operator: 'or',
            conditions: [
              { field: fieldNames.countryCode, fieldOperator: 'isEmpty' },
              { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.usa }
            ]
          }
        ],
        visibility: { value: true, clearOnHide: true }
      }
    ];

    // Add required rule for state code
    if (config.isRequired) {
      // If address is always required, state code is required when visible
      addressRules[fieldNames.stateCode].push({
        conditions: [
          {
            operator: 'or',
            conditions: [
              { field: fieldNames.countryCode, fieldOperator: 'isEmpty' },
              { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.usa }
            ]
          }
        ],
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    } else {
      // State code is required only if address lines are not empty AND country is USA or empty
      addressRules[fieldNames.stateCode].push({
        conditions: [
          {
            operator: 'and',
            conditions: [
              addressLineNotEmptyCondition,
              {
                operator: 'or',
                conditions: [
                  { field: fieldNames.countryCode, fieldOperator: 'isEmpty' },
                  { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.usa }
                ]
              }
            ]
          }
        ],
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    }

    // ZIP Code - visible only for USA or empty country
    addressRules[fieldNames.zip] = [
      // Visibility rule
      {
        conditions: [
          {
            operator: 'or',
            conditions: [
              { field: fieldNames.countryCode, fieldOperator: 'isEmpty' },
              { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.usa }
            ]
          }
        ],
        visibility: { value: true, clearOnHide: true }
      }
    ];

    // Add required rule for zip code
    if (config.isRequired) {
      // If address is always required, zip code is required when visible
      addressRules[fieldNames.zip].push({
        conditions: [
          {
            operator: 'or',
            conditions: [
              { field: fieldNames.countryCode, fieldOperator: 'isEmpty' },
              { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.usa }
            ]
          }
        ],
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    } else {
      // ZIP code is required only if address lines are not empty AND country is USA or empty
      addressRules[fieldNames.zip].push({
        conditions: [
          {
            operator: 'and',
            conditions: [
              addressLineNotEmptyCondition,
              {
                operator: 'or',
                conditions: [
                  { field: fieldNames.countryCode, fieldOperator: 'isEmpty' },
                  { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.usa }
                ]
              }
            ]
          }
        ],
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    }

    // Province Code - visible only for Canada
    addressRules[fieldNames.provinceCode] = [
      // Visibility rule
      {
        conditions: [
          { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.canada }
        ],
        visibility: { value: true, clearOnHide: true }
      }
    ];

    // Add required rule for province code
    if (config.isRequired) {
      // If address is always required, province code is required when visible
      addressRules[fieldNames.provinceCode].push({
        conditions: [
          { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.canada }
        ],
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    } else {
      // Province code is required only if address lines are not empty AND country is Canada
      addressRules[fieldNames.provinceCode].push({
        conditions: [
          {
            operator: 'and',
            conditions: [
              addressLineNotEmptyCondition,
              { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.canada }
            ]
          }
        ],
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    }

    // Postal Code - visible for Canada or other countries (not USA)
    addressRules[fieldNames.postalCode] = [
      // Visibility rule
      {
        conditions: [
          {
            operator: 'or',
            conditions: [
              { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.canada },
              {
                operator: 'and',
                conditions: [
                  { field: fieldNames.countryCode, fieldOperator: 'isNotEmpty' },
                  { field: fieldNames.countryCode, fieldOperator: 'notEquals', value: countryValues.usa },
                  { field: fieldNames.countryCode, fieldOperator: 'notEquals', value: countryValues.canada }
                ]
              }
            ]
          }
        ],
        visibility: { value: true, clearOnHide: true }
      }
    ];

    // Add required rule for postal code
    if (config.isRequired) {
      // If address is always required, postal code is required when visible
      addressRules[fieldNames.postalCode].push({
        conditions: [
          {
            operator: 'or',
            conditions: [
              { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.canada },
              {
                operator: 'and',
                conditions: [
                  { field: fieldNames.countryCode, fieldOperator: 'isNotEmpty' },
                  { field: fieldNames.countryCode, fieldOperator: 'notEquals', value: countryValues.usa },
                  { field: fieldNames.countryCode, fieldOperator: 'notEquals', value: countryValues.canada }
                ]
              }
            ]
          }
        ],
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    } else {
      // Postal code is required only if address lines are not empty AND country is Canada or other
      addressRules[fieldNames.postalCode].push({
        conditions: [
          {
            operator: 'and',
            conditions: [
              addressLineNotEmptyCondition,
              {
                operator: 'or',
                conditions: [
                  { field: fieldNames.countryCode, fieldOperator: 'equals', value: countryValues.canada },
                  {
                    operator: 'and',
                    conditions: [
                      { field: fieldNames.countryCode, fieldOperator: 'isNotEmpty' },
                      { field: fieldNames.countryCode, fieldOperator: 'notEquals', value: countryValues.usa },
                      { field: fieldNames.countryCode, fieldOperator: 'notEquals', value: countryValues.canada }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        validation: {
          rules: [{ type: 'required' }]
        }
      });
    }

    return addressRules;
  }
}

// Usage example
@Component({
  selector: 'app-employee-simple',
  template: `
    <form [formGroup]="employeeForm">
      <div class="form-group">
        <label for="employeeStatus">Employee Status:</label>
        <select id="employeeStatus" formControlName="employeeStatus" (change)="onEmployeeStatusChange($event)">
          <option value="">Select Status</option>
          <option value="employed">Employed</option>
          <option value="unemployed">Unemployed</option>
        </select>
      </div>

      <div formGroupName="address">
        <h3>Address Information</h3>
        
        <div class="form-group">
          <label for="countryCode">Country:</label>
          <select id="countryCode" formControlName="countryCode">
            <option value="">Select Country</option>
            <option value="USA">United States</option>
            <option value="CANADA">Canada</option>
            <option value="OTHER">Other</option>
          </select>
          <div *ngIf="employeeForm.get('address.countryCode')?.errors?.required && employeeForm.get('address.countryCode')?.touched" class="error">
            Country is required
          </div>
        </div>
        
        <div class="form-group">
          <label for="addressLine1">Address Line 1:</label>
          <input id="addressLine1" formControlName="addressLine1" />
          <div *ngIf="employeeForm.get('address.addressLine1')?.errors?.required && employeeForm.get('address.addressLine1')?.touched" class="error">
            Address Line 1 is required
          </div>
        </div>
        
        <div class="form-group">
          <label for="addressLine2">Address Line 2:</label>
          <input id="addressLine2" formControlName="addressLine2" />
        </div>
        
        <div class="form-group">
          <label for="city">City:</label>
          <input id="city" formControlName="city" />
          <div *ngIf="employeeForm.get('address.city')?.errors?.required && employeeForm.get('address.city')?.touched" class="error">
            City is required
          </div>
        </div>
        
        <div class="form-group">
          <label for="stateCode">State:</label>
          <select id="stateCode" formControlName="stateCode">
            <option value="">Select State</option>
            <option value="CA">California</option>
            <option value="NY">New York</option>
            <option value="TX">Texas</option>
          </select>
          <div *ngIf="employeeForm.get('address.stateCode')?.errors?.required && employeeForm.get('address.stateCode')?.touched" class="error">
            State is required
          </div>
        </div>
        
        <div class="form-group">
          <label for="zip">ZIP Code:</label>
          <input id="zip" formControlName="zip" />
          <div *ngIf="employeeForm.get('address.zip')?.errors?.required && employeeForm.get('address.zip')?.touched" class="error">
            ZIP Code is required
          </div>
        </div>
        
        <div class="form-group">
          <label for="provinceCode">Province:</label>
          <select id="provinceCode" formControlName="provinceCode">
            <option value="">Select Province</option>
            <option value="ON">Ontario</option>
            <option value="BC">British Columbia</option>
            <option value="AB">Alberta</option>
          </select>
          <div *ngIf="employeeForm.get('address.provinceCode')?.errors?.required && employeeForm.get('address.provinceCode')?.touched" class="error">
            Province is required
          </div>
        </div>
        
        <div class="form-group">
          <label for="postalCode">Postal Code:</label>
          <input id="postalCode" formControlName="postalCode" />
          <div *ngIf="employeeForm.get('address.postalCode')?.errors?.required && employeeForm.get('address.postalCode')?.touched" class="error">
            Postal Code is required
          </div>
        </div>
      </div>
    </form>
  `,
  styles: [`
    .form-group {
      margin-bottom: 1rem;
    }
    .error {
      color: red;
      font-size: 0.8rem;
      margin-top: 0.25rem;
    }
  `]
})
export class EmployeeSimpleComponent implements OnInit {
  private addressValidationService = inject(AddressValidationService);
  private fb = inject(FormBuilder);

  employeeForm: FormGroup;
  addressController: ValidationController;

  ngOnInit() {
    this.employeeForm = this.fb.group({
      employeeStatus: [''],
      address: this.fb.group({
        addressLine1: [''],
        addressLine2: [''],
        city: [''],
        stateCode: [''],
        zip: [''],
        provinceCode: [''],
        postalCode: [''],
        countryCode: ['']
      })
    });

    // Register address validation with initial config (not required)
    this.addressController = this.addressValidationService.registerAddressValidation(
      'address',
      this.employeeForm.get('address') as FormGroup,
      { isRequired: false }
    );
  }

  onEmployeeStatusChange(event: Event) {
    const target = event.target as HTMLSelectElement;
    const isEmployed = target.value === 'employed';
    
    // Re-register address validation with new configuration
    this.addressController = this.addressValidationService.registerAddressValidation(
      'address',
      this.employeeForm.get('address') as FormGroup,
      { isRequired: isEmployed }
    );
  }
}
