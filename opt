function optimizedGroupFieldsThreeLevels(fields, level = 1, sortByLabel = false) {
  const grouped = level !== 2 ? { fieldsLeft: [], fieldsRight: [], fieldsFull: [] } : [];
  let leftCount = 0, rightCount = 0;

  for (let i = 0; i < fields.length; i++) {
    const originalField = fields[i];
    let field = { ...originalField }; // Shallow copy to avoid modifying original

    if (field.seq == null) {
      field.seq = i; // Assign seq without modifying original
    }

    if (field.fields && field.fields.length) {
      field.fields = optimizedGroupFieldsThreeLevels(field.fields, level + 1, sortByLabel);
    }

    if (level === 2) {
      grouped.push(field);
    } else {
      const side = field.side && ['left', 'right', 'full'].includes(field.side)
        ? field.side
        : (leftCount <= rightCount ? (leftCount++, 'left') : (rightCount++, 'right'));
      
      grouped[`fields${side.charAt(0).toUpperCase() + side.slice(1)}`].push(field);
    }
  }

  // Sort function
  const sortFunction = sortByLabel
    ? (a, b) => (a.label || '').localeCompare(b.label || '')
    : (a, b) => (a.seq ?? 0) - (b.seq ?? 0);

  // Sort only once at the end
  if (level === 2) {
    return grouped.sort(sortFunction);
  } else {
    for (const key in grouped) {
      grouped[key].sort(sortFunction);
    }
  }

  return grouped;
}

function optimizedGroupFieldsBySide(sections, sortByLabel = false) {
  return sections.map(section => {
    const { fields, ...rest } = section;
    const grouped = optimizedGroupFieldsThreeLevels(fields, 1, sortByLabel);
    return { ...rest, ...grouped };
  });
}

// Usage in Angular service
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class FieldGroupingService {
  groupFields(sections, sortByLabel = false) {
    return optimizedGroupFieldsBySide(sections, sortByLabel);
  }
}
