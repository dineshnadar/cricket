import { Injectable, signal, computed, inject, WritableSignal } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { HttpClient } from '@angular/common/http';
import { WIDGET_CONFIG, WidgetConfig, WidgetState, SubMenuItem } from './widget-config';

@Injectable({ providedIn: 'root' })
export class ProfileBuilderService {
  private fb = inject(FormBuilder);
  private http = inject(HttpClient);

  private profiles: WritableSignal<FormGroup[]> = signal([]);
  private activeProfileIndex: WritableSignal<number | null> = signal(null);
  private profileWidgetStates: WritableSignal<Record<string, WidgetState>[]> = signal([]);
  private activeWidgetName: WritableSignal<string | null> = signal(null);
  private isLoading: WritableSignal<boolean> = signal(false);
  private dynamicSubMenus: WritableSignal<Record<string, SubMenuItem[]>> = signal({});

  private initialWidgetState: WidgetState = {
    hasError: false,
    errorMessage: '',
    visited: false,
    acknowledged: false,
    active: false,
    status: 'pending'
  };

  constructor() {
    this.loadDynamicSubMenus();
  }

  private async loadDynamicSubMenus() {
    for (const widget of WIDGET_CONFIG) {
      await this.loadSubMenusRecursively(widget);
    }
  }

  private async loadSubMenusRecursively(item: WidgetConfig | SubMenuItem) {
    if (typeof item.subMenu === 'function') {
      const subMenus = await item.subMenu();
      this.dynamicSubMenus.update(current => ({ ...current, [item.name]: subMenus }));
      for (const subItem of subMenus) {
        await this.loadSubMenusRecursively(subItem);
      }
    } else if (item.subMenu === 'dynamic' || item.subMenu === 'api') {
      const subMenus = await this.fetchDynamicSubMenu(item.name);
      this.dynamicSubMenus.update(current => ({ ...current, [item.name]: subMenus }));
      for (const subItem of subMenus) {
        await this.loadSubMenusRecursively(subItem);
      }
    } else if (Array.isArray(item.subMenu)) {
      for (const subItem of item.subMenu) {
        await this.loadSubMenusRecursively(subItem);
      }
    }
  }

  private async fetchDynamicSubMenu(widgetName: string): Promise<SubMenuItem[]> {
    try {
      const response = await this.http.get<SubMenuItem[]>(`/api/sub-menu/${widgetName}`).toPromise();
      return response || [];
    } catch (error) {
      console.error(`Error fetching dynamic sub-menu for ${widgetName}:`, error);
      return [];
    }
  }

  addNewProfile() {
    const newProfileForm = this.createProfileFormGroup();
    this.profiles.update(profiles => [...profiles, newProfileForm]);
    
    const newProfileWidgetStates = this.createInitialWidgetStates();
    this.profileWidgetStates.update(states => [...states, newProfileWidgetStates]);
    
    this.setActiveProfile(this.profiles().length - 1);
  }

  private createProfileFormGroup(): FormGroup {
    return this.fb.group({
      // Add your form controls here
      id: [''],
      name: [''],
      // ... other profile fields
    });
  }

  private createInitialWidgetStates(): Record<string, WidgetState> {
    const flattenedWidgets = this.getFlattenedWidgets();
    return flattenedWidgets.reduce((acc, widget) => {
      acc[widget.name] = { ...this.initialWidgetState };
      return acc;
    }, {} as Record<string, WidgetState>);
  }

  setActiveProfile(index: number) {
    if (index >= 0 && index < this.profiles().length) {
      this.activeProfileIndex.set(index);
      this.resetWidgetStates();
      this.loadInitialWidget();
    } else {
      console.error('Invalid profile index');
    }
  }

  getActiveProfile(): FormGroup | null {
    const index = this.activeProfileIndex();
    return index !== null ? this.profiles()[index] : null;
  }

  getActiveProfileWidgetStates(): Record<string, WidgetState> | null {
    const index = this.activeProfileIndex();
    return index !== null ? this.profileWidgetStates()[index] : null;
  }

  updateWidgetState(widgetName: string, update: Partial<WidgetState>, profileIndex?: number) {
    const index = profileIndex !== undefined ? profileIndex : this.activeProfileIndex();
    if (index === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[index] };
      profileStates[widgetName] = { ...profileStates[widgetName], ...update };

      // Update parent states
      this.updateParentStates(widgetName, profileStates);

      newAllStates[index] = profileStates;
      return newAllStates;
    });
  }

  private updateParentStates(widgetName: string, profileStates: Record<string, WidgetState>) {
    const parents = this.getParentWidgets(widgetName);
    parents.forEach(parent => {
      const childStates = this.getChildWidgetStates(parent.name, profileStates);
      const allChildrenCompleted = childStates.every(state => state.status === 'completed');
      const anyChildError = childStates.some(state => state.status === 'error');
      const allChildrenAcknowledged = childStates.every(state => state.acknowledged);
      const anyChildVisited = childStates.some(state => state.visited);

      let newStatus: WidgetState['status'] = 'pending';
      if (allChildrenCompleted) newStatus = 'completed';
      else if (anyChildError) newStatus = 'error';
      else if (childStates.some(state => state.status === 'in-progress')) newStatus = 'in-progress';

      profileStates[parent.name] = {
        ...profileStates[parent.name],
        status: newStatus,
        acknowledged: allChildrenAcknowledged,
        visited: anyChildVisited || profileStates[parent.name].visited,
        hasError: anyChildError
      };
    });
  }

  getVisibleWidgets = computed(() => {
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfileWidgetStates) return [];
    
    return this.getFlattenedWidgets()
      .filter(widget => widget.visible)
      .map(widget => ({
        ...widget,
        state: activeProfileWidgetStates[widget.name] || this.initialWidgetState
      }));
  });

  private getFlattenedWidgets(): (WidgetConfig | SubMenuItem)[] {
    const flatten = (items: (WidgetConfig | SubMenuItem)[]): (WidgetConfig | SubMenuItem)[] => {
      return items.flatMap(item => {
        const subItems = this.getSubMenuItems(item);
        return [item, ...flatten(subItems)];
      });
    };

    return flatten(WIDGET_CONFIG);
  }

  getSubMenuItems(item: WidgetConfig | SubMenuItem): SubMenuItem[] {
    if (Array.isArray(item.subMenu)) {
      return item.subMenu;
    } else if (this.dynamicSubMenus()[item.name]) {
      return this.dynamicSubMenus()[item.name];
    }
    return [];
  }

  setActiveWidget(widgetName: string) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[activeProfileIndex] };

      // Deactivate all widgets
      Object.keys(profileStates).forEach(key => {
        profileStates[key] = { ...profileStates[key], active: false };
      });

      // Activate the selected widget and its parents
      this.activateWidgetAndParents(widgetName, profileStates);

      newAllStates[activeProfileIndex] = profileStates;
      return newAllStates;
    });

    this.activeWidgetName.set(widgetName);
  }

  private activateWidgetAndParents(widgetName: string, profileStates: Record<string, WidgetState>) {
    const parents = this.getParentWidgets(widgetName);
    [...parents, { name: widgetName }].forEach(widget => {
      profileStates[widget.name] = {
        ...profileStates[widget.name],
        active: true,
        visited: true,
        status: profileStates[widget.name].status === 'pending' ? 'in-progress' : profileStates[widget.name].status
      };
    });
  }

  resetWidgetStates() {
    const index = this.activeProfileIndex();
    if (index !== null) {
      this.profileWidgetStates.update(allStates => {
        const newAllStates = [...allStates];
        newAllStates[index] = this.createInitialWidgetStates();
        return newAllStates;
      });
    }
  }

  loadInitialWidget() {
    const firstWidget = this.getVisibleWidgets()[0];
    if (firstWidget) {
      this.setActiveWidget(firstWidget.name);
    }
  }

  validateAllWidgets(): boolean {
    const activeProfile = this.getActiveProfile();
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfile || !activeProfileWidgetStates) return false;

    let isValid = true;
    this.getFlattenedWidgets().forEach(widget => {
      if (widget.visible) {
        const widgetForm = activeProfile.get(widget.name);
        const widgetValid = widgetForm?.valid ?? false;
        this.updateWidgetState(widget.name, { 
          hasError: !widgetValid, 
          status: widgetValid ? 'completed' : 'error' 
        });
        isValid = isValid && widgetValid;
      }
    });
    return isValid;
  }

  loadAllWidgets() {
    this.getFlattenedWidgets().forEach(widget => {
      if (widget.visible) {
        this.updateWidgetState(widget.name, { visited: true, status: 'in-progress' });
      }
    });
  }

  getNextIncompleteWidget(): string | null {
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfileWidgetStates) return null;

    const incompleteWidget = this.getFlattenedWidgets().find(widget => 
      widget.visible && activeProfileWidgetStates[widget.name]?.status !== 'completed'
    );
    return incompleteWidget ? incompleteWidget.name : null;
  }

  getCompletionPercentage(): number {
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfileWidgetStates) return 0;

    const visibleWidgets = this.getFlattenedWidgets().filter(w => w.visible);
    const completedWidgets = visibleWidgets.filter(w => 
      activeProfileWidgetStates[w.name]?.status === 'completed'
    );
    return (completedWidgets.length / visibleWidgets.length) * 100;
  }

  acknowledgeWidget(widgetName: string) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[activeProfileIndex] };

      // Acknowledge the widget and its children
      this.acknowledgeWidgetRecursively(widgetName, profileStates);

      // Update parent states
      this.updateParentStates(widgetName, profileStates);

      newAllStates[activeProfileIndex] = profileStates;
      return newAllStates;
    });
  }

  private acknowledgeWidgetRecursively(widgetName: string, profileStates: Record<string, WidgetState>) {
    profileStates[widgetName] = {
      ...profileStates[widgetName],
      acknowledged: true
    };

    const widget = this.findWidgetByName(widgetName);
    if (widget) {
      const subItems = this.getSubMenuItems(widget);
      subItems.forEach(subItem => {
        this.acknowledgeWidgetRecursively(subItem.name, profileStates);
      });
    }
  }

  private getParentWidgets(widgetName: string): (WidgetConfig | SubMenuItem)[] {
    const result: (WidgetConfig | SubMenuItem)[] = [];
    const findParent = (items: (WidgetConfig | SubMenuItem)[], parent?: WidgetConfig | SubMenuItem) => {
      for (const item of items) {
        if (item.name === widgetName && parent) {
          result.push(parent);
          return true;
        }
        const subItems = this.getSubMenuItems(item);
        if (subItems.length && findParent(subItems, item)) {
          if (parent) result.push(parent);
          return true;
        }
      }
      return false;
    };
    findParent(WIDGET_CONFIG);
    return result.reverse();
  }

  private getChildWidgetStates(widgetName: string, profileStates: Record<string, WidgetState>): WidgetState[] {
    const result: WidgetState[] = [];
    const widget = this.findWidgetByName(widgetName);
    if (widget) {
      const subItems = this.getSubMenuItems(widget);
      subItems.forEach(item => {
        if (profileStates[item.name]) {
          result.push(profileStates[item.name]);
        }
        result.push(...this.getChildWidgetStates(item.name, profileStates));
      });
    }
    return result;
  }

  private findWidgetByName(name: string): WidgetConfig | SubMenuItem | undefined {
    const find = (items: (WidgetConfig | SubMenuItem)[]): WidgetConfig | SubMenuItem | undefined => {
      for (const item of items) {
        if (item.name === name) return item;
        const subItems = this.getSubMenuItems(item);
        const found = find(subItems);
        if (found) return found;
      }
    };
    return find(WIDGET_CONFIG);
  }

  getIsLoading(): WritableSignal<boolean> {
    return this.isLoading;
  }

async createOrEditProfile(partyId?: string) {
  this.isLoading.set(true);
  try {
    let profileData: any = {};
    const metadataData = await this.fetchMetadata();

    if (partyId) {
      // Editing existing profile
      profileData = await this.fetchPartyData(partyId);
      const existingProfileIndex = this.findProfileIndexByPartyId(partyId);
      
      if (existingProfileIndex !== -1) {
        // Update existing profile
        this.updateProfile(existingProfileIndex, profileData, metadataData);
        this.setActiveProfile(existingProfileIndex);
      } else {
        // Profile not found, create new
        this.addNewProfile();
        const newProfileIndex = this.profiles().length - 1;
        this.updateProfile(newProfileIndex, profileData, metadataData);
      }
    } else {
      // Creating new profile
      this.addNewProfile();
      const newProfileIndex = this.profiles().length - 1;
      this.updateProfile(newProfileIndex, profileData, metadataData);
    }
  } catch (error) {
    console.error('Error in createOrEditProfile:', error);
    // Handle error (e.g., show user notification)
  } finally {
    this.isLoading.set(false);
  }
}

private updateProfile(index: number, profileData: any, metadataData: any) {
  const profileForm = this.profiles()[index];
  if (profileForm) {
    // Update form with new data
    profileForm.patchValue(profileData);
    
    // Update widget states based on the new data
    this.getFlattenedWidgets().forEach(widget => {
      if (profileData[widget.name]) {
        this.updateWidgetState(widget.name, { 
          visited: true,
          status: 'in-progress'
        }, index);
      }
    });

    // You might want to add logic here to handle metadata
    // For example, updating visibility of widgets based on metadata
  }
}

private findProfileIndexByPartyId(partyId: string): number {
  return this.profiles().findIndex(profile => profile.get('id')?.value === partyId);
}

private async fetchMetadata(): Promise<any> {
  try {
    return await this.http.get('/api/metadata').toPromise();
  } catch (error) {
    console.error('Error fetching metadata:', error);
    return {};
  }
}

private async fetchPartyData(partyId: string): Promise<any> {
  try {
    return await this.http.get(`/api/party/${partyId}`).toPromise();
  } catch (error) {
    console.error(`Error fetching party data for ID ${partyId}:`, error);
    return {};
  }
}

------------------------

      

import { Component, inject } from '@angular/core';
import { NgFor, NgIf, NgClass, AsyncPipe } from '@angular/common';
import { ProfileBuilderService } from './profile-builder.service';
import { WidgetConfig, SubMenuItem } from './widget-config';

@Component({
  selector: 'app-left-menu',
  standalone: true,
  imports: [NgFor, NgIf, NgClass, AsyncPipe],
  template: `
    <nav>
      <ul>
        <ng-container *ngFor="let widget of profileService.getVisibleWidgets() | async">
          <li>
            <ng-container *ngTemplateOutlet="menuItem; context: { $implicit: widget }"></ng-container>
          </li>
        </ng-container>
      </ul>
    </nav>

    <ng-template #menuItem let-item>
      <a (click)="setActiveWidget(item.name)"
         [ngClass]="{
           'active': item.state.active,
           'visited': item.state.visited,
           'error': item.state.hasError,
           'acknowledged': item.state.acknowledged,
           [item.state.status]: true
         }">
        {{ item.label }}
        <span *ngIf="item.state.hasError" class="error-indicator">!</span>
        <span *ngIf="item.state.status === 'completed'" class="completion-indicator">âœ“</span>
      </a>
      <ul *ngIf="hasSubMenu(item)">
        <li *ngFor="let subItem of getSubMenuItems(item)">
          <ng-container *ngTemplateOutlet="menuItem; context: { $implicit: subItem }"></ng-container>
        </li>
      </ul>
    </ng-template>
  `,
  styles: [`
    ul { list-style-type: none; padding-left: 20px; }
    li { margin-bottom: 5px; }
    a { 
      cursor: pointer; 
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .active { font-weight: bold; }
    .visited { text-decoration: underline; }
    .error { color: red; }
    .acknowledged { font-style: italic; }
    .completed { color: green; }
    .in-progress { color: orange; }
    .error-indicator { 
      color: red; 
      font-weight: bold; 
      margin-left: 5px; 
    }
    .completion-indicator { 
      color: green; 
      font-weight: bold; 
      margin-left: 5px; 
    }
  `]
})
export class LeftMenuComponent {
  profileService = inject(ProfileBuilderService);

  setActiveWidget(widgetName: string) {
    this.profileService.setActiveWidget(widgetName);
  }

  hasSubMenu(item: WidgetConfig | SubMenuItem): boolean {
    return this.profileService.getSubMenuItems(item).length > 0;
  }

  getSubMenuItems(item: WidgetConfig | SubMenuItem): (WidgetConfig | SubMenuItem)[] {
    return this.profileService.getSubMenuItems(item);
  }
}

-----

import { Component, ViewContainerRef, ViewChild, effect, inject, Injector } from '@angular/core';
import { AsyncPipe, NgFor, NgIf } from '@angular/common';
import { ProfileBuilderService } from './profile-builder.service';
import { FormGroup } from '@angular/forms';
import { LeftMenuComponent } from './left-menu.component';

@Component({
  selector: 'app-party-builder',
  standalone: true,
  imports: [AsyncPipe, NgFor, NgIf, LeftMenuComponent],
  template: `
    <div class="profile-selector">
      <button *ngFor="let profile of profileService.profiles(); let i = index"
              (click)="profileService.setActiveProfile(i)"
              [class.active]="i === profileService.activeProfileIndex()">
        Profile {{ i + 1 }}
      </button>
      <button (click)="profileService.addNewProfile()">Add New Profile</button>
    </div>
    <div class="party-builder" *ngIf="profileService.hasActiveProfile()">
      <app-left-menu></app-left-menu>
      <div class="widget-container">
        <ng-container #widgetContainer></ng-container>
      </div>
    </div>
    <button (click)="validateAll()">Validate All</button>
    <button (click)="loadAllWidgets()">Load All Widgets</button>
    <button (click)="loadNextIncompleteWidget()">Next Incomplete Widget</button>
  `
})
export class PartyBuilderComponent {
  @ViewChild('widgetContainer', { read: ViewContainerRef, static: false })
  widgetContainer!: ViewContainerRef;

  profileService = inject(ProfileBuilderService);
  private injector = inject(Injector);

  constructor() {
    effect(() => {
      const activeWidgetName = this.profileService.activeWidgetName();
      if (activeWidgetName) {
        this.loadComponent(activeWidgetName);
      }
    }, { injector: this.injector });
  }

  async loadComponent(widgetName: string) {
    const widget = this.profileService.getVisibleWidgets().find(w => w.name === widgetName);
    if (widget && widget.component) {
      try {
        const component = await widget.component();
        this.widgetContainer.clear();
        const componentRef = this.widgetContainer.createComponent(component);
        const activeProfile = this.profileService.getActiveProfile();
        if (activeProfile) {
          const widgetForm = activeProfile.get(widgetName) as FormGroup;
          if (componentRef.instance.setFormGroup) {
            componentRef.instance.setFormGroup(widgetForm);
          }
        }
      } catch (error) {
        console.error('Error loading component:', error);
      }
    }
  }

  validateAll() {
    const isValid = this.profileService.validateAllWidgets();
    console.log(isValid ? 'All widgets are valid' : 'There are validation errors');
    console.log('Completion percentage:', this.profileService.getCompletionPercentage());
  }

  loadAllWidgets() {
    this.profileService.loadAllWidgets();
  }

  loadNextIncompleteWidget() {
    const nextWidgetName = this.profileService.getNextIncompleteWidget();
    if (nextWidgetName) {
      this.profileService.setActiveWidget(nextWidgetName);
    } else {
      console.log('All widgets are complete!');
    }
  }
}

