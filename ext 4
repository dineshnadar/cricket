import { AbstractControl, FormArray, FormGroup } from '@angular/forms';
import { ExtendedAbstractControl, FieldItem, LayoutField } from './form-extension.types';

export class FormExtensionHelpers {
  // ... other methods ...

  private createArrayFieldItem(baseItem: FieldItem, parentControl: FormGroup | FormArray, layout: LayoutField): FieldItem {
    const control = parentControl instanceof FormGroup 
      ? parentControl.get(baseItem.fldName!) as FormArray 
      : parentControl as FormArray;

    if (!(control instanceof FormArray)) {
      console.error(`Expected FormArray for ${baseItem.fldName}, but got:`, control);
      return baseItem;
    }

    const arrayItem: FieldItem = {
      ...baseItem,
      type: 'arrayGroup',
      isArray: true,
      value: control.value,
      fields: []
    };

    // Sort layout fields by sequence
    const sortedLayoutFields = this.sortLayoutFields(layout.fields || []);

    arrayItem.fields = control.controls.flatMap((ctrl, index) => {
      return this.createNestedFields(ctrl as FormGroup, sortedLayoutFields, `${baseItem.fldName}.${index}`);
    });

    return arrayItem;
  }

  private createNestedFields(control: FormGroup, layoutFields: LayoutField[], basePath: string): FieldItem[] {
    return layoutFields.flatMap(fieldLayout => {
      const nestedControl = control.get(fieldLayout.fldName);
      if (!nestedControl) return [];

      if (nestedControl instanceof FormGroup) {
        // Handle nested FormGroup
        return this.createNestedFields(
          nestedControl, 
          fieldLayout.fields || [], 
          `${basePath}.${fieldLayout.fldName}`
        );
      } else {
        // Handle FormControl
        return this.createFieldItem({
          ...fieldLayout,
          fldName: `${basePath}.${fieldLayout.fldName}`,
        }, control);
      }
    }).filter(Boolean) as FieldItem[];
  }

  private sortLayoutFields(fields: LayoutField[]): LayoutField[] {
    return fields.sort((a, b) => (a.seq || 0) - (b.seq || 0));
  }

  // ... other methods ...
}












--------------------------x-----------xx--------
import { AbstractControl, FormGroup } from '@angular/forms';
import { ExtendedAbstractControl, ExtendedControlOptions } from './form-extension.types';

export class FormExtensionHelpers {
  // ... other methods ...

  transformValue(value: any, control: ExtendedAbstractControl | ExtendedControlOptions): any {
    if (value === null || value === undefined) {
      return '';
    }

    if (typeof value === 'object' && !(value instanceof Date)) {
      // ... (keep existing object handling logic)
    }

    // Handle primitive values
    if (control.lookupData && Array.isArray(control.lookupData)) {
      if (typeof value === 'string' && value.includes('|')) {
        // Handle pipe-separated values
        return this.transformPipeSeparatedValues(value, control.lookupData);
      }

      // Handle single value lookup
      const matchingLookup = control.lookupData.find(item => item.value === value);
      if (matchingLookup) return matchingLookup.label;
    }

    switch (value) {
      case 'Y':
        return 'Yes';
      case 'N':
        return 'No';
      case true:
        return 'Yes';
      case false:
        return 'No';
      default:
        return value;
    }
  }

  private transformPipeSeparatedValues(value: string, lookupData: Array<{ label: string; value: any }>): string {
    const codes = value.split('|').map(code => code.trim());
    const transformedValues = codes
      .map(code => {
        const match = lookupData.find(item => item.value === code);
        return match ? match.label : code; // Use original code if no mapping found
      })
      .filter(val => val !== ''); // Filter out empty values

    return transformedValues.join(', ');
  }

  // ... other methods ...
}
















-----------
import { FormGroup } from '@angular/forms';
import { FieldItem, LayoutField } from './form-extension.types';

export class FormExtensionHelpers {
  // ... other methods ...

  private createCombinedFieldItem(baseItem: FieldItem, parentControl: FormGroup): FieldItem {
    if (!baseItem.combineFields || !Array.isArray(baseItem.combineFields)) {
      console.error('combineFields is not properly defined for', baseItem.fldName);
      return baseItem;
    }

    const separator = baseItem.combineSeparator || ' ';
    let combinedValue: string;

    if (baseItem.customCombine) {
      combinedValue = this.customCombineAddress(baseItem.combineFields, parentControl);
    } else {
      const values = baseItem.combineFields.map(fieldName => {
        const control = parentControl.get(fieldName);
        return control ? this.transformValue(control.value, control) : '';
      }).filter(value => value !== ''); // Filter out empty values

      combinedValue = values.join(separator).trim();
    }

    return {
      ...baseItem,
      value: combinedValue,
      computedValue: combinedValue,
      isCombined: true,
      useHtml: true
    };
  }

  private customCombineAddress(fields: string[], parentControl: FormGroup): string {
    const address1 = parentControl.get(fields[0])?.value || '';
    const address2 = parentControl.get(fields[1])?.value || '';
    const city = parentControl.get(fields[2])?.value || '';
    const state = parentControl.get(fields[3])?.value || '';
    const zip = parentControl.get(fields[4])?.value || '';

    const parts = [
      address1,
      address2,
      [city, state, zip].filter(Boolean).join(', ')
    ].filter(Boolean); // Filter out empty parts

    return parts.join('<br>');
  }

  // ... other methods ...
}

------------

import { AbstractControl, FormGroup } from '@angular/forms';
import { ExtendedAbstractControl, ExtendedControlOptions } from './form-extension.types';

export class FormExtensionHelpers {
  // ... other methods ...

  transformValue(value: any, control: ExtendedAbstractControl | ExtendedControlOptions): any {
    if (value === null || value === undefined) {
      return '';
    }

    if (typeof value === 'object' && !(value instanceof Date)) {
      if (control instanceof FormGroup) {
        // Handle FormGroup
        const transformedObject: any = {};
        Object.keys(control.controls).forEach(key => {
          transformedObject[key] = this.transformValue(value[key], control.get(key) as ExtendedAbstractControl);
        });
        return transformedObject;
      } else if (Array.isArray(value)) {
        // Handle arrays
        return value.map(item => this.transformValue(item, control));
      } else {
        // Handle plain objects
        const transformedObject: any = {};
        Object.keys(value).forEach(key => {
          transformedObject[key] = this.transformValue(value[key], control);
        });
        return transformedObject;
      }
    }

    // Handle primitive values
    if (control.lookupData && Array.isArray(control.lookupData)) {
      const matchingLookup = control.lookupData.find(item => item.value === value);
      if (matchingLookup) return matchingLookup.label;
    }

    switch (value) {
      case 'Y':
        return 'Yes';
      case 'N':
        return 'No';
      case true:
        return 'Yes';
      case false:
        return 'No';
      default:
        return value;
    }
  }

  // ... other methods ...
}
-------

import { Component, OnDestroy } from '@angular/core';
import { Subject, takeUntil } from 'rxjs';

interface WidgetComponentInstance {
  ackStatusChanged?: EventEmitter<boolean>;
  // ... other properties
}

@Component({
  // ... component metadata
})
export class PartyBuilderComponent implements OnDestroy {
  private destroy$ = new Subject<void>();

  // ... other properties and methods

  loadWidget(widgetName: string) {
    // ... existing code to load the widget

    const componentInstance = componentRef.instance as WidgetComponentInstance;

    if (componentInstance.ackStatusChanged) {
      componentInstance.ackStatusChanged.pipe(
        takeUntil(this.destroy$)
      ).subscribe({
        next: (ackStatus: boolean) => {
          try {
            this.profileBuilder.updateWidgetAckStatus(widgetName, ackStatus);
          } catch (error) {
            console.error(`Error updating ack status for ${widgetName}:`, error);
            // Handle error (e.g., show user notification)
          }
        },
        error: (err) => {
          console.error(`Error in ack status stream for ${widgetName}:`, err);
          // Handle error (e.g., show user notification)
        }
      });
    }

    // ... rest of the method
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
------
import { AbstractControl, FormArray, FormGroup } from '@angular/forms';
import { ExtendedAbstractControl, FieldItem, LayoutField } from './form-extension.types';

export class FormExtensionHelpers {
  // ... other methods ...

  private createArrayFieldItem(baseItem: FieldItem, parentControl: FormGroup | FormArray): FieldItem {
    const control = parentControl instanceof FormGroup 
      ? parentControl.get(baseItem.fldName!) as FormArray 
      : parentControl as FormArray;

    if (!(control instanceof FormArray)) {
      console.error(`Expected FormArray for ${baseItem.fldName}, but got:`, control);
      return baseItem;
    }

    const arrayItem: FieldItem = {
      ...baseItem,
      type: 'arrayGroup',
      isArray: true,
      value: control.value,
      fields: control.controls.map((ctrl, index) => {
        if (ctrl instanceof FormGroup) {
          // Handle nested FormGroup within the array
          return {
            fldName: `${baseItem.fldName}.${index}`,
            type: 'formGroup',
            fields: Object.keys(ctrl.controls).map(key => 
              this.createFieldItem({
                fldName: key,
                type: 'field',
                side: 'full',
                seq: 0
              } as LayoutField, ctrl)
            ).filter(Boolean) as FieldItem[]
          };
        } else {
          // Handle simple FormControl within the array
          return this.createFieldItem({
            fldName: `${baseItem.fldName}.${index}`,
            type: 'field',
            side: 'full',
            seq: index
          } as LayoutField, control, index);
        }
      }).filter(Boolean) as FieldItem[]
    };

    return arrayItem;
  }

  private createFieldItem(field: LayoutField, parentControl: FormGroup | FormArray, arrayIndex?: number): FieldItem | null {
    let control: AbstractControl | null;
    
    if (parentControl instanceof FormArray) {
      control = parentControl.at(arrayIndex!);
    } else {
      control = parentControl.get(field.fldName!);
    }

    if (!control) return null;

    const extendedControl = control as ExtendedAbstractControl;

    let baseItem: FieldItem = {
      ...field,
      value: control.value,
      isValid: control.valid,
      errors: control.errors,
      status: control.status,
      touched: control.touched,
      dirty: control.dirty
    };

    switch (field.type) {
      case 'subHeader':
        return { ...baseItem, isSubHeader: true };
      case 'reqDivider':
        return { ...baseItem, isReqDivider: true };
      case 'divider':
        return { ...baseItem, isDivider: true };
      case 'staticComponent':
        return { 
          ...baseItem, 
          isStaticComponent: true, 
          staticComponentName: field.staticComponent 
        };
      case 'injectedComponent':
        return this.createInjectedComponentItem(baseItem, parentControl);
      case 'arraySimple':
      case 'arrayGroup':
        return this.createArrayFieldItem(baseItem, parentControl);
      default:
        return this.createDefaultFieldItem(baseItem, control, parentControl);
    }
  }

  // ... other methods ...
}
-----------------------
import { AbstractControl, FormGroup } from '@angular/forms';
import { FieldItem, UIReadViewOptions, FormLayout } from './form-extension.types';

export class FormExtensionHelpers {
  // ... other methods remain the same

  getUIReadView(control: AbstractControl, options: UIReadViewOptions = {}, formLayouts?: WeakMap<FormGroup, FormLayout>): FieldItem[] {
    let readView: FieldItem[];

    if (control instanceof FormGroup && formLayouts && formLayouts.has(control)) {
      const layout = formLayouts.get(control)!;
      readView = this.applyLayoutToFormGroup(control, layout);
    } else {
      readView = this.getBasicReadViewForControl(control);
    }

    return this.filterAndFormatReadView(readView, options);
  }

  private filterAndFormatReadView(items: FieldItem[], options: UIReadViewOptions): FieldItem[] {
    return items.map(item => this.filterAndFormatItem(item, options)).filter(Boolean) as FieldItem[];
  }

  private filterAndFormatItem(item: FieldItem, options: UIReadViewOptions): FieldItem | null {
    if (!this.shouldIncludeItem(item, options)) return null;

    const formattedItem: FieldItem = { ...item };

    if (!options.includeOldValues) {
      delete formattedItem.oldValue;
    }

    if (!options.includeErrors) {
      delete formattedItem.errors;
    }

    if (formattedItem.fields) {
      formattedItem.fields = this.filterAndFormatReadView(formattedItem.fields, options);
    }

    return formattedItem;
  }

  private shouldIncludeItem(item: FieldItem, options: UIReadViewOptions): boolean {
    if (options.includeSections && item.sectionName) {
      return options.includeSections.includes(item.sectionName);
    }
    if (options.excludeSections && item.sectionName) {
      return !options.excludeSections.includes(item.sectionName);
    }
    if (options.includeFields && item.fldName) {
      return options.includeFields.includes(item.fldName);
    }
    if (options.excludeFields && item.fldName) {
      return !options.excludeFields.includes(item.fldName);
    }
    return true;
  }

  // ... other methods remain the same
}

---------------
import { Injectable } from '@angular/core';
import { AbstractControl, FormArray, FormBuilder, FormGroup, ValidatorFn, Validators } from '@angular/forms';
import { ExtendedAbstractControl, ExtendedControlOptions, FieldItem, FormLayout, LayoutField, LayoutSection, UIReadViewOptions } from './form-extension.types';

@Injectable({
  providedIn: 'root'
})
export class FormExtensionHelpers {
  constructor(private fb: FormBuilder) {}

  updateControlProperties(control: ExtendedAbstractControl, options: ExtendedControlOptions): boolean {
    let changed = false;
    Object.entries(options).forEach(([key, value]) => {
      if (key in control) {
        if (key === 'regex') {
          if (!this.areRegexArraysEqual(control[key] as string[], value as string[])) {
            (control as any)[key] = value;
            changed = true;
          }
        } else if (control[key as keyof ExtendedAbstractControl] !== value) {
          (control as any)[key] = value;
          changed = true;
        }
      }
    });
    return changed;
  }

  areRegexArraysEqual(arr1?: string[], arr2?: string[]): boolean {
    if (!arr1 && !arr2) return true;
    if (!arr1 || !arr2) return false;
    if (arr1.length !== arr2.length) return false;
    return arr1.every((regex, index) => regex === arr2[index]);
  }

  extendNestedControls(control: FormGroup | FormArray, service: any): void {
    if (control instanceof FormGroup) {
      Object.values(control.controls).forEach(childControl => {
        this.extendSingleControl(childControl, service);
      });
    } else if (control instanceof FormArray) {
      control.controls.forEach(childControl => {
        this.extendSingleControl(childControl, service);
      });
    }
  }

  private extendSingleControl(control: AbstractControl, service: any): void {
    if (!this.hasExtendedProperties(control)) {
      service.extendControl(control, {});
    }
    if (control instanceof FormGroup || control instanceof FormArray) {
      this.extendNestedControls(control, service);
    }
  }

  hasExtendedProperties(control: AbstractControl): boolean {
    return 'label' in control || 'fldName' in control;
  }

  updateValidators(control: AbstractControl, customValidatorsCache: WeakMap<AbstractControl, ValidatorFn[]>): void {
    const extendedControl = control as ExtendedAbstractControl;
    const validators: ValidatorFn[] = [];

    if (extendedControl.required) {
      validators.push(Validators.required);
    }

    if (extendedControl.regex && extendedControl.regex.length > 0) {
      validators.push(Validators.pattern(extendedControl.regex.join('|')));
    }

    if (extendedControl.fldMax !== undefined) {
      validators.push(Validators.max(extendedControl.fldMax));
    }

    const customValidators = customValidatorsCache.get(control) || [];
    validators.push(...customValidators);

    control.setValidators(validators);
    control.updateValueAndValidity();
  }

  shouldUpdateProperty<K extends keyof ExtendedControlOptions>(
    control: ExtendedAbstractControl,
    property: K,
    value: ExtendedControlOptions[K]
  ): boolean {
    if (property === 'regex') {
      return !this.areRegexArraysEqual(control[property] as string[], value as string[]);
    }
    return control[property] !== value;
  }

  sortFormLayout(layout: FormLayout): FormLayout {
    return {
      ...layout,
      sections: layout.sections.map(section => ({
        ...section,
        fields: [...section.fields].sort((a, b) => a.seq - b.seq)
      }))
    };
  }

  getExtendedReadViewForControl(control: AbstractControl, formLayouts: WeakMap<FormGroup, FormLayout>): FieldItem[] {
    if (control instanceof FormGroup) {
      const layout = formLayouts.get(control);
      if (layout) {
        return this.applyLayoutToFormGroup(control, layout);
      }
    }
    return this.getBasicReadViewForControl(control);
  }

  private applyLayoutToFormGroup(formGroup: FormGroup, layout: FormLayout): FieldItem[] {
    return layout.sections.flatMap(section => this.createSectionItems(section, formGroup));
  }

  private createSectionItems(section: LayoutSection, formGroup: FormGroup): FieldItem[] {
    if (section.type === 'divider') {
      return [{
        label: '',
        fldName: `divider_${Date.now()}`,
        type: 'divider',
        editable: false,
        visible: true,
        expand: false,
        value: null,
        isDivider: true,
        dividerClass: section.dividerClass
      }];
    }

    const sectionItem: FieldItem = {
      label: this.getSectionLabel(section),
      fldName: `section_${section.type}`,
      type: section.type,
      editable: false,
      visible: true,
      expand: true,
      value: null,
      fields: [],
      labelWidth: section.labelWidth
    };

    sectionItem.fields = section.fields.map(field => this.createFieldItem(field, formGroup)).filter(Boolean) as FieldItem[];
    return [sectionItem];
  }

  private createFieldItem(field: LayoutField, parentControl: FormGroup | FormArray, arrayIndex?: number): FieldItem | null {
    let control: AbstractControl | null;
    
    if (parentControl instanceof FormArray) {
      control = parentControl.at(arrayIndex!);
    } else {
      control = parentControl.get(field.fldName!);
    }

    if (!control) return null;

    const extendedControl = control as ExtendedAbstractControl;

    let baseItem: FieldItem = {
      ...field,
      value: control.value,
      isValid: control.valid,
      errors: control.errors,
      status: control.status,
      touched: control.touched,
      dirty: control.dirty
    };

    switch (field.type) {
      case 'subHeader':
        return { ...baseItem, isSubHeader: true };
      case 'reqDivider':
        return { ...baseItem, isReqDivider: true };
      case 'divider':
        return { ...baseItem, isDivider: true };
      case 'staticComponent':
        return { 
          ...baseItem, 
          isStaticComponent: true, 
          staticComponentName: field.staticComponent 
        };
      case 'injectedComponent':
        return this.createInjectedComponentItem(baseItem, parentControl);
      case 'arraySimple':
      case 'arrayGroup':
        return this.createArrayFieldItem(baseItem, parentControl);
      default:
        return this.createDefaultFieldItem(baseItem, control, parentControl);
    }
  }

  private createInjectedComponentItem(baseItem: FieldItem, parentControl: FormGroup | FormArray): FieldItem {
    const controlValues = baseItem.injectedComponentInputs?.map(input => 
      parentControl instanceof FormGroup ? parentControl.get(input)?.value : null
    ) || [];

    return {
      ...baseItem,
      type: 'injectedComponent',
      value: controlValues,
      isInjectedComponent: true,
      injectedComponentName: baseItem.injectedComponent,
      injectedComponentInputs: controlValues,
      injectedComponentOutputs: baseItem.injectedComponentOutputs
    };
  }

  private createArrayFieldItem(baseItem: FieldItem, parentControl: FormGroup | FormArray): FieldItem {
    const control = parentControl instanceof FormGroup 
      ? parentControl.get(baseItem.fldName!) as FormArray 
      : parentControl as FormArray;

    return {
      ...baseItem,
      type: baseItem.type as 'arraySimple' | 'arrayGroup',
      value: control.value,
      isArray: true,
      fields: control.controls.map((ctrl, index) => {
        const childLayoutField: LayoutField = {
          fldName: `${baseItem.fldName}.${index}`,
          seq: index,
          side: 'full',
          type: this.getFieldType(ctrl)
        };
        return this.createFieldItem(childLayoutField, control, index);
      }).filter(Boolean) as FieldItem[]
    };
  }

  private createDefaultFieldItem(baseItem: FieldItem, control: AbstractControl, parentControl: FormGroup | FormArray): FieldItem {
    const extendedControl = control as ExtendedAbstractControl;
    const rawValue = control.value;
    const transformedValue = this.transformValue(rawValue, extendedControl);

    return {
      ...baseItem,
      type: 'field',
      value: transformedValue,
      computedValue: extendedControl._customComputation ? extendedControl._customComputation(control, parentControl) : transformedValue,
      oldValue: extendedControl._oldValue
    };
  }

  private getFieldType(control: AbstractControl): LayoutField['type'] {
    if (control instanceof FormGroup) {
      return 'arrayGroup';
    } else if (control instanceof FormArray) {
      return 'arraySimple';
    } else {
      return 'field';
    }
  }

  private getSectionLabel(section: LayoutSection): string {
    switch (section.type) {
      case 'leftHeader':
      case 'leftRightHeader':
        return section.leftHeader || '';
      case 'commonHeader':
        return section.commonHeader || '';
      case 'accordion':
      case 'accordionHeader':
        return section.accordionHeader || '';
      default:
        return '';
    }
  }

  private transformValue(value: any, control: ExtendedAbstractControl): any {
    if (value === 'Y') return 'Yes';
    if (value === 'N') return 'No';

    if (control.lookupData && Array.isArray(control.lookupData)) {
      const matchingLookup = control.lookupData.find(item => item.value === value);
      if (matchingLookup) return matchingLookup.label;
    }

    return value;
  }

  getUIReadView(control: AbstractControl, options: UIReadViewOptions = {}): FieldItem[] {
    console.log('Getting UI Read View for control:', control);
    const readView = this.getExtendedReadViewForControl(control, new WeakMap());
    console.log('Initial read view:', readView);
    const filteredView = this.filterAndFormatReadView(readView, options);
    console.log('Filtered and formatted view:', filteredView);
    return filteredView;
  }

  private filterAndFormatReadView(items: FieldItem[], options: UIReadViewOptions): FieldItem[] {
    return items.filter(item => this.shouldIncludeItem(item, options))
      .map(item => this.formatItem(item, options));
  }

  private shouldIncludeItem(item: FieldItem, options: UIReadViewOptions): boolean {
    if (options.includeSections && item.sectionName) {
      return options.includeSections.includes(item.sectionName);
    }
    if (options.excludeSections && item.sectionName) {
      return !options.excludeSections.includes(item.sectionName);
    }
    if (options.includeFields && item.fldName) {
      return options.includeFields.includes(item.fldName);
    }
    if (options.excludeFields && item.fldName) {
      return !options.excludeFields.includes(item.fldName);
    }
    return true;
  }

  private formatItem(item: FieldItem, options: UIReadViewOptions): FieldItem {
    const formattedItem: FieldItem = { ...item };

    if (!options.includeOldValues) {
      delete formattedItem.oldValue;
    }

    if (!options.includeErrors) {
      delete formattedItem.errors;
    }

    if (formattedItem.fields) {
      formattedItem.fields = this.filterAndFormatReadView(formattedItem.fields, options);
    }

    return formattedItem;
  }

  applyDefaultValuesRecursive(control: AbstractControl, storeOldValue: boolean): void {
    const extendedControl = control as ExtendedAbstractControl;
    
    if (control instanceof FormGroup) {
      if (extendedControl.dfltVal !== undefined && this.isFormGroupEmpty(control)) {
        if (storeOldValue) {
          extendedControl._oldValue = this.getFormGroupValue(control);
        }
        this.setFormGroupValue(control, extendedControl.dfltVal);
      } else {
        Object.values(control.controls).forEach(childControl => {
          this.applyDefaultValuesRecursive(childControl, storeOldValue);
        });
      }
    } else if (control instanceof FormArray) {
      control.controls.forEach(ctrl => {
        this.applyDefaultValuesRecursive(ctrl, storeOldValue);
      });
    } else {
      if (extendedControl.dfltVal !== undefined && control.value === null) {
        if (storeOldValue) {
          extendedControl._oldValue = control.value;
        }
        control.setValue(extendedControl.dfltVal);
      }
    }
  }

  private isFormGroupEmpty(group: FormGroup): boolean {
    return Object.values(group.controls).every(control =>
      control.value === null || control.value === '' || 
      (control instanceof FormGroup && this.isFormGroupEmpty(control)) ||
      (control instanceof FormArray && control.length === 0)
    );
  }

  private getFormGroupValue(group: FormGroup): any {
    const value: any = {};
    Object.entries(group.controls).forEach(([key, control]) => {
      if (control instanceof FormGroup) {
        value[key] = this.getFormGroupValue(control);
      } else if (control instanceof FormArray) {
        value[key] = control.controls.map(ctrl => 
          ctrl instanceof FormGroup ? this.getFormGroupValue(ctrl) : ctrl.value
        );
      } else {
        value[key] = control.value;
      }
    });
    return value;
  }

  private setFormGroupValue(group: FormGroup, value: any): void {
    if (typeof value === 'object' && value !== null) {
      Object.entries(value).forEach(([key, val]) => {
        const control = group.get(key);
        if (control) {
          if (control instanceof FormGroup && typeof val === 'object') {
            this.setFormGroupValue(control, val);
          } else if (control instanceof FormArray && Array.isArray(val)) {
            this.setFormArrayValue(control, val);
          } else {
            control.setValue(val);
          }
        }
      });
    }
  }

  private setFormArrayValue(array: FormArray, values: any[]): void {
    while (array.length) {
      array.removeAt(0);
    }

    values.forEach(value => {
      if (typeof value === 'object' && value !== null) {
        const group = this.fb.group({});
        this.setFormGroupValue(group, value);
        array.push(group);
      } else {
        array.push(this.fb.control(value));
      }
    });
  }

  getExtendedProperties(control: ExtendedAbstractControl): Partial<ExtendedControlOptions> {
    return {
      label: control.label,
      fldName: control.fldName,
      visible: control.visible,
      editable: control.editable,
      lookup: control.lookup,
      lookupData: control.lookupData,
      regex: control.regex,
      fldMax: control.fldMax,
      fieldType: control.fieldType,
      dfltVal: control.dfltVal,
      required: control.required,
      oldValue: control._oldValue,
      expand: control.expand,
      sectionName: control.sectionName,
      subSectionName: control.subSectionName,
      reqBorder: control.reqBorder,
      subName: control.subName,
      align: control.align,
      isArray: control.isArray,
      combineFields: control.combineFields,
      combineSeparator: control.combineSeparator,
      customCombine: control.customCombine,
      injectedComponent: control.injectedComponent,
      injectedComponentInputs: control.injectedComponentInputs,
      injectedComponentOutputs: control.injectedComponentOutputs,
      staticComponent: control.staticComponent
    };
  }

  addCustomValidator(control: AbstractControl, validator: ValidatorFn, customValidatorsCache: WeakMap<AbstractControl, ValidatorFn[]>): void {
    const currentValidators = customValidatorsCache.get(control) || [];
    currentValidators.push(validator);
    customValidatorsCache.set(control, currentValidators);
  }

  removeCustomValidator(control: AbstractControl, validator: ValidatorFn, customValidatorsCache: WeakMap<AbstractControl, ValidatorFn[]>): void {
    const currentValidators = customValidatorsCache.get(control) || [];
    const index = currentValidators.indexOf(validator);
    if (index > -1) {
      currentValidators.splice(index, 1);
      customValidatorsCache.set(control, currentValidators);
    }
  }

  handleArrayOperation(formArray: FormArray, operation: 'add' | 'remove', index?: number): void {
    const arrayExtendedControl = formArray as ExtendedAbstractControl;
    
    if (operation === 'add') {
      if (arrayExtendedControl.fieldType === 'arrayGroup') {
        const newGroup = this.createNewArrayGroupItem(formArray);
        formArray.push(newGroup);
      } else if (arrayExtendedControl.fieldType === 'arraySimple') {
        formArray.push(this.fb.control(null));
      }
    } else if (operation === 'remove' && index !== undefined) {
      formArray.removeAt(index);
    }
  }

  private createNewArrayGroupItem(formArray: FormArray): FormGroup {
    const template = (formArray.at(0) as FormGroup).controls;
    const newGroup = this.fb.group({});
    Object.entries(template).forEach(([key, control]) => {
      newGroup.addControl(key, this.fb.control(null, control.validator));
      // Extend the new control with the same properties as the template
      const templateExtendedControl = control as ExtendedAbstractControl;
      const newExtendedControl = newGroup.get(key) as ExtendedAbstractControl;
      Object.assign(newExtendedControl, this.getExtendedProperties(templateExtendedControl));
    });
    return newGroup;
  }

  getBasicReadViewForControl(control: AbstractControl): FieldItem[] {
    if (control instanceof FormGroup || control instanceof FormArray) {
      return this.getFieldsReadViewItems(control);
    } else {
      const extendedControl = control as ExtendedAbstractControl;
      return [{
        fldName: extendedControl.fldName || '',
        label: extendedControl.label || '',
        value: control.value,
        type: 'field',
        isValid: control.valid,
        errors: control.errors,
        status: control.status,
        touched: control.touched,
        dirty: control.dirty
      }];
    }
  }

  private getFieldsReadViewItems(control: FormGroup | FormArray): FieldItem[] {
    if (control instanceof FormGroup) {
      return Object.entries(control.controls).map(([key, childControl]) => 
        this.createFieldItem({
          fldName: key,
          side: 'full',
          seq: 0,
          type: this.getFieldType(childControl)
        }, control)
      ).filter((item): item is FieldItem => item !== null);
    } else if (control instanceof FormArray) {
      return control.controls.map((childControl, index) => 
        this.createFieldItem({
          fldName: index.toString(),
          side: 'full',
          seq: index,
          type: this.getFieldType(childControl)
        }, control, index)
      ).filter((item): item is FieldItem => item !== null);
    }
    return [];
  }
}





---------------------------------------
import { Injectable, signal, computed, Signal, effect, untracked } from '@angular/core';
import { FormBuilder, FormGroup, FormArray, AbstractControl, ValidatorFn } from '@angular/forms';
import { ExtendedControlOptions, ExtendedAbstractControl, FieldItem, LayoutField, FormLayout, UIReadViewOptions } from './form-extension.types';
import { FormExtensionHelpers } from './form-extension.helpers';

@Injectable({
  providedIn: 'root'
})
export class FormExtensionService {
  private updateTrigger = signal(0);
  private readViewCache = new WeakMap<AbstractControl, Signal<FieldItem[]>>();
  private formLayouts = new WeakMap<FormGroup, FormLayout>();
  private extendedPropertiesCache = new WeakMap<AbstractControl, ExtendedControlOptions>();
  private customValidatorsCache = new WeakMap<AbstractControl, ValidatorFn[]>();

  constructor(
    private fb: FormBuilder,
    private helpers: FormExtensionHelpers
  ) {
    effect(() => {
      this.updateTrigger();
      this.clearCaches();
    });
  }

  extendControl(control: AbstractControl, options: ExtendedControlOptions): void {
    const extendedControl = control as ExtendedAbstractControl;
    let changed = this.helpers.updateControlProperties(extendedControl, options);

    if (changed) {
      if (control instanceof FormGroup || control instanceof FormArray) {
        this.helpers.extendNestedControls(control, this);
      }
      this.helpers.updateValidators(control, this.customValidatorsCache);
      this.triggerUpdate();
    }
  }

  updateControlProperty<K extends keyof ExtendedControlOptions>(
    control: AbstractControl,
    property: K,
    value: ExtendedControlOptions[K]
  ): void {
    const extendedControl = control as ExtendedAbstractControl;
    if (this.helpers.shouldUpdateProperty(extendedControl, property, value)) {
      (extendedControl as any)[property] = value;
      if (property === 'required' || property === 'regex') {
        this.helpers.updateValidators(control, this.customValidatorsCache);
      }
      this.triggerUpdate();
    }
  }

  setFormGroupLayout(formGroup: FormGroup, layout: FormLayout): void {
    const sortedLayout = this.helpers.sortFormLayout(layout);
    this.formLayouts.set(formGroup, sortedLayout);
    this.triggerUpdate();
  }

  getExtendedReadView(control: AbstractControl): Signal<FieldItem[]> {
    if (!this.readViewCache.has(control)) {
      const readViewSignal = computed(() => {
        this.updateTrigger();
        return untracked(() => this.helpers.getExtendedReadViewForControl(control, this.formLayouts));
      });
      this.readViewCache.set(control, readViewSignal);
    }
    return this.readViewCache.get(control)!;
  }

  registerCustomComputation(control: AbstractControl, computation: (control: AbstractControl, form: FormGroup) => any): void {
    (control as ExtendedAbstractControl)._customComputation = computation;
    this.triggerUpdate();
  }

  applyDefaultValues(control: AbstractControl, storeOldValue: boolean = false): void {
    this.helpers.applyDefaultValuesRecursive(control, storeOldValue);
    this.triggerUpdate();
  }

  getOldValue(control: AbstractControl): any | undefined {
    return (control as ExtendedAbstractControl)._oldValue;
  }

  getExtendedProperties(control: AbstractControl): Partial<ExtendedControlOptions> {
    if (!this.extendedPropertiesCache.has(control)) {
      const properties = this.helpers.getExtendedProperties(control as ExtendedAbstractControl);
      this.extendedPropertiesCache.set(control, properties);
    }
    return this.extendedPropertiesCache.get(control)!;
  }

  addCustomValidator(control: AbstractControl, validator: ValidatorFn): void {
    this.helpers.addCustomValidator(control, validator, this.customValidatorsCache);
    this.helpers.updateValidators(control, this.customValidatorsCache);
    this.triggerUpdate();
  }

  removeCustomValidator(control: AbstractControl, validator: ValidatorFn): void {
    this.helpers.removeCustomValidator(control, validator, this.customValidatorsCache);
    this.helpers.updateValidators(control, this.customValidatorsCache);
    this.triggerUpdate();
  }

  handleArrayOperation(formArray: FormArray, operation: 'add' | 'remove', index?: number): void {
    this.helpers.handleArrayOperation(formArray, operation, index);
    this.triggerUpdate();
  }

  getUIReadView(control: AbstractControl, options: UIReadViewOptions = {}): FieldItem[] {
    return this.helpers.getUIReadView(control, options);
  }

  private triggerUpdate(): void {
    this.updateTrigger.update(v => v + 1);
  }

  private clearCaches(): void {
    this.readViewCache = new WeakMap();
    this.extendedPropertiesCache = new WeakMap();
  }
}

------------
function parseDateAndFormat(input: string): string | null {
  // Regular expression to match YYYY-MM-DD format
  const dateRegex = /^(\d{4})-(\d{2})-(\d{2})$/;
  const match = input.match(dateRegex);

  if (match) {
    const [, year, month, day] = match;
    
    // Validate month and day
    const monthNum = parseInt(month, 10);
    const dayNum = parseInt(day, 10);
    
    if (monthNum < 1 || monthNum > 12 || dayNum < 1 || dayNum > 31) {
      return null; // Invalid month or day
    }
    
    // Create a Date object to validate the date (e.g., catch invalid dates like 2023-02-31)
    const date = new Date(parseInt(year, 10), monthNum - 1, dayNum);
    if (
      date.getFullYear() !== parseInt(year, 10) ||
      date.getMonth() !== monthNum - 1 ||
      date.getDate() !== dayNum
    ) {
      return null; // Invalid date
    }
    
    // Format as MM/DD/YYYY
    return `${monthNum.toString().padStart(2, '0')}/${dayNum.toString().padStart(2, '0')}/${year}`;
  }

  return null; // No match found
}

// Usage example
function processDateString(input: string): void {
  const formattedDate = parseDateAndFormat(input);
  if (formattedDate) {
    console.log(`Formatted date: ${formattedDate}`);
  } else {
    console.log('Invalid date format or date');
  }
}

// Test cases
processDateString('2023-03-14'); // Should output: Formatted date: 03/14/2023
processDateString('2023-02-28'); // Should output: Formatted date: 02/28/2023
processDateString('2023-02-31'); // Should output: Invalid date format or date
processDateString('2023-13-01'); // Should output: Invalid date format or date
processDateString('not a date'); // Should output: Invalid date format or date
