// apps/your-app/src/app/party-builder-config.ts

import { ContextConfig, SharedConfig, ButtonConfig, ApiCallConfig } from '@your-org/party-builder';

// Common Buttons
const commonButtons: Record<string, ButtonConfig> = {
  save: { id: 'save', label: 'Save', action: 'saveParty', location: 'form-bottom', visible: true, disabled: false },
  submit: { id: 'submit', label: 'Submit', action: 'submitParty', location: 'form-bottom', visible: true, disabled: false },
  cancel: { id: 'cancel', label: 'Cancel', action: 'cancelParty', location: 'header', visible: true, disabled: false }
};

// Common API Calls
const commonApiCalls: Record<string, ApiCallConfig> = {
  getPartyDetails: {
    baseUrl: 'https://api.example.com',
    endpoint: '/party',
    method: 'GET',
    inputs: ['partyId', 'sourceApp', { name: 'partyType', fromLookup: 'partyTypes', key: 'value' }]
  },
  submitParty: {
    baseUrl: 'https://api.example.com',
    endpoint: '/submit',
    method: 'POST',
    inputs: ['partyData', 'metadata']
  }
};

// Common Lookups
const commonLookups = {
  partyTypes: [
    { value: 'individual', label: 'Individual' },
    { value: 'corporate', label: 'Corporate' }
  ]
};

export const contextConfigs: Record<string, ContextConfig> = {
  partyBuilder: {
    useCases: {
      existingPartyWithoutAccounts: {
        buttons: [commonButtons.save, commonButtons.submit, commonButtons.cancel],
        apiCalls: {
          getPartyDetails: commonApiCalls.getPartyDetails,
          submitParty: commonApiCalls.submitParty
        },
        initialApiCalls: ['getPartyDetails']
      }
    },
    lookups: commonLookups,
    metadata: {
      version: '1.0.0',
      lastUpdated: '2023-05-20'
    }
  }
};

export const sharedConfigs: Record<string, SharedConfig> = {
  standardPartyBuilder: {
    useCases: {
      basicPartyCreation: {
        buttons: [commonButtons.save, commonButtons.cancel],
        apiCalls: {
          getPartyDetails: commonApiCalls.getPartyDetails
        },
        initialApiCalls: []
      }
    },
    lookups: commonLookups,
    metadata: {
      version: '1.0.0',
      lastUpdated: '2023-05-20'
    }
  }
};

----------
Library Structure (libs/party-builder/src/):

Copylib/
├── button.component.ts
├── context-config.service.ts
├── party-builder.service.ts
├── party-builder.component.ts
├── context-config.ts
index.ts

libs/party-builder/src/lib/context-config.ts:

typescriptCopyimport { InjectionToken } from '@angular/core';

export interface ButtonConfig {
  id: string;
  label: string;
  action: string;
  location: 'header' | 'footer' | 'form-top' | 'form-bottom' | 'sidebar';
  visible: boolean;
  disabled: boolean;
  requireConfirmation?: boolean;
  confirmationMessage?: string;
}

export interface ApiCallConfig {
  baseUrl: string;
  endpoint: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  inputs: Array<string | { name: string; fromLookup: string; key: string }>;
  lookups?: string[];
  transformInput?: (input: any) => any;
  dependsOn?: string[];
}

export interface UseCaseConfig {
  buttons: ButtonConfig[];
  apiCalls: Record<string, ApiCallConfig>;
  initialApiCalls: string[];
}

export interface ContextConfig {
  useCases: Record<string, UseCaseConfig>;
  lookups?: Record<string, any>;
  metadata?: Record<string, any>;
}

export interface SharedConfig {
  useCases: Record<string, UseCaseConfig>;
  lookups?: Record<string, any>;
  metadata?: Record<string, any>;
}

export const CONTEXT_CONFIG = new InjectionToken<Record<string, ContextConfig>>('CONTEXT_CONFIG');
export const SHARED_CONFIG = new InjectionToken<Record<string, SharedConfig>>('SHARED_CONFIG');

libs/party-builder/src/lib/context-config.service.ts:

typescriptCopyimport { Injectable, Inject } from '@angular/core';
import { CONTEXT_CONFIG, SHARED_CONFIG, ContextConfig, SharedConfig, UseCaseConfig, ButtonConfig, ApiCallConfig } from './context-config';

@Injectable({
  providedIn: 'root'
})
export class ContextConfigService {
  private currentContext: string = '';
  private currentUseCase: string = '';

  constructor(
    @Inject(CONTEXT_CONFIG) private contextConfigs: Record<string, ContextConfig>,
    @Inject(SHARED_CONFIG) private sharedConfigs: Record<string, SharedConfig>
  ) {}

  setContext(context: string, useCase: string) {
    this.currentContext = context;
    this.currentUseCase = useCase;
  }

  getCurrentContext() {
    return { context: this.currentContext, useCase: this.currentUseCase };
  }

  private getUseCaseConfig(context: string, useCase: string): UseCaseConfig | null {
    return this.contextConfigs[context]?.useCases[useCase] || null;
  }

  getButtons(context?: string, useCase?: string): ButtonConfig[] {
    const useCaseConfig = this.getRelevantUseCaseConfig(context, useCase);
    return useCaseConfig?.buttons || [];
  }

  getButtonsByLocation(context?: string, useCase?: string): Record<string, ButtonConfig[]> {
    const buttons = this.getButtons(context, useCase);
    return buttons.reduce((acc, button) => {
      (acc[button.location] = acc[button.location] || []).push(button);
      return acc;
    }, {} as Record<string, ButtonConfig[]>);
  }

  getApiCall(apiCallId: string, context?: string, useCase?: string): ApiCallConfig | undefined {
    const useCaseConfig = this.getRelevantUseCaseConfig(context, useCase);
    return useCaseConfig?.apiCalls[apiCallId];
  }

  getInitialApiCalls(context?: string, useCase?: string): string[] {
    const useCaseConfig = this.getRelevantUseCaseConfig(context, useCase);
    return useCaseConfig?.initialApiCalls || [];
  }

  getLookup(lookupName: string, context?: string): any[] {
    const relevantContext = context || this.currentContext;
    return this.contextConfigs[relevantContext]?.lookups?.[lookupName] || 
           this.sharedConfigs.standardPartyBuilder?.lookups?.[lookupName] || 
           [];
  }

  getMetadata(context?: string): Record<string, any> | undefined {
    const relevantContext = context || this.currentContext;
    return this.contextConfigs[relevantContext]?.metadata || 
           this.sharedConfigs.standardPartyBuilder?.metadata;
  }

  async prepareApiCall(apiCallName: string, input: any, context?: string, useCase?: string, additionalTransforms?: ((input: any) => any)[]): Promise<any> {
    const apiCall = this.getApiCall(apiCallName, context, useCase);
    if (!apiCall) {
      throw new Error(`API call ${apiCallName} not found for the given context and use case`);
    }

    let preparedData: any = {};
    for (const inputConfig of apiCall.inputs) {
      if (typeof inputConfig === 'string') {
        if (input[inputConfig] !== undefined) {
          preparedData[inputConfig] = input[inputConfig];
        }
      } else {
        const lookupValue = this.getValueFromLookup(inputConfig.fromLookup, inputConfig.key, input[inputConfig.name], context);
        if (lookupValue !== undefined) {
          preparedData[inputConfig.name] = lookupValue;
        }
      }
    }

    if (apiCall.lookups) {
      for (const lookupName of apiCall.lookups) {
        preparedData[lookupName] = this.getLookup(lookupName, context);
      }
    }

    const metadata = this.getMetadata(context);
    if (metadata) {
      preparedData.metadata = metadata;
    }

    const transforms = [
      apiCall.transformInput,
      ...(additionalTransforms || [])
    ].filter(Boolean);

    for (const transform of transforms) {
      preparedData = await transform(preparedData);
    }

    return preparedData;
  }

  private getValueFromLookup(lookupName: string, key: string, value: any, context?: string): any {
    const lookup = this.getLookup(lookupName, context);
    const lookupItem = lookup.find(item => item[key] === value);
    return lookupItem ? lookupItem.value : undefined;
  }

  getSharedUseCaseConfig(useCaseName: string): UseCaseConfig | null {
    return this.sharedConfigs.standardPartyBuilder?.useCases[useCaseName] || null;
  }

  mergeWithSharedConfig(contextUseCase: string, sharedUseCase: string, context?: string): UseCaseConfig {
    const contextConfig = this.getUseCaseConfig(context || this.currentContext, contextUseCase);
    const sharedConfig = this.getSharedUseCaseConfig(sharedUseCase);

    if (!contextConfig) {
      throw new Error(`Context use case ${contextUseCase} not found`);
    }

    if (!sharedConfig) {
      throw new Error(`Shared use case ${sharedUseCase} not found`);
    }

    return {
      buttons: [...(contextConfig.buttons || []), ...(sharedConfig.buttons || [])],
      apiCalls: { ...sharedConfig.apiCalls, ...contextConfig.apiCalls },
      initialApiCalls: [...(sharedConfig.initialApiCalls || []), ...(contextConfig.initialApiCalls || [])]
    };
  }

  private getRelevantUseCaseConfig(context?: string, useCase?: string): UseCaseConfig | null {
    if (context && useCase) {
      return this.getUseCaseConfig(context, useCase);
    }
    return this.getUseCaseConfig(this.currentContext, this.currentUseCase);
  }
}

libs/party-builder/src/lib/party-builder.service.ts:

typescriptCopyimport { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { ContextConfigService } from './context-config.service';
import { catchError, Observable, of } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class PartyBuilderService {
  private http = inject(HttpClient);
  private contextConfig = inject(ContextConfigService);

  executeApiCall(apiCallName: string, input: any, context?: string, useCase?: string): Observable<any> {
    const apiCall = this.contextConfig.getApiCall(apiCallName, context, useCase);
    if (!apiCall) {
      return of(null);
    }

    return this.contextConfig.prepareApiCall(apiCallName, input, context, useCase).then(preparedData => {
      const url = `${apiCall.baseUrl}${apiCall.endpoint}`;
      switch (apiCall.method) {
        case 'GET':
          return this.http.get(url, { params: preparedData });
        case 'POST':
          return this.http.post(url, preparedData);
        case 'PUT':
          return this.http.put(url, preparedData);
        case 'DELETE':
          return this.http.delete(url, { body: preparedData });
        default:
          throw new Error(`Unsupported HTTP method: ${apiCall.method}`);
      }
    }).pipe(
      catchError(error => {
        console.error(`Error in API call ${apiCallName}:`, error);
        return of(null);
      })
    );
  }

  saveParty(partyData: any, context?: string, useCase?: string): Observable<any> {
    return this.executeApiCall('submitParty', { partyData }, context, useCase);
  }

  cancelParty(): Observable<boolean> {
    // Implement cancel logic
    return of(true);
  }
}

libs/party-builder/src/lib/button.component.ts:

typescriptCopyimport { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { ButtonConfig } from './context-config';

@Component({
  selector: 'app-button',
  standalone: true,
  template: `
    <button
      [disabled]="config.disabled"
      [style.display]="config.visible ? 'inline-block' : 'none'"
      (click)="onClick()"
      [attr.data-testid]="config.id">
      {{ config.label }}
    </button>
  `,
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ButtonComponent {
  @Input({ required: true }) config!: ButtonConfig;
  @Output() action = new EventEmitter<string>();

  onClick() {
    if (this.config.requireConfirmation && !confirm(this.config.confirmationMessage || 'Are you sure?')) {
      return;
    }
    this.action.emit(this.config.id);
  }
}

libs/party-builder/src/lib/party-builder.component.ts:

typescriptCopyimport { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule } from '@angular/forms';
import { ContextConfigService } from './context-config.service';
import { PartyBuilderService } from './party-builder.service';
import { ButtonComponent } from './button.component';
import { ButtonConfig } from './context-config';

@Component({
  selector: 'app-party-builder',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, ButtonComponent],
  template: `
    <div>
      <h2>Party Builder</h2>
      <div *ngFor="let button of buttonsByLocation['header']; trackBy: trackByButtonId">
        <app-button [config]="updateButtonState(button)" (action)="onButtonAction($event)"></app-button>
      </div>
      
      <form [formGroup]="partyForm" (ngSubmit)="onSubmit()">
        <div *ngFor="let button of buttonsByLocation['form-top']; trackBy: trackByButtonId">
          <app-button [config]="updateButtonState(button)" (action)="onButtonAction($event)"></app-button>
        </div>

        <div>
          <label for="partyId">Party ID:</label>
          <input id="partyId" formControlName="partyId">
        </div>
        <div>
          <label for="partyType">Party Type:</label>
          <select id="partyType" formControlName="partyType">
            <option *ngFor="let type of partyTypes" [value]="type.value">{{type.label}}</option>
          </select>
        </div>
        <div>
          <label for="name">Name:</label>
          <input id="name" formControlName="name">
        </div>

        <div *ngFor="let button of buttonsByLocation['form-bottom']; trackBy: trackByButtonId">
          <app-button [config]="updateButtonState(button)" (action)="onButtonAction($event)"></app-button>
        </div>
      </form>

      <div *ngFor="let button of buttonsByLocation['footer']; trackBy: trackByButtonId">
        <app-button [config]="updateButtonState(button)" (action)="onButtonAction($event)"></app-button>
      </div>
    </div>
  `
})
export class PartyBuilderComponent implements OnInit {
  buttonsByLocation: Record<string, ButtonConfig[]> = {};
  partyForm: FormGroup;
  partyTypes: { value: string; label: string }[] = [];
  isSubmitting = false;
  isSaving = false;

  constructor(
    private contextConfigService: ContextConfigService,
    private partyBuilderService: PartyBuilderService,
    private fb: FormBuilder
  ) {
    this.partyForm = this.fb.group({
      partyId: [''],
      partyType: [''],
      name: ['']
    });
  }

  ngOnInit() {
    this.contextConfigService.setContext('partyBuilder', 'existingPartyWithoutAccounts');
    this.buttonsByLocation = this.contextConfigService.getButtonsByLocation();
    this.partyTypes = this.contextConfigService.getLookup('partyTypes');
    this.loadInitialData();
  }

  async loadInitialData() {
    const initialApiCalls = this.contextConfigService.getInitialApiCalls();
    for (const apiCall of initialApiCalls) {
      await this.partyBuilderService.executeApiCall(apiCall, {}).toPromise();
    }
  }

  onButtonAction(actionId: string) {
    switch (actionId) {
      case 'saveParty':
        this.saveParty();
        break;
      case 'submitParty':
        this.submitParty();
        break;
      case 'cancelParty':
        this.cancelParty();
        break;
      default:
        console.log(`Unhandled action: ${actionId}`);
    }
  }

  onSubmit() {
    if (this.partyForm.valid) {
      this.submitParty();
    } else {
      console.log('Form is invalid');
    }
  }

  saveParty() {
    console.log('Saving party...');
    this.isSaving = true;
    const partyData = this.partyForm.value;
    this.partyBuilderService.saveParty( CopyRetryClaude’s response was limited as it hit the maximum length allowed at this time. Claude does not have the ability to run the code it generates yet.DScode stuck in saveParty() {EditI apologize for the interruption. Let's complete the PartyBuilderComponent with the saveParty, submitParty, and cancelParty methods, along with the supporting methods. Here's the complete PartyBuilderComponent:
typescriptCopyimport { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, FormGroup, ReactiveFormsModule } from '@angular/forms';
import { ContextConfigService } from './context-config.service';
import { PartyBuilderService } from './party-builder.service';
import { ButtonComponent } from './button.component';
import { ButtonConfig } from './context-config';

@Component({
  selector: 'app-party-builder',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, ButtonComponent],
  template: `
    <div>
      <h2>Party Builder</h2>
      <div *ngFor="let button of buttonsByLocation['header']; trackBy: trackByButtonId">
        <app-button [config]="updateButtonState(button)" (action)="onButtonAction($event)"></app-button>
      </div>
      
      <form [formGroup]="partyForm" (ngSubmit)="onSubmit()">
        <div *ngFor="let button of buttonsByLocation['form-top']; trackBy: trackByButtonId">
          <app-button [config]="updateButtonState(button)" (action)="onButtonAction($event)"></app-button>
        </div>

        <div>
          <label for="partyId">Party ID:</label>
          <input id="partyId" formControlName="partyId">
        </div>
        <div>
          <label for="partyType">Party Type:</label>
          <select id="partyType" formControlName="partyType">
            <option *ngFor="let type of partyTypes" [value]="type.value">{{type.label}}</option>
          </select>
        </div>
        <div>
          <label for="name">Name:</label>
          <input id="name" formControlName="name">
        </div>

        <div *ngFor="let button of buttonsByLocation['form-bottom']; trackBy: trackByButtonId">
          <app-button [config]="updateButtonState(button)" (action)="onButtonAction($event)"></app-button>
        </div>
      </form>

      <div *ngFor="let button of buttonsByLocation['footer']; trackBy: trackByButtonId">
        <app-button [config]="updateButtonState(button)" (action)="onButtonAction($event)"></app-button>
      </div>
    </div>
  `
})
export class PartyBuilderComponent implements OnInit {
  buttonsByLocation: Record<string, ButtonConfig[]> = {};
  partyForm: FormGroup;
  partyTypes: { value: string; label: string }[] = [];
  isSubmitting = false;
  isSaving = false;

  constructor(
    private contextConfigService: ContextConfigService,
    private partyBuilderService: PartyBuilderService,
    private fb: FormBuilder
  ) {
    this.partyForm = this.fb.group({
      partyId: [''],
      partyType: [''],
      name: ['']
    });
  }

  ngOnInit() {
    this.contextConfigService.setContext('partyBuilder', 'existingPartyWithoutAccounts');
    this.buttonsByLocation = this.contextConfigService.getButtonsByLocation();
    this.partyTypes = this.contextConfigService.getLookup('partyTypes');
    this.loadInitialData();
  }

  async loadInitialData() {
    const initialApiCalls = this.contextConfigService.getInitialApiCalls();
    for (const apiCall of initialApiCalls) {
      await this.partyBuilderService.executeApiCall(apiCall, {}).toPromise();
    }
  }

  onButtonAction(actionId: string) {
    switch (actionId) {
      case 'saveParty':
        this.saveParty();
        break;
      case 'submitParty':
        this.submitParty();
        break;
      case 'cancelParty':
        this.cancelParty();
        break;
      default:
        console.log(`Unhandled action: ${actionId}`);
    }
  }

  onSubmit() {
    if (this.partyForm.valid) {
      this.submitParty();
    } else {
      console.log('Form is invalid');
    }
  }

  saveParty() {
    console.log('Saving party...');
    this.isSaving = true;
    const partyData = this.partyForm.value;
    this.partyBuilderService.saveParty(partyData).subscribe(
      response => {
        console.log('Party saved successfully', response);
        this.isSaving = false;
        this.updateButtonStates();
      },
      error => {
        console.error('Error saving party', error);
        this.isSaving = false;
        this.updateButtonStates();
      }
    );
  }

  submitParty() {
    console.log('Submitting party...');
    this.isSubmitting = true;
    const partyData = this.partyForm.value;
    this.partyBuilderService.executeApiCall('submitParty', { partyData }).subscribe(
      response => {
        console.log('Party submitted successfully', response);
        this.isSubmitting = false;
        this.updateButtonStates();
      },
      error => {
        console.error('Error submitting party', error);
        this.isSubmitting = false;
        this.updateButtonStates();
      }
    );
  }

  cancelParty() {
    console.log('Cancelling party builder...');
    this.partyBuilderService.cancelParty().subscribe(
      success => {
        if (success) {
          console.log('Party builder cancelled');
          this.partyForm.reset();
          this.updateButtonStates();
        } else {
          console.log('Failed to cancel party builder');
        }
      },
      error => {
        console.error('Error cancelling party builder', error);
      }
    );
  }

  trackByButtonId(index: number, button: ButtonConfig): string {
    return button.id;
  }

  updateButtonState(button: ButtonConfig): ButtonConfig {
    const updatedButton = { ...button };

    switch (button.id) {
      case 'saveParty':
        updatedButton.disabled = !this.partyForm.dirty || this.isSaving || this.isSubmitting;
        break;
      case 'submitParty':
        updatedButton.disabled = !this.partyForm.valid || this.isSubmitting || this.isSaving;
        break;
      case 'cancelParty':
        updatedButton.visible = this.partyForm.dirty || this.isSaving || this.isSubmitting;
        updatedButton.disabled = this.isSaving || this.isSubmitting;
        break;
    }

    return updatedButton;
  }

  private updateButtonStates() {
    // Force change detection to update button states
    this.buttonsByLocation = { ...this.buttonsByLocation };
  }
}
Now, let's add the main AppModule to tie everything together:

apps/your-app/src/app/app.module.ts:

typescriptCopyimport { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule } from '@angular/common/http';
import { ReactiveFormsModule } from '@angular/forms';
import { AppComponent } from './app.component';
import { PartyBuilderComponent } from '@your-org/party-builder';
import { CONTEXT_CONFIG, SHARED_CONFIG } from '@your-org/party-builder';
import { contextConfigs, sharedConfigs } from './party-builder-config';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    HttpClientModule,
    ReactiveFormsModule,
    PartyBuilderComponent
  ],
  providers: [
    { provide: CONTEXT_CONFIG, useValue: contextConfigs },
    { provide: SHARED_CONFIG, useValue: sharedConfigs }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }

apps/your-app/src/app/app.component.ts:

typescriptCopyimport { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  template: `
    <h1>Party Builder App</h1>
    <app-party-builder></app-party-builder>
  `
})
export class AppComponent { }

apps/your-app/src/app/party-builder-config.ts:

typescriptCopyimport { ContextConfig, SharedConfig } from '@your-org/party-builder';

export const contextConfigs: Record<string, ContextConfig> = {
  partyBuilder: {
    useCases: {
      existingPartyWithoutAccounts: {
        buttons: [
          { id: 'save', label: 'Save', action: 'saveParty', location: 'form-bottom', visible: true, disabled: false },
          { id: 'submit', label: 'Submit', action: 'submitParty', location: 'form-bottom', visible: true, disabled: false },
          { id: 'cancel', label: 'Cancel', action: 'cancelParty', location: 'header', visible: true, disabled: false }
        ],
        apiCalls: {
          getPartyDetails: {
            baseUrl: 'https://api.example.com',
            endpoint: '/party',
            method: 'GET',
            inputs: ['partyId', 'sourceApp', { name: 'partyType', fromLookup: 'partyTypes', key: 'value' }]
          },
          submitParty: {
            baseUrl: 'https://api.example.com',
            endpoint: '/submit',
            method: 'POST',
            inputs: ['partyData', 'metadata']
          }
        },
        initialApiCalls: ['getPartyDetails']
      }
    },
    lookups: {
      partyTypes: [
        { value: 'individual', label: 'Individual' },
        { value: 'corporate', label: 'Corporate' }
      ]
    },
    metadata: {
      version: '1.0.0',
      lastUpdated: '2023-05-20'
    }
  }
};

export const sharedConfigs: Record<string, SharedConfig> = {
  standardPartyBuilder: {
    useCases: {
      basicPartyCreation: {
        buttons: [
          { id: 'save', label: 'Save Draft', action: 'saveParty', location: 'form-bottom', visible: true, disabled: false },
          { id: 'cancel', label: 'Cancel', action: 'cancelParty', location: 'header', visible: true, disabled: false }
        ],
        apiCalls: {
          getPartyDetails: {
            baseUrl: 'https://api.example.com',
            endpoint: '/party',
            method: 'GET',
            inputs: ['partyId', 'sourceApp']
          }
        },
        initialApiCalls: []
      }
    },
    lookups: {
      partyTypes: [
        { value: 'individual', label: 'Individual' },
        { value: 'corporate', label: 'Corporate' }
      ]
    },
    metadata: {
      version: '1.0.0',
      lastUpdated: '2023-05-20'
    }
  }
};
This complete implementation demonstrates:

How the context configuration is defined and provided to the application.
How the ContextConfigService manages and provides access to the configuration.
How the PartyBuilderService uses the context configuration to execute API calls.
How the PartyBuilderComponent uses both services to render buttons and handle user interactions based on the context configuration.
How form controls can be dynamically populated based on lookups from the context configuration.
How button states are dynamically updated based on the form state and ongoing operations.

This setup allows for flexible, configuration-driven behavior in your application. You can easily change the behavior of the party builder by modifying the context configuration, without having to change the component code.
