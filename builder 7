import { Injectable, signal, computed, WritableSignal } from '@angular/core';
import { WIDGET_CONFIG, WidgetConfig, SubMenuItem } from './widget-config';

export interface WidgetState {
  visible: boolean;
  hasError: boolean;
  errorMessage: string;
  visited: boolean;
  acknowledged: boolean;
  active: boolean;
  status: 'pending' | 'in-progress' | 'completed' | 'error';
}

@Injectable({ providedIn: 'root' })
export class WidgetStateService {
  private profileWidgetStates: WritableSignal<Record<string, WidgetState>[]> = signal([]);
  private activeProfileIndex: WritableSignal<number | null> = signal(null);

  private initialWidgetState: WidgetState = {
    visible: true,
    hasError: false,
    errorMessage: '',
    visited: false,
    acknowledged: false,
    active: false,
    status: 'pending'
  };

  initializeProfile() {
    const newProfileWidgetStates = this.createInitialWidgetStates();
    this.profileWidgetStates.update(states => [...states, newProfileWidgetStates]);
    return this.profileWidgetStates().length - 1;
  }

  setActiveProfile(index: number) {
    this.activeProfileIndex.set(index);
  }

  private createInitialWidgetStates(): Record<string, WidgetState> {
    const initializeStates = (items: (WidgetConfig | SubMenuItem)[]): Record<string, WidgetState> => {
      return items.reduce((acc, item) => {
        acc[item.name] = { ...this.initialWidgetState };
        if (Array.isArray(item.subMenu)) {
          Object.assign(acc, initializeStates(item.subMenu));
        }
        return acc;
      }, {} as Record<string, WidgetState>);
    };

    return initializeStates(WIDGET_CONFIG);
  }

  updateWidgetState(widgetName: string, update: Partial<WidgetState>) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[activeProfileIndex] };
      if (profileStates[widgetName]) {
        profileStates[widgetName] = { ...profileStates[widgetName], ...update };
        this.updateParentStates(widgetName, profileStates);
      }
      newAllStates[activeProfileIndex] = profileStates;
      return newAllStates;
    });
  }

  private updateParentStates(widgetName: string, profileStates: Record<string, WidgetState>) {
    const updateRecursively = (items: (WidgetConfig | SubMenuItem)[], parent: WidgetConfig | SubMenuItem | null = null): boolean => {
      for (const item of items) {
        if (item.name === widgetName) {
          if (parent) {
            this.updateParentState(parent.name, [profileStates[widgetName]], profileStates);
          }
          return true;
        }
        
        const subItems = Array.isArray(item.subMenu) ? item.subMenu : [];
        if (updateRecursively(subItems, item)) {
          if (parent) {
            this.updateParentState(parent.name, [profileStates[item.name]], profileStates);
          }
          return true;
        }
      }
      return false;
    };

    updateRecursively(WIDGET_CONFIG);
  }

  private updateParentState(parentName: string, childStates: WidgetState[], profileStates: Record<string, WidgetState>) {
    const allChildrenCompleted = childStates.every(state => state.status === 'completed');
    const anyChildError = childStates.some(state => state.status === 'error');
    const allChildrenAcknowledged = childStates.every(state => state.acknowledged);
    const anyChildVisited = childStates.some(state => state.visited);

    let newStatus: WidgetState['status'] = 'pending';
    if (allChildrenCompleted) newStatus = 'completed';
    else if (anyChildError) newStatus = 'error';
    else if (childStates.some(state => state.status === 'in-progress')) newStatus = 'in-progress';

    profileStates[parentName] = {
      ...profileStates[parentName],
      status: newStatus,
      acknowledged: allChildrenAcknowledged,
      visited: anyChildVisited || profileStates[parentName].visited,
      hasError: anyChildError
    };
  }

  getWidgetState(widgetName: string): WidgetState | undefined {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return undefined;
    return this.profileWidgetStates()[activeProfileIndex][widgetName];
  }

  getVisibleWidgets = computed(() => {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return [];

    const profileStates = this.profileWidgetStates()[activeProfileIndex];
    return WIDGET_CONFIG.filter(widget => profileStates[widget.name]?.visible);
  });

  setWidgetVisibility(widgetName: string, visible: boolean) {
    this.updateWidgetState(widgetName, { visible });
  }

  setWidgetActive(widgetName: string, active: boolean) {
    this.updateWidgetState(widgetName, { active });
  }

  setWidgetVisited(widgetName: string, visited: boolean) {
    this.updateWidgetState(widgetName, { visited });
  }

  setWidgetStatus(widgetName: string, status: WidgetState['status']) {
    this.updateWidgetState(widgetName, { status });
  }

  acknowledgeWidget(widgetName: string) {
    this.updateWidgetState(widgetName, { acknowledged: true });
    this.acknowledgeChildWidgets(widgetName);
  }

  private acknowledgeChildWidgets(widgetName: string) {
    const acknowledgeRecursively = (items: (WidgetConfig | SubMenuItem)[]) => {
      for (const item of items) {
        if (item.name === widgetName) {
          const subItems = Array.isArray(item.subMenu) ? item.subMenu : [];
          subItems.forEach(subItem => {
            this.updateWidgetState(subItem.name, { acknowledged: true });
            acknowledgeRecursively([subItem]);
          });
          return true;
        }
        const subItems = Array.isArray(item.subMenu) ? item.subMenu : [];
        if (acknowledgeRecursively(subItems)) {
          return true;
        }
      }
      return false;
    };

    acknowledgeRecursively(WIDGET_CONFIG);
  }

  setWidgetError(widgetName: string, hasError: boolean, errorMessage: string = '') {
    this.updateWidgetState(widgetName, { hasError, errorMessage });
  }

  resetWidgetStates() {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      newAllStates[activeProfileIndex] = this.createInitialWidgetStates();
      return newAllStates;
    });
  }
}

----------

import { Injectable, inject, signal, computed, WritableSignal } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { WIDGET_CONFIG, WidgetConfig, SubMenuItem } from './widget-config';
import { WidgetStateService, WidgetState } from './widget-state.service';
import { DynamicMenuService } from './dynamic-menu.service';

@Injectable({ providedIn: 'root' })
export class ProfileBuilderService {
  private fb = inject(FormBuilder);
  private widgetStateService = inject(WidgetStateService);
  private dynamicMenuService = inject(DynamicMenuService);

  private profiles: WritableSignal<FormGroup[]> = signal([]);
  private activeProfileIndex: WritableSignal<number | null> = signal(null);
  private activeWidgetName: WritableSignal<string | null> = signal(null);

  addNewProfile() {
    const newProfileForm = this.createProfileFormGroup();
    this.profiles.update(profiles => [...profiles, newProfileForm]);

    const newProfileIndex = this.profiles().length - 1;
    this.widgetStateService.initializeProfile();
    this.dynamicMenuService.initializeProfile();
    this.setActiveProfile(newProfileIndex);
    this.loadDynamicSubMenus();
  }

  private createProfileFormGroup(): FormGroup {
    return this.fb.group({
      id: [''],
      name: [''],
      // ... other profile fields
    });
  }

  setActiveProfile(index: number) {
    if (index >= 0 && index < this.profiles().length) {
      this.activeProfileIndex.set(index);
      this.widgetStateService.setActiveProfile(index);
      this.dynamicMenuService.setActiveProfile(index);
      this.loadInitialWidget();
    } else {
      console.error('Invalid profile index');
    }
  }

  getActiveProfile(): FormGroup | null {
    const index = this.activeProfileIndex();
    return index !== null ? this.profiles()[index] : null;
  }

  private async loadDynamicSubMenus() {
    for (const widget of WIDGET_CONFIG) {
      if (widget.subMenu === 'dynamic' || widget.subMenu === 'api') {
        await this.dynamicMenuService.loadDynamicSubMenu(widget.name);
      }
    }
  }

  getSubMenuItems(item: WidgetConfig | SubMenuItem): SubMenuItem[] {
    if (Array.isArray(item.subMenu)) {
      return item.subMenu;
    } else if (item.subMenu === 'dynamic' || item.subMenu === 'api') {
      return this.dynamicMenuService.getDynamicSubMenu(item.name);
    }
    return [];
  }

  updateWidgetVisibility(widgetName: string, visible: boolean) {
    this.widgetStateService.setWidgetVisibility(widgetName, visible);
  }

  getVisibleWidgets = computed(() => {
    return this.widgetStateService.getVisibleWidgets();
  });

  traverseWidgets(callback: (item: WidgetConfig | SubMenuItem, parent: WidgetConfig | SubMenuItem | null) => void) {
    const traverse = (items: (WidgetConfig | SubMenuItem)[], parent: WidgetConfig | SubMenuItem | null = null) => {
      items.forEach(item => {
        callback(item, parent);
        const subItems = this.getSubMenuItems(item);
        if (subItems.length > 0) {
          traverse(subItems, item);
        }
      });
    };

    traverse(WIDGET_CONFIG);
  }

  setActiveWidget(widgetName: string) {
    this.activeWidgetName.set(widgetName);
    this.widgetStateService.setWidgetActive(widgetName, true);
    this.widgetStateService.setWidgetVisited(widgetName, true);
    this.widgetStateService.setWidgetStatus(widgetName, 'in-progress');
  }

  getActiveWidgetName(): string | null {
    return this.activeWidgetName();
  }

  validateAllWidgets(): boolean {
    let isValid = true;
    this.traverseWidgets((widget) => {
      const widgetState = this.widgetStateService.getWidgetState(widget.name);
      if (widgetState && widgetState.visible) {
        const isWidgetValid = this.validateWidget(widget.name);
        isValid = isValid && isWidgetValid;
      }
    });
    return isValid;
  }

  private validateWidget(widgetName: string): boolean {
    // Implement your widget validation logic here
    // This is a placeholder implementation
    const isValid = Math.random() > 0.2; // 80% chance of being valid
    this.widgetStateService.setWidgetError(widgetName, !isValid, isValid ? '' : 'Validation failed');
    this.widgetStateService.setWidgetStatus(widgetName, isValid ? 'completed' : 'error');
    return isValid;
  }

  
  acknowledgeWidget(widgetName: string) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.widgetStateService.acknowledgeWidget(widgetName);
    
    // If you want to perform any profile-specific logic after acknowledgment
    const activeProfile = this.getActiveProfile();
    if (activeProfile) {
      // Perform any additional profile-specific actions
      // For example, you might want to update some profile-specific data
      // activeProfile.patchValue({ [widgetName + 'Acknowledged']: true });
    }

    // Update dynamic sub-menus if necessary
    this.updateDynamicSubMenusAfterAcknowledgment(widgetName);
  }

  private updateDynamicSubMenusAfterAcknowledgment(widgetName: string) {
    // Check if the acknowledged widget has dynamic sub-menus
    const widget = this.findWidgetByName(widgetName);
    if (widget && (widget.subMenu === 'dynamic' || widget.subMenu === 'api')) {
      // Reload dynamic sub-menus for this widget
      this.dynamicMenuService.loadDynamicSubMenu(widgetName);
    }
  }


  getNextIncompleteWidget(): string | null {
    let nextIncompleteWidget: string | null = null;
    this.traverseWidgets((widget) => {
      if (nextIncompleteWidget) return; // We've already found an incomplete widget
      const widgetState = this.widgetStateService.getWidgetState(widget.name);
      if (widgetState && widgetState.visible && widgetState.status !== 'completed') {
        nextIncompleteWidget = widget.name;
      }
    });
    return nextIncompleteWidget;
  }

  getCompletionPercentage(): number {
    let totalWidgets = 0;
    let completedWidgets = 0;
    this.traverseWidgets((widget) => {
      const widgetState = this.widgetStateService.getWidgetState(widget.name);
      if (widgetState && widgetState.visible) {
        totalWidgets++;
        if (widgetState.status === 'completed') {
          completedWidgets++;
        }
      }
    });
    return totalWidgets === 0 ? 0 : (completedWidgets / totalWidgets) * 100;
  }

  resetWidgetStates() {
    this.widgetStateService.resetWidgetStates();
    this.dynamicMenuService.clearDynamicSubMenus();
    this.loadDynamicSubMenus();
  }

  loadInitialWidget() {
    const visibleWidgets = this.getVisibleWidgets()();
    if (visibleWidgets.length > 0) {
      this.setActiveWidget(visibleWidgets[0].name);
    }
  }

  updateWidgetState(widgetName: string, update: Partial<WidgetState>) {
    this.widgetStateService.updateWidgetState(widgetName, update);
  }

  getWidgetState(widgetName: string): WidgetState | undefined {
    return this.widgetStateService.getWidgetState(widgetName);
  }

  findWidgetByName(name: string): WidgetConfig | SubMenuItem | undefined {
    let foundWidget: WidgetConfig | SubMenuItem | undefined;

    const searchInItems = (items: (WidgetConfig | SubMenuItem)[]): boolean => {
      for (const item of items) {
        if (item.name === name) {
          foundWidget = item;
          return true;
        }
        const subItems = this.getSubMenuItems(item);
        if (searchInItems(subItems)) {
          return true;
        }
      }
      return false;
    };

    searchInItems(WIDGET_CONFIG);
    return foundWidget;
  }

  // Additional utility methods

  isWidgetVisible(widgetName: string): boolean {
    const widgetState = this.getWidgetState(widgetName);
    return widgetState ? widgetState.visible : false;
  }

  setWidgetStatus(widgetName: string, status: WidgetState['status']) {
    this.updateWidgetState(widgetName, { status });
  }

  loadAllWidgets() {
    this.traverseWidgets((widget) => {
      if (this.isWidgetVisible(widget.name)) {
        this.updateWidgetState(widget.name, { visited: true, status: 'in-progress' });
      }
    });
  }

  // Method to handle profile data updates
  updateProfileData(profileData: any) {
    const activeProfile = this.getActiveProfile();
    if (activeProfile) {
      activeProfile.patchValue(profileData);
      this.updateWidgetStatesFromProfileData(profileData);
    }
  }

  private updateWidgetStatesFromProfileData(profileData: any) {
    this.traverseWidgets((widget) => {
      if (profileData[widget.name]) {
        this.updateWidgetState(widget.name, { 
          visited: true,
          status: 'in-progress'
        });
      }
    });
  }

  // Method to get all profiles
  getProfiles(): FormGroup[] {
    return this.profiles();
  }

  // Method to delete a profile
  deleteProfile(index: number) {
    if (index >= 0 && index < this.profiles().length) {
      this.profiles.update(profiles => profiles.filter((_, i) => i !== index));
      this.profileWidgetStates.update(states => states.filter((_, i) => i !== index));
      this.dynamicSubMenus.update(menus => menus.filter((_, i) => i !== index));

      // If we deleted the active profile, set a new active profile
      if (this.activeProfileIndex() === index) {
        const newActiveIndex = index > 0 ? index - 1 : (this.profiles().length > 0 ? 0 : null);
        this.setActiveProfile(newActiveIndex);
      }
    }
  }

  // Method to duplicate a profile
  duplicateProfile(index: number) {
    if (index >= 0 && index < this.profiles().length) {
      const profileToDuplicate = this.profiles()[index];
      const newProfile = this.fb.group(profileToDuplicate.value);
      
      this.profiles.update(profiles => [...profiles, newProfile]);
      
      const statesToDuplicate = this.profileWidgetStates()[index];
      this.profileWidgetStates.update(states => [...states, {...statesToDuplicate}]);
      
      const menusToDuplicate = this.dynamicSubMenus()[index];
      this.dynamicSubMenus.update(menus => [...menus, {...menusToDuplicate}]);

      const newIndex = this.profiles().length - 1;
      this.setActiveProfile(newIndex);
    }
  }
  }
  ---------------
import { Component, ViewChild, ViewContainerRef, inject, effect } from '@angular/core';
import { NgFor, NgIf } from '@angular/common';
import { ProfileBuilderService } from './profile-builder.service';
import { LeftMenuComponent } from './left-menu.component';

@Component({
  selector: 'app-party-builder',
  standalone: true,
  imports: [NgFor, NgIf, LeftMenuComponent],
  template: `
    <div class="profile-selector">
      <button *ngFor="let profile of profiles; let i = index"
              (click)="setActiveProfile(i)"
              [class.active]="i === activeProfileIndex()">
        Profile {{ i + 1 }}
      </button>
      <button (click)="addNewProfile()">Add New Profile</button>
    </div>
    <div class="party-builder" *ngIf="activeProfile()">
      <app-left-menu></app-left-menu>
      <div #widgetContainer></div>
    </div>
    <button (click)="validateAll()">Validate All</button>
    <button (click)="loadAllWidgets()">Load All Widgets</button>
    <button (click)="loadNextIncompleteWidget()">Next Incomplete Widget</button>
  `
})
export class PartyBuilderComponent {
  @ViewChild('widgetContainer', { read: ViewContainerRef, static: false })
  widgetContainer!: ViewContainerRef;

  private profileBuilder = inject(ProfileBuilderService);

  profiles = this.profileBuilder.getProfiles;
  activeProfile = this.profileBuilder.getActiveProfile;
  activeProfileIndex = this.profileBuilder.activeProfileIndex;

  constructor() {
    effect(() => {
      const activeWidgetName = this.profileBuilder.getActiveWidgetName();
      if (activeWidgetName) {
        this.loadComponent(activeWidgetName);
      }
    });
  }

  async loadComponent(widgetName: string) {
    this.widgetContainer.clear();
    const widgetConfig = this.profileBuilder.findWidgetByName(widgetName);
    if (widgetConfig && widgetConfig.component) {
      const component = await widgetConfig.component();
      const componentRef = this.widgetContainer.createComponent(component);
      if (componentRef.instance.setFormGroup) {
        const formGroup = this.profileBuilder.getWidgetFormGroup(widgetName);
        if (formGroup) {
          componentRef.instance.setFormGroup(formGroup);
        }
      }
    }
  }

  setActiveProfile(index: number) {
    this.profileBuilder.setActiveProfile(index);
  }

  addNewProfile() {
    this.profileBuilder.addNewProfile();
  }

  validateAll() {
    const isValid = this.profileBuilder.validateAllWidgets();
    console.log(isValid ? 'All widgets are valid' : 'There are validation errors');
    console.log('Completion percentage:', this.profileBuilder.getCompletionPercentage());
  }

  loadAllWidgets() {
    this.profileBuilder.loadAllWidgets();
  }

  loadNextIncompleteWidget() {
    const nextWidgetName = this.profileBuilder.getNextIncompleteWidget();
    if (nextWidgetName) {
      this.profileBuilder.setActiveWidget(nextWidgetName);
    } else {
      console.log('All widgets are complete!');
    }
  }
}


