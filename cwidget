// libs/pipes/src/lib/pipes.ts

import { Pipe, PipeTransform, OnDestroy } from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { formatDistanceToNow } from 'date-fns';
import { Subject, debounceTime } from 'rxjs';

@Pipe({
  name: 'safeHtml',
  standalone: true
})
export class SafeHtmlPipe implements PipeTransform {
  constructor(private sanitizer: DomSanitizer) {}

  transform(value: string): SafeHtml {
    return this.sanitizer.bypassSecurityTrustHtml(value);
  }
}

@Pipe({
  name: 'truncate',
  standalone: true
})
export class TruncatePipe implements PipeTransform {
  transform(value: string, limit = 25, completeWords = false, ellipsis = '...'): string {
    if (!value) return '';
    if (value.length <= limit) return value;

    if (completeWords) {
      limit = value.substring(0, limit).lastIndexOf(' ');
    }
    return `${value.substring(0, limit)}${ellipsis}`;
  }
}

@Pipe({
  name: 'filter',
  standalone: true
})
export class FilterPipe implements PipeTransform {
  transform<T>(items: T[], field: keyof T, value: any): T[] {
    if (!items) return [];
    if (!field || value === undefined || value === null) return items;

    return items.filter(item => 
      String(item[field]).toLowerCase().includes(String(value).toLowerCase())
    );
  }
}

@Pipe({
  name: 'sortBy',
  standalone: true
})
export class SortByPipe implements PipeTransform {
  transform<T>(array: T[], field: keyof T, order: 'asc' | 'desc' = 'asc'): T[] {
    if (!Array.isArray(array) || !field) return array;

    return [...array].sort((a, b) => {
      if (a[field] < b[field]) return order === 'asc' ? -1 : 1;
      if (a[field] > b[field]) return order === 'asc' ? 1 : -1;
      return 0;
    });
  }
}

@Pipe({
  name: 'timeAgo',
  standalone: true
})
export class TimeAgoPipe implements PipeTransform {
  transform(value: string | number | Date): string {
    if (!value) return '';
    return formatDistanceToNow(new Date(value), { addSuffix: true });
  }
}

@Pipe({
  name: 'fileSize',
  standalone: true
})
export class FileSizePipe implements PipeTransform {
  transform(bytes: number, decimals = 2): string {
    if (!+bytes) return '0 Bytes';

    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
  }
}

@Pipe({
  name: 'highlight',
  standalone: true
})
export class HighlightPipe implements PipeTransform {
  transform(text: string, search: string): string {
    if (!search) return text;
    const pattern = search
      .replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
      .split(' ')
      .filter(t => t.length > 0)
      .join('|');
    const regex = new RegExp(pattern, 'gi');
    return text.replace(regex, match => `<mark>${match}</mark>`);
  }
}

@Pipe({
  name: 'enumToArray',
  standalone: true
})
export class EnumToArrayPipe implements PipeTransform {
  transform(enumObj: any): { key: string; value: any }[] {
    return Object.keys(enumObj)
      .filter(key => isNaN(Number(key)))
      .map(key => ({ key, value: enumObj[key] }));
  }
}

@Pipe({
  name: 'objectEntries',
  standalone: true
})
export class ObjectEntriesPipe implements PipeTransform {
  transform(obj: { [key: string]: any }): [string, any][] {
    return Object.entries(obj);
  }
}

@Pipe({
  name: 'groupBy',
  standalone: true
})
export class GroupByPipe implements PipeTransform {
  transform<T>(array: T[], property: keyof T): { key: any; value: T[] }[] {
    if (!array) return [];

    const groups = array.reduce((acc, item) => {
      const key = item[property];
      if (!acc[key]) {
        acc[key] = [];
      }
      acc[key].push(item);
      return acc;
    }, {} as { [key: string]: T[] });

    return Object.keys(groups).map(key => ({
      key,
      value: groups[key]
    }));
  }
}

@Pipe({
  name: 'debounce',
  standalone: true,
  pure: false
})
export class DebouncePipe implements PipeTransform, OnDestroy {
  private subject = new Subject<any>();
  private latestValue: any = null;

  constructor() {
    this.subject.pipe(debounceTime(300)).subscribe(value => {
      this.latestValue = value;
    });
  }

  transform(value: any): any {
    this.subject.next(value);
    return this.latestValue;
  }

  ngOnDestroy() {
    this.subject.complete();
  }
}

@Pipe({
  name: 'isEmpty',
  standalone: true
})
export class IsEmptyPipe implements PipeTransform {
  transform(value: any): boolean {
    if (value === null || value === undefined) return true;
    if (typeof value === 'string') return value.trim().length === 0;
    if (Array.isArray(value)) return value.length === 0;
    if (typeof value === 'object') return Object.keys(value).length === 0;
    return false;
  }
}

@Pipe({
  name: 'highlightChange',
  standalone: true,
  pure: true
})
export class HighlightChangePipe implements PipeTransform {
  transform(value: any, previousValue: any, duration: number = 2000): string {
    if (value !== previousValue) {
      return `highlight highlight-${duration}`;
    }
    return '';
  }
}

// Export all pipes
export const PIPES = [
  SafeHtmlPipe,
  TruncatePipe,
  FilterPipe,
  SortByPipe,
  TimeAgoPipe,
  FileSizePipe,
  HighlightPipe,
  EnumToArrayPipe,
  ObjectEntriesPipe,
  GroupByPipe,
  DebouncePipe,
  IsEmptyPipe,
  HighlightChangePipe
];

// libs/pipes/src/index.ts
export * from './lib/pipes';

-------------
// libs/pipes/src/lib/pipes.spec.ts

import { TestBed } from '@angular/core/testing';
import { DomSanitizer } from '@angular/platform-browser';
import {
  SafeHtmlPipe,
  TruncatePipe,
  FilterPipe,
  SortByPipe,
  TimeAgoPipe,
  FileSizePipe,
  HighlightPipe,
  EnumToArrayPipe,
  ObjectEntriesPipe,
  GroupByPipe,
  DebouncePipe,
  IsEmptyPipe,
  HighlightChangePipe
} from './pipes';

describe('Pipes Library', () => {
  let sanitizer: DomSanitizer;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    sanitizer = TestBed.inject(DomSanitizer);
  });

  describe('SafeHtmlPipe', () => {
    it('should sanitize HTML', () => {
      const pipe = new SafeHtmlPipe(sanitizer);
      const html = '<script>alert("XSS")</script>';
      const sanitizedHtml = pipe.transform(html);
      expect(sanitizer.bypassSecurityTrustHtml).toHaveBeenCalledWith(html);
      expect(sanitizedHtml).toBeTruthy();
    });
  });

  describe('TruncatePipe', () => {
    const pipe = new TruncatePipe();

    it('should truncate text', () => {
      expect(pipe.transform('Hello World', 5)).toBe('Hello...');
    });

    it('should preserve whole words', () => {
      expect(pipe.transform('Hello World', 7, true)).toBe('Hello...');
    });

    it('should not truncate if text is shorter than limit', () => {
      expect(pipe.transform('Hello', 10)).toBe('Hello');
    });
  });

  describe('FilterPipe', () => {
    const pipe = new FilterPipe();
    const items = [
      { name: 'John', age: 25 },
      { name: 'Jane', age: 30 },
      { name: 'Bob', age: 35 }
    ];

    it('should filter items', () => {
      const result = pipe.transform(items, 'name', 'Jo');
      expect(result.length).toBe(1);
      expect(result[0].name).toBe('John');
    });

    it('should return all items if no filter value', () => {
      expect(pipe.transform(items, 'name', '')).toEqual(items);
    });

    it('should return empty array if items is null', () => {
      expect(pipe.transform(null, 'name', 'John')).toEqual([]);
    });
  });

  describe('SortByPipe', () => {
    const pipe = new SortByPipe();
    const items = [
      { name: 'John', age: 25 },
      { name: 'Jane', age: 30 },
      { name: 'Bob', age: 35 }
    ];

    it('should sort items ascending', () => {
      const result = pipe.transform(items, 'age');
      expect(result[0].name).toBe('John');
      expect(result[2].name).toBe('Bob');
    });

    it('should sort items descending', () => {
      const result = pipe.transform(items, 'age', 'desc');
      expect(result[0].name).toBe('Bob');
      expect(result[2].name).toBe('John');
    });

    it('should return original array if not sortable', () => {
      expect(pipe.transform(null, 'age')).toBeNull();
    });
  });

  describe('TimeAgoPipe', () => {
    const pipe = new TimeAgoPipe();

    it('should return time ago', () => {
      const date = new Date();
      date.setMinutes(date.getMinutes() - 5);
      expect(pipe.transform(date)).toContain('5 minutes ago');
    });

    it('should return empty string for invalid date', () => {
      expect(pipe.transform('')).toBe('');
    });
  });

  describe('FileSizePipe', () => {
    const pipe = new FileSizePipe();

    it('should format file size', () => {
      expect(pipe.transform(1024)).toBe('1 KB');
      expect(pipe.transform(1048576)).toBe('1 MB');
      expect(pipe.transform(1073741824)).toBe('1 GB');
    });

    it('should return 0 Bytes for 0', () => {
      expect(pipe.transform(0)).toBe('0 Bytes');
    });
  });

  describe('HighlightPipe', () => {
    const pipe = new HighlightPipe();

    it('should highlight search term', () => {
      const result = pipe.transform('Hello World', 'World');
      expect(result).toBe('Hello <mark>World</mark>');
    });

    it('should return original text if no search term', () => {
      expect(pipe.transform('Hello World', '')).toBe('Hello World');
    });
  });

  describe('EnumToArrayPipe', () => {
    const pipe = new EnumToArrayPipe();

    enum TestEnum {
      A = 'Value A',
      B = 'Value B'
    }

    it('should convert enum to array', () => {
      const result = pipe.transform(TestEnum);
      expect(result).toEqual([
        { key: 'A', value: 'Value A' },
        { key: 'B', value: 'Value B' }
      ]);
    });
  });

  describe('ObjectEntriesPipe', () => {
    const pipe = new ObjectEntriesPipe();

    it('should convert object to entries', () => {
      const obj = { a: 1, b: 2 };
      const result = pipe.transform(obj);
      expect(result).toEqual([['a', 1], ['b', 2]]);
    });
  });

  describe('GroupByPipe', () => {
    const pipe = new GroupByPipe();
    const items = [
      { name: 'John', category: 'A' },
      { name: 'Jane', category: 'B' },
      { name: 'Bob', category: 'A' }
    ];

    it('should group items', () => {
      const result = pipe.transform(items, 'category');
      expect(result.length).toBe(2);
      expect(result[0].key).toBe('A');
      expect(result[0].value.length).toBe(2);
    });

    it('should return empty array for null input', () => {
      expect(pipe.transform(null, 'category')).toEqual([]);
    });
  });

  describe('DebouncePipe', () => {
    let pipe: DebouncePipe;

    beforeEach(() => {
      pipe = new DebouncePipe();
      jest.useFakeTimers();
    });

    afterEach(() => {
      jest.useRealTimers();
    });

    it('should debounce value changes', () => {
      let result = pipe.transform('test1');
      expect(result).toBeNull();

      result = pipe.transform('test2');
      expect(result).toBeNull();

      jest.advanceTimersByTime(300);
      expect(result).toBe('test2');
    });

    it('should clean up on destroy', () => {
      const completeSpy = jest.spyOn(pipe['subject'], 'complete');
      pipe.ngOnDestroy();
      expect(completeSpy).toHaveBeenCalled();
    });
  });

  describe('IsEmptyPipe', () => {
    const pipe = new IsEmptyPipe();

    it('should check if value is empty', () => {
      expect(pipe.transform(null)).toBe(true);
      expect(pipe.transform(undefined)).toBe(true);
      expect(pipe.transform([])).toBe(true);
      expect(pipe.transform({})).toBe(true);
      expect(pipe.transform('')).toBe(true);
      expect(pipe.transform('  ')).toBe(true);
      expect(pipe.transform([1, 2, 3])).toBe(false);
      expect(pipe.transform({ a: 1 })).toBe(false);
      expect(pipe.transform('text')).toBe(false);
    });
  });

  describe('HighlightChangePipe', () => {
    const pipe = new HighlightChangePipe();

    it('should highlight changes', () => {
      expect(pipe.transform('new', 'old')).toBe('highlight highlight-2000');
      expect(pipe.transform('same', 'same')).toBe('');
    });

    it('should use custom duration', () => {
      expect(pipe.transform('new', 'old', 1000)).toBe('highlight highlight-1000');
    });
  });
});
