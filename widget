// widget-config.ts
import { Type } from '@angular/core';

export interface SubMenuItem {
  name: string;
  label: string;
  component?: () => Promise<Type<any>>;
  visible: boolean;
  subMenu?: SubMenuItem[] | (() => Promise<SubMenuItem[]>) | 'dynamic' | 'api';
}

export interface WidgetConfig {
  name: string;
  label: string;
  component?: () => Promise<Type<any>>;
  visible: boolean;
  subMenu?: SubMenuItem[] | (() => Promise<SubMenuItem[]>) | 'dynamic' | 'api';
}

export interface WidgetState {
  hasError: boolean;
  errorMessage?: string;
  visited: boolean;
  acknowledged: boolean;
  active: boolean;
  status: 'pending' | 'in-progress' | 'completed' | 'error';
}

export const WIDGET_CONFIG: WidgetConfig[] = [
  {
    name: 'personal',
    label: 'Personal Info',
    component: () => import('./personal-info.component').then(m => m.PersonalInfoComponent),
    visible: true,
    subMenu: [
      {
        name: 'basic',
        label: 'Basic Info',
        component: () => import('./basic-info.component').then(m => m.BasicInfoComponent),
        visible: true,
      },
      {
        name: 'contact',
        label: 'Contact Info',
        component: () => import('./contact-info.component').then(m => m.ContactInfoComponent),
        visible: true,
        subMenu: 'dynamic'
      }
    ]
  },
  {
    name: 'financial',
    label: 'Financial Info',
    visible: true,
    subMenu: async () => {
      const response = await fetch('/api/financial-sub-menu');
      const data = await response.json();
      return data.map((item: any) => ({
        name: item.name,
        label: item.label,
        component: item.componentName ? () => import(`./financial/${item.componentName}`).then(m => m[item.exportName]) : undefined,
        visible: item.visible,
        subMenu: item.subMenu
      }));
    }
  }
];

// profile-builder.service.ts
import { Injectable, signal, computed, inject, WritableSignal } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { HttpClient } from '@angular/common/http';
import { WIDGET_CONFIG, WidgetConfig, SubMenuItem, WidgetState } from './widget-config';

@Injectable({ providedIn: 'root' })
export class ProfileBuilderService {
  private fb = inject(FormBuilder);
  private http = inject(HttpClient);

  private profiles: WritableSignal<FormGroup[]> = signal([]);
  private activeProfileIndex: WritableSignal<number | null> = signal(null);
  private activeWidgetPath: WritableSignal<string[]> = signal([]);
  private dynamicSubMenus: WritableSignal<Record<string, SubMenuItem[]>> = signal({});
  private widgetStates: WritableSignal<Record<string, WidgetState>> = signal({});

  async setActiveWidgetPath(path: string[]) {
    this.activeWidgetPath.set(path);
    await this.loadSubMenus(path);
    this.updateWidgetState(path.join('.'), { active: true, visited: true, status: 'in-progress' });
  }

  private async loadSubMenus(path: string[]) {
    let currentConfig: WidgetConfig | SubMenuItem | undefined = WIDGET_CONFIG.find(w => w.name === path[0]);
    let currentPath = path[0];

    for (let i = 0; i < path.length; i++) {
      if (!this.dynamicSubMenus()[currentPath] && currentConfig?.subMenu) {
        let subMenu: SubMenuItem[];
        if (typeof currentConfig.subMenu === 'function') {
          subMenu = await currentConfig.subMenu();
        } else if (currentConfig.subMenu === 'dynamic') {
          subMenu = await this.generateDynamicSubMenu(currentPath);
        } else if (currentConfig.subMenu === 'api') {
          subMenu = await this.fetchSubMenuFromApi(currentPath);
        } else {
          subMenu = currentConfig.subMenu;
        }
        this.dynamicSubMenus.update(current => ({...current, [currentPath]: subMenu}));
      }

      if (i < path.length - 1) {
        const subMenu = this.getSubMenuItems(currentPath);
        currentConfig = subMenu.find(item => item.name === path[i + 1]);
        currentPath += `.${path[i + 1]}`;
      }
    }
  }

  private async generateDynamicSubMenu(path: string): Promise<SubMenuItem[]> {
    // Implement dynamic sub-menu generation logic here
    return [];
  }

  private async fetchSubMenuFromApi(path: string): Promise<SubMenuItem[]> {
    // Implement API call to fetch sub-menu here
    return [];
  }

  updateWidgetState(path: string, update: Partial<WidgetState>) {
    this.widgetStates.update(states => ({
      ...states,
      [path]: { ...states[path], ...update }
    }));
  }

  getWidgetState(path: string): WidgetState {
    return this.widgetStates()[path] || {
      hasError: false,
      visited: false,
      acknowledged: false,
      active: false,
      status: 'pending'
    };
  }

  acknowledgeWidget(path: string) {
    this.updateWidgetState(path, { acknowledged: true });
    this.updateParentAcknowledgmentStatus(path);
  }

  private updateParentAcknowledgmentStatus(path: string) {
    const pathParts = path.split('.');
    while (pathParts.length > 1) {
      pathParts.pop();
      const parentPath = pathParts.join('.');
      const parentSubMenu = this.getSubMenuItems(parentPath);
      const allChildrenAcknowledged = parentSubMenu.every(item => 
        this.getWidgetState(`${parentPath}.${item.name}`).acknowledged
      );
      this.updateWidgetState(parentPath, { acknowledged: allChildrenAcknowledged });
    }
  }

  setWidgetError(path: string, errorMessage: string) {
    this.updateWidgetState(path, { hasError: true, errorMessage, status: 'error' });
  }

  clearWidgetError(path: string) {
    this.updateWidgetState(path, { hasError: false, errorMessage: undefined, status: 'in-progress' });
  }

  getVisibleWidgets = computed(() => {
    return this.getSubMenuItems('');
  });

  getSubMenuItems(path: string): (WidgetConfig | SubMenuItem)[] {
    let items: (WidgetConfig | SubMenuItem)[] = path === '' ? WIDGET_CONFIG : (this.dynamicSubMenus()[path] || []);
    return items.filter(item => item.visible).map(item => ({
      ...item,
      state: this.getWidgetState(path ? `${path}.${item.name}` : item.name),
      subMenuItems: item.subMenu ? this.getSubMenuItems(path ? `${path}.${item.name}` : item.name) : []
    }));
  }

  getActiveProfile(): FormGroup | null {
    const index = this.activeProfileIndex();
    return index !== null ? this.profiles()[index] : null;
  }

  addNewProfile() {
    const newProfile = this.fb.group({});
    this.profiles.update(profiles => [...profiles, newProfile]);
    this.setActiveProfile(this.profiles().length - 1);
  }

  setActiveProfile(index: number) {
    if (index >= 0 && index < this.profiles().length) {
      this.activeProfileIndex.set(index);
      this.resetWidgetStates();
    }
  }

  private resetWidgetStates() {
    this.widgetStates.set({});
    this.activeWidgetPath.set([]);
  }

  // Helper method to get the full widget path
  getFullWidgetPath(partialPath: string): string[] {
    const activePath = this.activeWidgetPath();
    const fullPath = activePath.slice(0, activePath.lastIndexOf(partialPath.split('.')[0]) + 1).concat(partialPath.split('.'));
    return fullPath;
  }

  // Helper method to check if a widget is fully acknowledged (including all sub-items)
  isWidgetFullyAcknowledged(path: string): boolean {
    const state = this.getWidgetState(path);
    if (!state.acknowledged) return false;

    const subItems = this.getSubMenuItems(path);
    return subItems.every(item => this.isWidgetFullyAcknowledged(`${path}.${item.name}`));
  }
}

// left-menu.component.ts
import { Component, inject, Output, EventEmitter } from '@angular/core';
import { NgFor, NgIf, NgClass } from '@angular/common';
import { ProfileBuilderService } from './profile-builder.service';
import { SubMenuItem, WidgetConfig } from './widget-config';

@Component({
  selector: 'app-left-menu',
  standalone: true,
  imports: [NgFor, NgIf, NgClass],
  template: `
    <nav>
      <ul>
        <ng-container *ngTemplateOutlet="menuTemplate; context: { items: profileService.getVisibleWidgets(), parentPath: '' }"></ng-container>
      </ul>
    </nav>

    <ng-template #menuTemplate let-items="items" let-parentPath="parentPath">
      <li *ngFor="let item of items">
        <a (click)="onItemClick(parentPath ? parentPath + '.' + item.name : item.name)" 
           [ngClass]="{
             'active': item.state.active,
             'visited': item.state.visited,
             'error': item.state.hasError,
             'acknowledged': profileService.isWidgetFullyAcknowledged(parentPath ? parentPath + '.' + item.name : item.name),
             [item.state.status]: true
           }">
          {{ item.label }}
          <span *ngIf="item.state.hasError" class="error-indicator" [title]="item.state.errorMessage">!</span>
          <button *ngIf="item.state.hasError && !item.state.acknowledged" (click)="acknowledgeError(parentPath ? parentPath + '.' + item.name : item.name, $event)">Ack</button>
        </a>
        <ul *ngIf="item.subMenuItems && item.subMenuItems.length > 0">
          <ng-container *ngTemplateOutlet="menuTemplate; context: { items: item.subMenuItems, parentPath: parentPath ? parentPath + '.' + item.name : item.name }"></ng-container>
        </ul>
      </li>
    </ng-template>
  `
})
export class LeftMenuComponent {
  profileService = inject(ProfileBuilderService);
  @Output() widgetPathSelected = new EventEmitter<string>();

  async onItemClick(path: string) {
    const fullPath = this.profileService.getFullWidgetPath(path);
    await this.profileService.setActiveWidgetPath(fullPath);
    this.widgetPathSelected.emit(fullPath.join('.'));
  }

  acknowledgeError(path: string, event: Event) {
    event.stopPropagation();
    this.profileService.acknowledgeWidget(path);
  }
}

// party-builder.component.ts
import { Component, ViewContainerRef, ViewChild, inject } from '@angular/core';
import { AsyncPipe, NgFor, NgIf } from '@angular/common';
import { ProfileBuilderService } from './profile-builder.service';
import { LeftMenuComponent } from './left-menu.component';
import { WidgetConfig, SubMenuItem } from './widget-config';

@Component({
  selector: 'app-party-builder',
  standalone: true,
  imports: [AsyncPipe, NgFor, NgIf, LeftMenuComponent],
  template: `
    <div class="party-builder">
      <app-left-menu (widgetPathSelected)="onWidgetPathSelected($event)"></app-left-menu>
      <div class="widget-container">
        <ng-container #widgetContainer></ng-container>
      </div>
    </div>
    <button (click)="addNewProfile()">Add New Profile</button>
    <button (click)="validateAll()">Validate All</button>
  `
})
export class PartyBuilderComponent {
  @ViewChild('widgetContainer', { read: ViewContainerRef, static: true })
  widgetContainer!: ViewContainerRef;

  profileService = inject(ProfileBuilderService);

  async onWidgetPathSelected(path: string) {
    const pathArray = path.split('.');
    await this.profileService.setActiveWidgetPath(pathArray);
    this.loadComponent(pathArray);
  }

  async loadComponent(pathArray: string[]) {
    this.widgetContainer.clear();
    
    let currentItem: WidgetConfig | SubMenuItem | undefined = 
      this.profileService.getVisibleWidgets().find(w => w.name === pathArray[0]);
    
    for (let i = 1; i < pathArray.length; i++) {
      currentItem = currentItem?.subMenuItems?.find(item => item.name === pathArray[i]);
    }

    if (currentItem?.component) {
      const component = await currentItem.component();
      const componentRef = this.widgetContainer.createComponent(component);
      
      if (componentRef.instance.setFormGroup) {
        const activeProfile = this.profileService.getActiveProfile();
        if (activeProfile) {
          componentRef.instance.setFormGroup(activeProfile.get(pathArray.join('.')) as FormGroup);
        }
      }
    } else {
      console.log('No component for this menu item');
    }
  }

  addNewProfile() {
    this.profileService.addNewProfile();
  }

  validateAll() {
    // Implement validation logic here
  }

  // Method to simulate setting an error
  setError(path: string, errorMessage: string) {
    this.profileService.setWidgetError(path, errorMessage);
  }
}

// app.component.ts
private async generateDynamicSubMenu(path: string): Promise<SubMenuItem[]> {
  // This is a placeholder implementation. You should customize this based on your specific requirements.
  const baseSubMenuItems: SubMenuItem[] = [
    {
      name: 'dynamicItem1',
      label: 'Dynamic Item 1',
      component: () => import('./dynamic-item1.component').then(m => m.DynamicItem1Component),
      visible: true
    },
    {
      name: 'dynamicItem2',
      label: 'Dynamic Item 2',
      component: () => import('./dynamic-item2.component').then(m => m.DynamicItem2Component),
      visible: true
    }
  ];

  // Example: Add conditional items based on the path
  if (path.includes('financial')) {
    baseSubMenuItems.push({
      name: 'financialDynamicItem',
      label: 'Financial Dynamic Item',
      component: () => import('./financial-dynamic-item.component').then(m => m.FinancialDynamicItemComponent),
      visible: true
    });
  }

  // Example: Add items based on user role (you would need to inject a user service to get this information)
  const userRole = await this.getUserRole(); // Implement this method to get the user's role
  if (userRole === 'admin') {
    baseSubMenuItems.push({
      name: 'adminOnlyItem',
      label: 'Admin Only Item',
      component: () => import('./admin-only-item.component').then(m => m.AdminOnlyItemComponent),
      visible: true
    });
  }

  // Example: Add items based on the current date
  const currentDate = new Date();
  if (currentDate.getMonth() === 11) { // December
    baseSubMenuItems.push({
      name: 'endOfYearReview',
      label: 'End of Year Review',
      component: () => import('./end-of-year-review.component').then(m => m.EndOfYearReviewComponent),
      visible: true
    });
  }

  return baseSubMenuItems;
}

// Helper method to get user role (implement this based on your authentication system)
private async getUserRole(): Promise<string> {
  // This is a placeholder. Implement your actual logic to get the user's role.
  // For example, you might use a UserService to fetch this information.
  return 'user'; // or 'admin', etc.
}
