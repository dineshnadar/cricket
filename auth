import { Injectable, inject, signal, computed, effect } from '@angular/core';
import { Observable, of, throwError } from 'rxjs';
import { tap, map, catchError } from 'rxjs/operators';
import { ApiService } from './api.service';
import { CacheDataService } from './cache-data.service';

export interface User {
  id: string;
  username: string;
  email: string;
  roles: string[];
}

interface AuthResponse {
  token: string;
  refreshToken: string;
  user: User;
}

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private apiService = inject(ApiService);
  private cacheDataService = inject(CacheDataService);

  private userSignal = signal<User | null>(null);
  private tokenSignal = signal<string | null>(null);
  private refreshTokenSignal = signal<string | null>(null);

  isAuthenticated = computed(() => !!this.tokenSignal());
  currentUser = computed(() => this.userSignal());

  constructor() {
    effect(() => {
      const token = this.tokenSignal();
      const refreshToken = this.refreshTokenSignal();
      const user = this.userSignal();

      if (token && refreshToken && user) {
        this.cacheDataService.set('auth_token', token);
        this.cacheDataService.set('refresh_token', refreshToken);
        this.cacheDataService.set('user', user);
      } else {
        this.cacheDataService.remove('auth_token');
        this.cacheDataService.remove('refresh_token');
        this.cacheDataService.remove('user');
      }
    });

    const storedToken = this.cacheDataService.get<string>('auth_token');
    const storedRefreshToken = this.cacheDataService.get<string>('refresh_token');
    const storedUser = this.cacheDataService.get<User>('user');
    if (storedToken && storedRefreshToken && storedUser) {
      this.setAuthState(storedToken, storedRefreshToken, storedUser);
    }
  }

  login(credentials: { username: string; password: string }): Observable<User> {
    return this.apiService.post<AuthResponse>('login', credentials).pipe(
      tap(response => this.setAuthState(response.token, response.refreshToken, response.user)),
      map(response => response.user),
      catchError(error => {
        console.error('Login failed', error);
        return throwError(() => new Error('Invalid username or password'));
      })
    );
  }

  logout(): void {
    this.setAuthState(null, null, null);
  }

  getToken(): string | null {
    return this.tokenSignal();
  }

  getRefreshToken(): string | null {
    return this.refreshTokenSignal();
  }

  hasRole(role: string): boolean {
    const user = this.currentUser();
    return user ? user.roles.includes(role) : false;
  }

  refreshToken(): Observable<string> {
    const refreshToken = this.getRefreshToken();
    if (!refreshToken) {
      return throwError(() => new Error('No refresh token available'));
    }
    return this.apiService.post<AuthResponse>('refreshToken', { refreshToken }).pipe(
      tap(response => this.setAuthState(response.token, response.refreshToken, response.user)),
      map(response => response.token),
      catchError(error => {
        console.error('Token refresh failed', error);
        this.logout();
        return throwError(() => new Error('Token refresh failed'));
      })
    );
  }

  checkAuth(): Observable<boolean> {
    if (!this.isAuthenticated()) {
      return of(false);
    }
    return this.apiService.post<{ isValid: boolean }>('validateToken', { token: this.getToken() }).pipe(
      map(response => {
        if (!response.isValid) {
          this.logout();
        }
        return response.isValid;
      }),
      catchError(() => {
        this.logout();
        return of(false);
      })
    );
  }

  private setAuthState(token: string | null, refreshToken: string | null, user: User | null): void {
    this.tokenSignal.set(token);
    this.refreshTokenSignal.set(refreshToken);
    this.userSignal.set(user);
  }
}
----------
import { Injectable, inject } from '@angular/core';
import { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError, BehaviorSubject } from 'rxjs';
import { catchError, switchMap, filter, take } from 'rxjs/operators';
import { AuthService } from './auth.service';
import { API_CONFIG } from './api.config';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  private authService = inject(AuthService);
  private isRefreshing = false;
  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);

  intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {
    if (this.isAuthEndpoint(request)) {
      return next.handle(request);
    }

    const token = this.authService.getToken();

    if (token) {
      request = this.addToken(request, token);
    }

    return next.handle(request).pipe(
      catchError(error => {
        if (error instanceof HttpErrorResponse && error.status === 890) {
          return this.handle890Error(request, next);
        } else {
          return throwError(() => error);
        }
      })
    );
  }

  private isAuthEndpoint(request: HttpRequest<any>): boolean {
    return Object.values(API_CONFIG.endpoints)
      .some(endpoint => request.url.includes(endpoint.url) && endpoint.url.includes('/auth'));
  }

  private addToken(request: HttpRequest<any>, token: string) {
    return request.clone({
      setHeaders: {
        'Authorization': `Bearer ${token}`
      }
    });
  }

  private handle890Error(request: HttpRequest<any>, next: HttpHandler) {
    if (!this.isRefreshing) {
      this.isRefreshing = true;
      this.refreshTokenSubject.next(null);

      return this.authService.refreshToken().pipe(
        switchMap((token: string) => {
          this.isRefreshing = false;
          this.refreshTokenSubject.next(token);
          return next.handle(this.addToken(request, token));
        }),
        catchError((error) => {
          this.isRefreshing = false;
          this.authService.logout();
          return throwError(() => error);
        })
      );
    } else {
      return this.refreshTokenSubject.pipe(
        filter(token => token != null),
        take(1),
        switchMap(token => {
          return next.handle(this.addToken(request, token));
        })
      );
    }
  }
}
-----------auth guard

import { Injectable, inject } from '@angular/core';
import { CanActivate, CanActivateChild, CanLoad, Router, UrlTree } from '@angular/router';
import { Observable, map } from 'rxjs';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate, CanActivateChild, CanLoad {
  private authService = inject(AuthService);
  private router = inject(Router);

  canActivate(): Observable<boolean | UrlTree> {
    return this.checkAuth();
  }

  canActivateChild(): Observable<boolean | UrlTree> {
    return this.checkAuth();
  }

  canLoad(): Observable<boolean | UrlTree> {
    return this.checkAuth();
  }

  private checkAuth(): Observable<boolean | UrlTree> {
    return this.authService.checkAuth().pipe(
      map(isAuthenticated => {
        if (isAuthenticated) {
          return true;
        } else {
          return this.router.createUrlTree(['/login']);
        }
      })
    );
  }
}
----------
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { AuthInterceptor } from './auth.interceptor';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    HttpClientModule,
    AppRoutingModule
  ],
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
