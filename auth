private getRequestOptions(config: ApiEndpointConfig): {
    headers?: HttpHeaders;
    params?: HttpParams;
    withCredentials?: boolean;
  } {
    const options: {
      headers?: HttpHeaders;
      params?: HttpParams;
      withCredentials?: boolean;
    } = {};

    if (config.headers) {
      options.headers = new HttpHeaders(config.headers);
    }

    if (config.params) {
      options.params = new HttpParams({ fromObject: config.params });
    }

    if (config.withCredentials !== undefined) {
      options.withCredentials = config.withCredentials;
    }

    return options;
  }

private applyRetryLogic(config: ApiEndpointConfig) {
    if (config.retryEnabled && config.maxRetries && config.maxRetries > 0) {
      return retry({
        count: config.maxRetries,
        delay: (error, retryCount) => {
          if (error instanceof HttpErrorResponse && error.status >= 500) {
            return timer((config.retryDelay || 1000) * Math.pow(2, retryCount));
          }
          return throwError(() => error);
        },
      });
    }
    return (source: Observable<any>) => source;
  }

private fetchData<T>(
    endpointKey: string,
    method: HttpMethod,
    data?: any,
    id?: number
  ): Observable<T> {
    const config = API_CONFIG.endpoints[endpointKey as keyof ApiEndpoints];
    if (!config) {
      return throwError(() => new Error(`No configuration found for endpoint: ${endpointKey}`));
    }

    const url = typeof config.url === 'function' ? config.url(id) : config.url;
    const cacheKey = this.generateCacheKey(config, endpointKey, method, id);

    // Check cache based on method
    if (config.shouldCache) {
      const cachedData = this.checkCache<T>(cacheKey, method, data, config.cacheStorageType || 'memory');
      if (cachedData) {
        return of(cachedData);
      }
    }

    const options = this.getRequestOptions(config);

    let request: Observable<T>;
    const abortOptions = { ...options, signal: this.abortController().signal };

    switch (method) {
      case 'GET':
        request = this.http.get<T>(url, abortOptions);
        break;
      case 'POST':
        request = this.http.post<T>(url, data, abortOptions);
        break;
      case 'PUT':
        request = this.http.put<T>(url, data, abortOptions);
        break;
      case 'PATCH':
        request = this.http.patch<T>(url, data, abortOptions);
        break;
      case 'DELETE':
        request = this.http.delete<T>(url, abortOptions);
        break;
      default:
        return throwError(() => new Error(`Unsupported HTTP method: ${method}`));
    }

    this.pendingRequests.update(set => {
      set.add(cacheKey);
      return new Set(set);
    });

    return request.pipe(
      timeout(config.requestTimeout || 30000),
      this.applyRetryLogic(config),
      tap(response => {
        if (config.shouldCache) {
          this.setCacheData(cacheKey, method, data, response, {
            expiration: config.cacheTimeout,
            storageType: config.cacheStorageType || 'memory'
          });
        }
      }),
      catchError(this.handleError.bind(this)),
      tap(() => {
        this.pendingRequests.update(set => {
          set.delete(cacheKey);
          return new Set(set);
        });
      })
    );
  }
