import { Injectable, signal } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { catchError, of, switchMap, timer, throwError, retryWhen, delay, take, Observable } from 'rxjs';
import { API_CONFIG } from './api.config'; // Import your API config
import { LoggingService } from './logging.service'; // Import your logging service

@Injectable({
  providedIn: 'root',
})
export class ApiService {
  private cache: Record<string, { data: any; timestamp: number; requestBody?: any }> = {};
  public apiData = signal<any>(null); // Angular signal to store API data
  private abortController = new AbortController(); // Create an AbortController instance

  constructor(private http: HttpClient, private loggingService: LoggingService) {}

  private fetchData<T>(
    endpointKey: string,
    method: 'GET' | 'POST' | 'PUT' | 'DELETE',
    requestBody?: any,
    id?: number // For dynamic URLs (like DELETE or PUT)
  ): Observable<any> {
    const config = API_CONFIG.endpoints[endpointKey];
    const url = typeof config.url === 'function' ? config.url(id) : config.url; // Handle dynamic URLs
    const currentTime = Date.now();
    const cacheKey = this.generateCacheKey(url, requestBody); // Generate a unique cache key

    // Check for cached data
    const cachedData = this.getCachedData(cacheKey, config.storageType);

    // If cached data is valid, return it
    if (cachedData) {
      this.apiData.set(cachedData.data); // Update the signal with cached data
      return of(this.apiData); // Return cached data as observable
    }

    // Create a request observable based on the method
    let request$: Observable<T>;
    const signal = this.abortController.signal; // Get the AbortSignal

    if (method === 'GET') {
      request$ = this.http.get<T>(url, { signal }).pipe(
        this.handleResponse(config, currentTime, requestBody, cacheKey),
        this.retryRequest(config),
        catchError(this.handleError)
      );
    } else if (method === 'POST') {
      request$ = this.http.post<T>(url, requestBody, { signal }).pipe(
        this.handleResponse(config, currentTime, requestBody, cacheKey),
        this.retryRequest(config),
        catchError(this.handleError)
      );
    } else if (method === 'PUT') {
      request$ = this.http.put<T>(url, requestBody, { signal }).pipe(
        this.handleResponse(config, currentTime, requestBody, cacheKey),
        this.retryRequest(config),
        catchError(this.handleError)
      );
    } else if (method === 'DELETE') {
      request$ = this.http.delete<T>(url, { signal }).pipe(
        this.handleResponse(config, currentTime, requestBody, cacheKey),
        this.retryRequest(config),
        catchError(this.handleError)
      );
    } else {
      throw new Error(`Unsupported method: ${method}`);
    }

    return request$; // Return the request observable
  }

  // Method to retrieve cached data
  private getCachedData(cacheKey: string, storageType: 'local' | 'session' | 'memory') {
    let cachedData: any = null;

    if (storageType === 'local') {
      cachedData = localStorage.getItem(cacheKey);
    } else if (storageType === 'session') {
      cachedData = sessionStorage.getItem(cacheKey);
    } else if (storageType === 'memory') {
      cachedData = this.cache[cacheKey];
    }

    return cachedData ? JSON.parse(cachedData) : null; // Return parsed cached data or null
  }

  private retryRequest(config: any) {
    // Only apply retry logic if enabled in the config
    return config.retryEnabled
      ? retryWhen((errors) =>
          errors.pipe(
            take(config.maxRetries || 0), // Limit to maxRetries
            delay(config.retryDelay || 1000) // Delay between retries
          )
        )
      : (source: Observable<any>) => source; // Return source as is if retries are not enabled
  }

  private handleResponse<T>(config: any, currentTime: number, requestBody?: any, cacheKey?: string) {
    return switchMap((data: T) => {
      if (config.shouldCache) {
        const timestampedData = { data, timestamp: currentTime, requestBody }; // Store requestBody for POST and PUT
        // Cache in memory
        this.cache[cacheKey] = timestampedData;

        // Cache in local or session storage
        if (config.storageType === 'local') {
          localStorage.setItem(cacheKey, JSON.stringify(timestampedData)); // Cache to local storage
        } else if (config.storageType === 'session') {
          sessionStorage.setItem(cacheKey, JSON.stringify(timestampedData)); // Cache to session storage
        }
      }
      this.apiData.set(data); // Update the signal with new data
      return of(this.apiData); // Return the new data
    });
  }

  private handleError(error: any) {
    this.loggingService.error('API error:', error); // Log the error
    return throwError(error); // Return error to the caller
  }

  // General method for GET requests
  get(endpointKey: string) {
    return this.fetchData(endpointKey, 'GET');
  }

  // General method for POST requests
  post(endpointKey: string, data: any) {
    return this.fetchData(endpointKey, 'POST', data);
  }

  // General method for PUT requests
  put(endpointKey: string, id: number, data: any) {
    return this.fetchData(endpointKey, 'PUT', data, id);
  }

  // General method for DELETE requests
  delete(endpointKey: string, id: number) {
    return this.fetchData(endpointKey, 'DELETE', undefined, id);
  }

  // Cancel ongoing requests
  public cancelRequests() {
    this.abortController.abort();
    this.abortController = new AbortController(); // Reset for future requests
  }

  private generateCacheKey(url: string, requestBody?: any): string {
    // Create a unique cache key based on URL and request body
    return `${url}::${JSON.stringify(requestBody)}`;
  }
}
