import { Injectable, signal } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, of, throwError } from 'rxjs';
import { catchError, map, retry, switchMap } from 'rxjs/operators';
import { API_CONFIG, ApiEndpointConfig } from './api.config';
import { LoggingService } from './logging.service';

type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';

interface CacheEntry<T> {
  data: T;
  timestamp: number;
}

@Injectable({
  providedIn: 'root',
})
export class ApiService {
  private cache: Map<string, CacheEntry<any>> = new Map();
  public apiData = signal<any>(null);
  private abortController = new AbortController();

  constructor(private http: HttpClient, private loggingService: LoggingService) {}

  private fetchData<T>(
    endpointKey: string,
    method: HttpMethod,
    requestBody?: any,
    id?: number
  ): Observable<T> {
    const config = API_CONFIG.endpoints[endpointKey];
    if (!config) {
      return throwError(() => new Error(`No configuration found for endpoint: ${endpointKey}`));
    }

    const url = typeof config.url === 'function' ? config.url(id) : config.url;
    const cacheKey = this.generateCacheKey(config, endpointKey, method, requestBody, id);

    const cachedData = this.getCachedData<T>(cacheKey, config);
    if (cachedData) {
      this.apiData.set(cachedData);
      return of(cachedData);
    }

    const request$ = this.createRequest<T>(url, method, requestBody, config);

    return request$.pipe(
      retry(this.createRetryConfig(config)),
      switchMap((data: T) => this.handleResponse(data, config, cacheKey)),
      catchError((error) => this.handleError(error, endpointKey, method))
    );
  }

  private createRequest<T>(url: string, method: HttpMethod, requestBody: any, config: ApiEndpointConfig): Observable<T> {
    const options = { signal: this.abortController.signal };

    switch (method) {
      case 'GET':
        return this.http.get<T>(url, options);
      case 'POST':
        return this.http.post<T>(url, requestBody, options);
      case 'PUT':
        return this.http.put<T>(url, requestBody, options);
      case 'DELETE':
        return this.http.delete<T>(url, options);
      case 'PATCH':
        return this.http.patch<T>(url, requestBody, options);
      default:
        return throwError(() => new Error(`Unsupported HTTP method: ${method}`));
    }
  }

  private getCachedData<T>(cacheKey: string, config: ApiEndpointConfig): T | null {
    const entry = this.getStorageData(cacheKey, config.storageType);
    if (!entry) return null;

    const { data, timestamp } = entry;
    const now = Date.now();
    if (now - timestamp > (config.cacheDuration || 300000)) { // 5 minutes default
      this.removeFromStorage(cacheKey, config.storageType);
      return null;
    }

    return data;
  }

  private getStorageData(key: string, storageType: 'local' | 'session' | 'memory'): CacheEntry<any> | null {
    let data: string | null = null;
    switch (storageType) {
      case 'local':
        data = localStorage.getItem(key);
        break;
      case 'session':
        data = sessionStorage.getItem(key);
        break;
      case 'memory':
        return this.cache.get(key) || null;
    }
    return data ? JSON.parse(data) : null;
  }

  private removeFromStorage(key: string, storageType: 'local' | 'session' | 'memory'): void {
    switch (storageType) {
      case 'local':
        localStorage.removeItem(key);
        break;
      case 'session':
        sessionStorage.removeItem(key);
        break;
      case 'memory':
        this.cache.delete(key);
        break;
    }
  }

  private createRetryConfig(config: ApiEndpointConfig) {
    return {
      count: config.maxRetries || 3,
      delay: config.retryDelay || 1000,
      resetOnSuccess: true,
    };
  }

  private handleResponse<T>(data: T, config: ApiEndpointConfig, cacheKey: string): Observable<T> {
    if (config.shouldCache) {
      const entry: CacheEntry<T> = { data, timestamp: Date.now() };
      this.setStorageData(cacheKey, entry, config.storageType);
    }
    this.apiData.set(data);
    return of(data);
  }

  private setStorageData(key: string, entry: CacheEntry<any>, storageType: 'local' | 'session' | 'memory'): void {
    const stringifiedEntry = JSON.stringify(entry);
    switch (storageType) {
      case 'local':
        localStorage.setItem(key, stringifiedEntry);
        break;
      case 'session':
        sessionStorage.setItem(key, stringifiedEntry);
        break;
      case 'memory':
        this.cache.set(key, entry);
        break;
    }
  }

  private handleError(error: HttpErrorResponse, endpointKey: string, method: HttpMethod): Observable<never> {
    this.loggingService.error(`API error for ${method} ${endpointKey}:`, error);
    return throwError(() => error);
  }

  get<T>(endpointKey: string): Observable<T> {
    return this.fetchData<T>(endpointKey, 'GET');
  }

  post<T>(endpointKey: string, data: any): Observable<T> {
    return this.fetchData<T>(endpointKey, 'POST', data);
  }

  put<T>(endpointKey: string, id: number, data: any): Observable<T> {
    return this.fetchData<T>(endpointKey, 'PUT', data, id);
  }

  patch<T>(endpointKey: string, id: number, data: any): Observable<T> {
    return this.fetchData<T>(endpointKey, 'PATCH', data, id);
  }

  delete<T>(endpointKey: string, id: number): Observable<T> {
    return this.fetchData<T>(endpointKey, 'DELETE', undefined, id);
  }

  cancelRequests(): void {
    this.abortController.abort();
    this.abortController = new AbortController();
  }

  private generateCacheKey(
    config: ApiEndpointConfig,
    endpointKey: string,
    method: HttpMethod,
    requestBody?: any,
    id?: number
  ): string {
    if (typeof config.cacheKey === 'function') {
      return config.cacheKey({ endpointKey, method, requestBody, id });
    } else if (typeof config.cacheKey === 'string') {
      return config.cacheKey;
    } else {
      // Fallback to a default cache key generation if not provided in the config
      const bodyHash = requestBody ? this.hashCode(JSON.stringify(requestBody)) : '';
      return `${method}:${endpointKey}:${id || ''}:${bodyHash}`;
    }
  }

  private hashCode(s: string): number {
    let hash = 0;
    for (let i = 0; i < s.length; i++) {
      const chr = s.charCodeAt(i);
      hash = ((hash << 5) - hash) + chr;
      hash |= 0; // Convert to 32bit integer
    }
    return hash;
  }
}
