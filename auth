// api.service.ts

import { Injectable, inject, signal, computed } from '@angular/core';
import { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError, timer, of } from 'rxjs';
import { catchError, tap, retry, timeout } from 'rxjs/operators';
import { API_CONFIG, ApiEndpointConfig } from './api.config';
import { LoggingService } from './logging.service';
import { CacheService, CacheStorageType } from './cache.service';

type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';

interface CachedResponse<T> {
  response: T;
  timestamp: number;
}

@Injectable({
  providedIn: 'root',
})
export class ApiService {
  private http = inject(HttpClient);
  private loggingService = inject(LoggingService);
  private cacheService = inject(CacheService);

  private pendingRequests = signal<Set<string>>(new Set());
  private abortController = signal(new AbortController());

  isLoading = computed(() => this.pendingRequests().size > 0);

  get<T>(endpointKey: string): Observable<T> {
    return this.fetchData<T>(endpointKey, 'GET');
  }

  post<T>(endpointKey: string, data: any): Observable<T> {
    return this.fetchData<T>(endpointKey, 'POST', data);
  }

  put<T>(endpointKey: string, id: number, data: any): Observable<T> {
    return this.fetchData<T>(endpointKey, 'PUT', data, id);
  }

  patch<T>(endpointKey: string, id: number, data: any): Observable<T> {
    return this.fetchData<T>(endpointKey, 'PATCH', data, id);
  }

  delete<T>(endpointKey: string, id: number): Observable<T> {
    return this.fetchData<T>(endpointKey, 'DELETE', undefined, id);
  }

  private fetchData<T>(
    endpointKey: string,
    method: HttpMethod,
    data?: any,
    id?: number
  ): Observable<T> {
    const config = API_CONFIG.endpoints[endpointKey];
    if (!config) {
      return throwError(() => new Error(`No configuration found for endpoint: ${endpointKey}`));
    }

    const url = typeof config.url === 'function' ? config.url(id) : config.url;
    const cacheKey = this.generateCacheKey(config, endpointKey, method, id);

    // Check cache based on method
    if (config.shouldCache) {
      const cachedData = this.checkCache<T>(cacheKey, method, data, config.cacheStorageType || 'memory');
      if (cachedData) {
        return of(cachedData);
      }
    }

    const options = this.getRequestOptions(config);

    let request: Observable<T>;
    switch (method) {
      case 'GET':
        request = this.http.get<T>(url, options);
        break;
      case 'POST':
        request = this.http.post<T>(url, data, options);
        break;
      case 'PUT':
        request = this.http.put<T>(url, data, options);
        break;
      case 'PATCH':
        request = this.http.patch<T>(url, data, options);
        break;
      case 'DELETE':
        request = this.http.delete<T>(url, options);
        break;
      default:
        return throwError(() => new Error(`Unsupported HTTP method: ${method}`));
    }

    this.pendingRequests.update(set => {
      set.add(cacheKey);
      return new Set(set);
    });

    return request.pipe(
      timeout(config.requestTimeout || 30000),
      this.applyRetryLogic(config),
      tap(response => {
        if (config.shouldCache) {
          this.setCacheData(cacheKey, method, data, response, {
            expiration: config.cacheTimeout,
            storageType: config.cacheStorageType || 'memory'
          });
        }
      }),
      catchError(this.handleError.bind(this)),
      tap(() => {
        this.pendingRequests.update(set => {
          set.delete(cacheKey);
          return new Set(set);
        });
      })
    );
  }

  private checkCache<T>(cacheKey: string, method: HttpMethod, data: any, storageType: CacheStorageType): T | null {
    const cachedItem = this.cacheService.get<any>(cacheKey, storageType);
    if (!cachedItem) return null;

    if (method === 'GET') {
      return cachedItem as T;
    } else if (method === 'POST') {
      const requestHash = this.hashCode(JSON.stringify(data));
      const cachedResponse = cachedItem[requestHash] as CachedResponse<T> | undefined;
      if (cachedResponse && (!cachedResponse.timestamp || Date.now() - cachedResponse.timestamp < (API_CONFIG.endpoints[cacheKey]?.cacheTimeout || 300000))) {
        return cachedResponse.response;
      }
    }

    return null;
  }

  private setCacheData<T>(cacheKey: string, method: HttpMethod, requestData: any, response: T, options: { expiration?: number; storageType: CacheStorageType }): void {
    if (method === 'GET') {
      this.cacheService.set(cacheKey, response, options);
    } else if (method === 'POST') {
      const cachedItem = this.cacheService.get<{ [key: string]: CachedResponse<T> }>(cacheKey, options.storageType) || {};
      const requestHash = this.hashCode(JSON.stringify(requestData));
      cachedItem[requestHash] = {
        response,
        timestamp: Date.now()
      };
      this.cacheService.set(cacheKey, cachedItem, options);
    }
  }

  private generateCacheKey(
    config: ApiEndpointConfig,
    endpointKey: string,
    method: HttpMethod,
    id?: number
  ): string {
    if (typeof config.cacheKey === 'function') {
      return config.cacheKey({ endpointKey, method, id });
    } else if (typeof config.cacheKey === 'string') {
      return config.cacheKey;
    } else {
      return `${method}:${endpointKey}:${id || ''}`;
    }
  }

  private hashCode(s: string): number {
    let hash = 0;
    for (let i = 0; i < s.length; i++) {
      const chr = s.charCodeAt(i);
      hash = ((hash << 5) - hash) + chr;
      hash |= 0; // Convert to 32bit integer
    }
    return hash;
  }

  private getRequestOptions(config: ApiEndpointConfig): any {
    const options: any = {
      headers: new HttpHeaders(config.headers),
      params: config.params,
      withCredentials: config.withCredentials,
    };

    options.signal = this.abortController().signal;

    return options;
  }

  private applyRetryLogic(config: ApiEndpointConfig) {
    if (config.retryEnabled && config.maxRetries > 0) {
      return retry({
        count: config.maxRetries,
        delay: (error, retryCount) => {
          if (error instanceof HttpErrorResponse && error.status >= 500) {
            return timer(Math.pow(2, retryCount) * 1000);
          }
          return throwError(() => error);
        },
      });
    }
    return (source: Observable<any>) => source;
  }

  private handleError(error: HttpErrorResponse) {
    this.loggingService.error('API error', error);
    return throwError(() => error);
  }

  cancelRequests() {
    this.abortController.update(controller => {
      controller.abort();
      return new AbortController();
    });
  }
}
