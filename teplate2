import { ChangeDetectionStrategy, Component, Input, signal, computed } from '@angular/core';
import { CommonModule } from '@angular/common';

interface Field {
  label: string;
  value: any;
  type: 'field';
  visible: boolean;
  side: 'left' | 'right';
  fieldType: string;
}

interface Section {
  label: string;
  type: 'section';
  visible: boolean;
  expand: boolean;
  fields: (Field | Section)[];
}

interface ProcessedSection extends Section {
  leftFields: Field[];
  rightFields: Field[];
  subsections: Section[];
}

@Component({
  selector: 'app-read-view',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="read-view" role="region" aria-label="Read View">
      <ng-container *ngFor="let section of processedSections(); trackBy: trackByLabel">
        <ng-container 
          *ngTemplateOutlet="sectionTemplate; 
          context: { $implicit: section, level: 0 }">
        </ng-container>
      </ng-container>
    </div>

    <ng-template #sectionTemplate let-section let-level="level">
      <section 
        class="section" 
        [class.section-collapsed]="!expandedSections()[section.label]"
        [class.section-nested]="level > 0"
        [attr.aria-expanded]="expandedSections()[section.label]">
        
        <!-- Section Header -->
        <div class="section-header" (click)="toggleSection(section.label)">
          <h2 [class.nested-header]="level > 0">{{ section.label }}</h2>
          <button 
            class="expand-button"
            [attr.aria-label]="(expandedSections()[section.label] ? 'Collapse ' : 'Expand ') + section.label"
          >
            <span class="expand-icon" [class.expanded]="expandedSections()[section.label]">
              â–¼
            </span>
          </button>
        </div>

        <!-- Section Content -->
        <div class="section-content" [class.hidden]="!expandedSections()[section.label]">
          <!-- Fields Grid -->
          <div class="fields-grid" *ngIf="section.leftFields.length || section.rightFields.length">
            <!-- Left Column -->
            <div class="fields-column">
              <ng-container *ngFor="let field of section.leftFields; trackBy: trackByLabel">
                <ng-container 
                  *ngTemplateOutlet="fieldTemplate; 
                  context: { $implicit: field }">
                </ng-container>
              </ng-container>
            </div>

            <!-- Right Column -->
            <div class="fields-column">
              <ng-container *ngFor="let field of section.rightFields; trackBy: trackByLabel">
                <ng-container 
                  *ngTemplateOutlet="fieldTemplate; 
                  context: { $implicit: field }">
                </ng-container>
              </ng-container>
            </div>
          </div>

          <!-- Nested Sections -->
          <div class="nested-sections" *ngIf="section.subsections.length">
            <ng-container *ngFor="let subsection of section.subsections; trackBy: trackByLabel">
              <ng-container 
                *ngTemplateOutlet="sectionTemplate; 
                context: { $implicit: subsection, level: level + 1 }">
              </ng-container>
            </ng-container>
          </div>
        </div>
      </section>
    </ng-template>

    <ng-template #fieldTemplate let-field>
      <div class="field" role="group" [attr.aria-label]="field.label">
        <label class="field-label">{{ field.label }}</label>
        <div [ngSwitch]="field.fieldType" class="field-value">
          <ng-container *ngSwitchCase="'date'">
            {{ field.value | date }}
          </ng-container>
          <ng-container *ngSwitchCase="'boolean'">
            {{ field.value ? 'Yes' : 'No' }}
          </ng-container>
          <ng-container *ngSwitchCase="'currency'">
            {{ field.value | currency }}
          </ng-container>
          <ng-container *ngSwitchCase="'percentage'">
            {{ field.value | percent }}
          </ng-container>
          <ng-container *ngSwitchDefault>
            {{ field.value }}
          </ng-container>
        </div>
      </div>
    </ng-template>
  `,
  styles: [`
    :host {
      display: block;
      width: 100%;
    }

    .read-view {
      max-width: 1200px;
      margin: 0 auto;
      padding: 1rem;
    }

    .section {
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    }

    .section-nested {
      margin-left: 1.5rem;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      cursor: pointer;
      background: #f9fafb;
      border-radius: 0.5rem 0.5rem 0 0;
      transition: background-color 0.2s;
    }

    .section-header:hover {
      background: #f3f4f6;
    }

    .nested-header {
      font-size: 1.1rem;
      color: #4b5563;
    }

    .expand-button {
      padding: 0.5rem;
      border-radius: 9999px;
      border: none;
      background: transparent;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .expand-button:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    .expand-button:focus {
      outline: 2px solid #3b82f6;
      outline-offset: 2px;
    }

    .expand-icon {
      display: inline-block;
      color: #6b7280;
      transform: rotate(-90deg);
      transition: transform 0.2s;
    }

    .expand-icon.expanded {
      transform: rotate(0);
    }

    .section-content {
      padding: 1rem;
      border-top: 1px solid #e5e7eb;
    }

    .hidden {
      display: none;
    }

    .fields-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 2rem;
    }

    .fields-column {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .field-label {
      font-size: 0.875rem;
      font-weight: 500;
      color: #374151;
    }

    .field-value {
      font-size: 1rem;
      color: #111827;
    }

    .nested-sections {
      margin-top: 1rem;
    }

    @media (max-width: 768px) {
      .fields-grid {
        grid-template-columns: 1fr;
      }

      .section-nested {
        margin-left: 0.75rem;
      }
    }
  `],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ReadViewComponent {
  private sectionsSignal = signal<Section[]>([]);
  private expandedSectionsState = signal<Record<string, boolean>>({});

  @Input()
  set data(value: Section[]) {
    this.sectionsSignal.set(value);
    // Initialize expanded state
    const expandedState: Record<string, boolean> = {};
    this.initializeExpandedState(value, expandedState);
    this.expandedSectionsState.set(expandedState);
  }

  protected processedSections = computed(() => {
    return this.sectionsSignal()
      .filter(section => section.visible)
      .map(section => this.processSection(section));
  });

  protected expandedSections = computed(() => this.expandedSectionsState());

  private initializeExpandedState(sections: Section[], state: Record<string, boolean>) {
    sections.forEach(section => {
      state[section.label] = section.expand;
      const subsections = section.fields.filter((f): f is Section => f.type === 'section');
      this.initializeExpandedState(subsections, state);
    });
  }

  private processSection(section: Section): ProcessedSection {
    const fields = section.fields.filter((f): f is Field => f.type === 'field' && f.visible);
    const subsections = section.fields
      .filter((f): f is Section => f.type === 'section' && f.visible)
      .map(subsection => this.processSection(subsection));

    return {
      ...section,
      leftFields: fields.filter(f => f.side === 'left'),
      rightFields: fields.filter(f => f.side === 'right'),
      subsections
    };
  }

  protected toggleSection(label: string): void {
    this.expandedSectionsState.update(state => ({
      ...state,
      [label]: !state[label]
    }));
  }

  protected trackByLabel(index: number, item: Section | Field): string {
    return item.label;
  }
}
