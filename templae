// Fixing the cdkDropList connection issue

// 1. Update the getConnectedDropListIds method to ensure it only returns existing IDs

getConnectedDropListIds(): string[] {
  // Start with an array containing just the main container ID
  const ids = ['main-form-container'];
  
  // Use ViewChildren or a different approach to ensure all drop lists are properly registered
  // before attempting to connect them
  
  // Only add IDs for sections that are already in the DOM
  this.formData.forEach(section => {
    if (section.instanceId) {
      ids.push('drop-' + section.instanceId);
      
      // Add IDs for all subsections
      if (section.subSections && section.subSections.length > 0) {
        section.subSections.forEach((subsection: any) => {
          if (subsection.instanceId) {
            ids.push('drop-' + subsection.instanceId);
          }
        });
      }
    }
  });
  
  return ids;
}

// 2. Update the template to ensure drop lists have consistent IDs
/*
In your template, make sure all cdkDropList elements have proper IDs:

<div id="section-catalog" cdkDropList [cdkDropListData]="catalogData.sections" 
     cdkDropListId="section-catalog"
     [cdkDropListConnectedTo]="getConnectedDropListIds()">
  <!-- ... -->
</div>

<div id="field-catalog" cdkDropList [cdkDropListData]="catalogData.fields"
     cdkDropListId="field-catalog"
     [cdkDropListConnectedTo]="getConnectedDropListIds()">
  <!-- ... -->
</div>

<div class="form-container" cdkDropList [cdkDropListData]="formData" 
     cdkDropListId="main-form-container"
     (cdkDropListDropped)="dropIntoForm($event)">
  <!-- ... -->
</div>
*/

// 3. Add a method to reinitialize connections after DOM changes

// When adding new sections/fields, we need to refresh the connections
reinitializeDropConnections(): void {
  // Using setTimeout to ensure the DOM has updated
  setTimeout(() => {
    // Force Angular to detect changes and update the connections
    this.getConnectedDropListIds();
    
    // If you're using ChangeDetectorRef, you can also call:
    // this.cdr.detectChanges();
  }, 0);
}

// 4. Call reinitializeDropConnections whenever you add a new section or field
// For example, in dropIntoForm, dropIntoSection, and dropIntoSubsection methods:

dropIntoForm(event: CdkDragDrop<any[]>): void {
  // Existing implementation...
  
  if (event.previousContainer !== event.container) {
    // Dropping a catalog item into the form
    const dragData = event.item.data;
    
    if (dragData.type === 'section') {
      const catalogSection = this.catalogData.sections.find(s => s.id === dragData.id);
      if (catalogSection) {
        const instanceId = "instance_" + this.instanceCounter++;
        
        const sectionData = {
          instanceId: instanceId,
          referenceId: dragData.id,
          type: "section",
          name: catalogSection.name,
          label: catalogSection.label || catalogSection.name,
          fields: [],
          subSections: [],
          overrideProperties: {}
        };
        
        this.formData.push(sectionData);
        
        // Reinitialize drop connections after adding a new section
        this.reinitializeDropConnections();
      }
    }
  }
}

// Similarly, update dropIntoSection and dropIntoSubsection

// 5. Add logging to help diagnose connection issues
ngAfterViewInit() {
  // Log the available IDs for drop lists
  console.log('Connected drop list IDs:', this.getConnectedDropListIds());
  
  // Re-initialize connections after view init
  this.reinitializeDropConnections();
}


-------------------------------------------------------------------------------------------------

// Fixed saveProperties method with type safety improvements
saveProperties(): void {
  if (!this.currentItem) return;
  
  const { name, label, required, visible, editable } = this.currentItem;
  // Only extract type if it's a field
  const type = this.currentItemType === 'field' || this.currentItemType === 'catalog-field' 
    ? this.currentItem.type 
    : undefined;
  
  if (this.currentItemType === 'catalog-section' || this.currentItemType === 'catalog-field') {
    // Updating a catalog item
    const targetArray = this.currentItemType === 'catalog-section' 
      ? this.catalogData.sections 
      : this.catalogData.fields;
    
    const index = targetArray.findIndex(item => item.id === this.currentItem.id);
    if (index !== -1) {
      // Create a copy of the existing item
      const updatedItem = { ...targetArray[index] };
      
      // Update common properties
      updatedItem.name = name;
      updatedItem.label = label;
      updatedItem.required = required;
      updatedItem.visible = visible;
      updatedItem.editable = editable;
      
      // Only update type for fields
      if (this.currentItemType === 'catalog-field' && type !== undefined) {
        updatedItem.type = type;
      }
      
      // Update the array item
      targetArray[index] = updatedItem;
    }
  } else {
    // Updating a form instance
    const itemId = this.currentItem.instanceId;
    const referenceId = this.currentItem.referenceId;
    
    // Find the item to update
    const updateItem = (items: any[]): boolean => {
      for (let i = 0; i < items.length; i++) {
        if (items[i].instanceId === itemId) {
          // Get the catalog item
          const catalogItem = this.currentItemType === 'section'
            ? this.catalogData.sections.find(s => s.id === referenceId)
            : this.catalogData.fields.find(f => f.id === referenceId);
          
          // Only create overrides if different from catalog
          if (catalogItem) {
            // Create a shallow copy of existing overrides or initialize an empty object
            const overrides: any = { ...(items[i].overrideProperties || {}) };
            
            // Compare and update override properties
            if (name !== catalogItem.name) overrides.name = name;
            else delete overrides.name;
            
            if (label !== catalogItem.label) overrides.label = label;
            else delete overrides.label;
            
            // Only handle type for field items
            if (this.currentItemType === 'field') {
              const catalogFieldType = (catalogItem as any).type;
              if (type !== undefined && type !== catalogFieldType) {
                overrides.type = type;
              } else {
                delete overrides.type;
              }
            }
            
            if (required !== catalogItem.required) overrides.required = required;
            else delete overrides.required;
            
            if (visible !== catalogItem.visible) overrides.visible = visible;
            else delete overrides.visible;
            
            if (editable !== catalogItem.editable) overrides.editable = editable;
            else delete overrides.editable;
            
            // Create a new item object with updated properties
            const updatedItem = { ...items[i] };
            updatedItem.name = name;
            updatedItem.label = label;
            updatedItem.required = required;
            updatedItem.visible = visible;
            updatedItem.editable = editable;
            updatedItem.overrideProperties = overrides;
            
            // Only update type for fields
            if (this.currentItemType === 'field' && type !== undefined) {
              updatedItem.type = type;
            }
            
            // Update the item in the array
            items[i] = updatedItem;
            
            return true;
          }
          
          return false;
        }
        
        // Check in fields
        if (items[i].fields && items[i].fields.length > 0) {
          const found = updateItem(items[i].fields);
          if (found) return true;
        }
        
        // Check in subsections
        if (items[i].subSections && items[i].subSections.length > 0) {
          const found = updateItem(items[i].subSections);
          if (found) return true;
        }
      }
      
      return false;
    };
    
    updateItem(this.formData);
  }
  
  this.closePropertiesPanel();
}

// Fixed clearOverrides method with type safety improvements
clearOverrides(): void {
  if (!this.currentOverrideItem) return;
  
  const item = this.currentOverrideItem;
  
  // Clear all overrides
  item.overrideProperties = {};
  
  // Reset to catalog values if this is an instance (not a catalog item)
  if (item.instanceId) {
    const catalogItem = this.currentOverrideType === 'section'
      ? this.catalogData.sections.find(s => s.id === item.referenceId)
      : this.catalogData.fields.find(f => f.id === item.referenceId);
    
    if (catalogItem) {
      // Update common properties
      item.name = catalogItem.name;
      item.label = catalogItem.label;
      
      // Only update type for field items
      if (this.currentOverrideType === 'field' && 'type' in catalogItem) {
        item.type = catalogItem.type;
      }
    }
  }
  
  this.closeOverridePanel();
}






////////////////////////////////////////

// Fix 1: The saveProperties method has errors with catalogItem.type and targetArray[index]
// Fix 2: Type safety issues in the overridePanel methods

// Updated saveProperties method:
saveProperties(): void {
  if (!this.currentItem) return;
  
  const { name, label, type, required, visible, editable } = this.currentItem;
  
  if (this.currentItemType === 'catalog-section' || this.currentItemType === 'catalog-field') {
    // Updating a catalog item
    const targetArray = this.currentItemType === 'catalog-section' 
      ? this.catalogData.sections 
      : this.catalogData.fields;
    
    const index = targetArray.findIndex(item => item.id === this.currentItem.id);
    if (index !== -1) {
      // Fix: Use spread operator properly and conditionally include type only for fields
      if (this.currentItemType === 'catalog-field') {
        targetArray[index] = { ...targetArray[index], name, label, type, required, visible, editable };
      } else {
        targetArray[index] = { ...targetArray[index], name, label, required, visible, editable };
      }
    }
  } else {
    // Updating a form instance
    const itemId = this.currentItem.instanceId;
    const referenceId = this.currentItem.referenceId;
    
    // Find the item to update
    const updateItem = (items: any[]): boolean => {
      for (let i = 0; i < items.length; i++) {
        if (items[i].instanceId === itemId) {
          // Get the catalog item
          const catalogItem = this.currentItemType === 'section'
            ? this.catalogData.sections.find(s => s.id === referenceId)
            : this.catalogData.fields.find(f => f.id === referenceId);
          
          // Only create overrides if different from catalog
          if (catalogItem) {
            const overrides: any = { ...items[i].overrideProperties || {} };
            
            if (name !== catalogItem.name) overrides.name = name;
            else delete overrides.name;
            
            if (label !== catalogItem.label) overrides.label = label;
            else delete overrides.label;
            
            // Fix: Only compare type for fields
            if (this.currentItemType === 'field' && type && type !== (catalogItem as any).type) {
              overrides.type = type;
            } else if (this.currentItemType === 'field') {
              delete overrides.type;
            }
            
            if (required !== catalogItem.required) overrides.required = required;
            else delete overrides.required;
            
            if (visible !== catalogItem.visible) overrides.visible = visible;
            else delete overrides.visible;
            
            if (editable !== catalogItem.editable) overrides.editable = editable;
            else delete overrides.editable;
            
            // Update the item with spread operator to avoid mutation issues
            items[i] = { 
              ...items[i], 
              name, 
              label, 
              required, 
              visible, 
              editable,
              // Only include type for fields
              ...(this.currentItemType === 'field' ? { type: type || items[i].type } : {}),
              overrideProperties: overrides 
            };
            
            return true;
          }
          
          return false;
        }
        
        // Check in fields
        if (items[i].fields && items[i].fields.length > 0) {
          const found = updateItem(items[i].fields);
          if (found) return true;
        }
        
        // Check in subsections
        if (items[i].subSections && items[i].subSections.length > 0) {
          const found = updateItem(items[i].subSections);
          if (found) return true;
        }
      }
      
      return false;
    };
    
    updateItem(this.formData);
  }
  
  this.closePropertiesPanel();
}

// Updated openInstanceOverridePanel method:
openInstanceOverridePanel(item: any, type: string): void {
  this.currentOverrideItem = item;
  this.currentOverrideType = type;
  
  // Find the catalog item
  const catalogItem = type === 'section'
    ? this.catalogData.sections.find(s => s.id === item.referenceId)
    : this.catalogData.fields.find(f => f.id === item.referenceId);
  
  if (catalogItem) {
    // Initialize override values with existing overrides or catalog values
    this.overrideValues = {
      name: item.overrideProperties?.name || catalogItem.name,
      label: item.overrideProperties?.label || catalogItem.label,
      // Fix: Only include type for fields
      ...(type === 'field' ? {
        type: item.overrideProperties?.type || (catalogItem as any).type
      } : {}),
      required: item.overrideProperties?.required !== undefined 
               ? item.overrideProperties.required 
               : catalogItem.required,
      visible: item.overrideProperties?.visible !== undefined 
              ? item.overrideProperties.visible 
              : catalogItem.visible,
      editable: item.overrideProperties?.editable !== undefined 
               ? item.overrideProperties.editable 
               : catalogItem.editable
    };
    
    // Load custom properties
    this.customOverrideProperties = [];
    Object.entries(catalogItem).forEach(([key, value]) => {
      if (!['id', 'name', 'label', 'type', 'required', 'visible', 'editable', 'description'].includes(key)) {
        const overrideValue = item.overrideProperties ? item.overrideProperties[key] : undefined;
        this.customOverrideProperties.push({ 
          key, 
          value: overrideValue !== undefined ? overrideValue : value 
        });
      }
    });
  }
  
  this.showOverridePanel = true;
}

// Updated saveOverrides method:
saveOverrides(): void {
  if (!this.currentOverrideItem) return;
  
  const item = this.currentOverrideItem;
  
  if (!item.overrideProperties) {
    item.overrideProperties = {};
  }
  
  // If it's a catalog item being used as a template
  if (!item.instanceId) {
    // We don't modify catalog items directly, just close the panel
    this.closeOverridePanel();
    return;
  }
  
  // Find the catalog item
  const catalogItem = this.currentOverrideType === 'section'
    ? this.catalogData.sections.find(s => s.id === item.referenceId)
    : this.catalogData.fields.find(f => f.id === item.referenceId);
  
  if (catalogItem) {
    // Compare with catalog and add overrides only if different
    const { name, label, required, visible, editable } = this.overrideValues;
    const type = this.currentOverrideType === 'field' ? this.overrideValues.type : undefined;
    
    if (name !== catalogItem.name) item.overrideProperties.name = name;
    else delete item.overrideProperties.name;
    
    if (label !== catalogItem.label) item.overrideProperties.label = label;
    else delete item.overrideProperties.label;
    
    // Fix: Only check type for fields
    if (this.currentOverrideType === 'field' && type && type !== (catalogItem as any).type) {
      item.overrideProperties.type = type;
    } else if (this.currentOverrideType === 'field') {
      delete item.overrideProperties.type;
    }
    
    if (required !== catalogItem.required) item.overrideProperties.required = required;
    else delete item.overrideProperties.required;
    
    if (visible !== catalogItem.visible) item.overrideProperties.visible = visible;
    else delete item.overrideProperties.visible;
    
    if (editable !== catalogItem.editable) item.overrideProperties.editable = editable;
    else delete item.overrideProperties.editable;
    
    // Process custom properties
    this.customOverrideProperties.forEach(prop => {
      if (JSON.stringify(prop.value) !== JSON.stringify(catalogItem[prop.key])) {
        item.overrideProperties[prop.key] = prop.value;
      } else {
        delete item.overrideProperties[prop.key];
      }
    });
    
    // Update the display properties
    item.name = item.overrideProperties.name || catalogItem.name;
    item.label = item.overrideProperties.label || catalogItem.label;
    
    // Fix: Only update type for fields
    if (this.currentOverrideType === 'field') {
      item.type = item.overrideProperties.type || (catalogItem as any).type;
    }
  }
  
  this.closeOverridePanel();
}

----------
import { Component, OnInit, ViewChild, ElementRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { CdkDragDrop, moveItemInArray, transferArrayItem, CdkDrag, CdkDropList, DragDropModule } from '@angular/cdk/drag-drop';

@Component({
  selector: 'app-form-builder',
  standalone: true,
  imports: [CommonModule, FormsModule, DragDropModule],
  styles: [`
    .container {
      display: flex;
      gap: 20px;
    }
    .catalog-panel {
      width: 300px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .catalog {
      background: white;
      border-radius: 5px;
      padding: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .catalog-header {
      font-weight: bold;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
    }
    .add-new {
      cursor: pointer;
      color: #4CAF50;
    }
    .section-catalog-item, .field-catalog-item {
      padding: 8px 12px;
      margin-bottom: 8px;
      cursor: move;
      border-radius: 3px;
      position: relative;
    }
    .section-catalog-item {
      background: #e3f2fd;
      border: 1px solid #bbdefb;
    }
    .field-catalog-item {
      background: #e8f5e9;
      border: 1px solid #c8e6c9;
    }
    .catalog-item-id {
      font-size: 0.7em;
      color: #666;
      display: block;
      margin-top: 3px;
    }
    .form-container {
      flex: 1;
      background: white;
      border-radius: 5px;
      padding: 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      min-height: 500px;
    }
    .section {
      background: #f5f5f5;
      border-radius: 5px;
      padding: 10px;
      margin-bottom: 10px;
    }
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-weight: bold;
    }
    .section-title {
      display: flex;
      flex-direction: column;
    }
    .section-id {
      font-size: 0.7em;
      color: #666;
      font-weight: normal;
    }
    .nested-section {
      background: #eaf5ff;
      border-radius: 5px;
      padding: 10px;
      margin: 10px 0 10px 20px;
      border: 1px solid #d0e3ff;
    }
    .section-drop-area, .nested-section-drop-area {
      min-height: 50px;
      border: 1px dashed #ccc;
      border-radius: 3px;
      margin-top: 10px;
      padding: 10px;
    }
    .field-item {
      background: #e8f5e9;
      border: 1px solid #c8e6c9;
      border-radius: 3px;
      padding: 8px;
      margin: 5px 0;
      position: relative;
    }
    .field-id {
      font-size: 0.7em;
      color: #666;
      display: block;
      margin-top: 3px;
    }
    .cdk-drag-placeholder {
      opacity: 0.3;
    }
    .cdk-drag-animating {
      transition: transform 250ms;
    }
    .cdk-drop-list-dragging .cdk-drag {
      transition: transform 250ms;
    }
    .empty-message {
      color: #757575;
      font-style: italic;
      padding: 10px;
      text-align: center;
    }
    .field-type {
      font-size: 0.8em;
      color: #757575;
      margin-left: 5px;
    }
    .item-actions {
      float: right;
    }
    .edit-item, .remove-item, .override-item {
      cursor: pointer;
      margin-left: 5px;
    }
    .edit-item {
      color: #2196F3;
    }
    .remove-item {
      color: #F44336;
    }
    .override-item {
      color: #FF9800;
    }
    .properties-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: white;
      border-radius: 5px;
      padding: 15px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      width: 350px;
      z-index: 1000;
      max-height: 80vh;
      overflow-y: auto;
    }
    .properties-header {
      font-weight: bold;
      margin-bottom: 15px;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
      position: relative;
    }
    .close-panel {
      position: absolute;
      right: 0;
      top: 0;
      cursor: pointer;
    }
    .property-field {
      margin-bottom: 10px;
    }
    .property-field label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .property-field input, .property-field select, .property-field textarea {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 3px;
    }
    .property-field input[type="checkbox"] {
      width: auto;
    }
    .json-output {
      margin-top: 20px;
      background: #272822;
      color: #f8f8f2;
      padding: 15px;
      border-radius: 5px;
      max-height: 400px;
      overflow: auto;
      white-space: pre-wrap;
      font-family: monospace;
    }
    .buttons {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 3px;
      cursor: pointer;
    }
    button:hover {
      background: #43a047;
    }
    .btn-secondary {
      background: #2196F3;
    }
    .btn-secondary:hover {
      background: #1976D2;
    }
    .btn-warning {
      background: #FF9800;
    }
    .btn-warning:hover {
      background: #F57C00;
    }
    .btn-danger {
      background: #F44336;
    }
    .btn-danger:hover {
      background: #D32F2F;
    }
    .id-display {
      font-size: 0.8em;
      color: #888;
      margin-bottom: 10px;
      border: 1px solid #eee;
      padding: 5px;
      background: #f9f9f9;
    }
    .custom-property-row {
      display: flex;
      margin-bottom: 5px;
    }
    .custom-property-row input {
      flex: 1;
      margin-right: 5px;
    }
    .remove-prop {
      cursor: pointer;
      color: #F44336;
      font-weight: bold;
    }
    .add-property-btn {
      margin-top: 5px;
      background: #2196F3;
    }
    .tabs {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin-bottom: 15px;
    }
    .tab {
      padding: 8px 15px;
      cursor: pointer;
      border: 1px solid transparent;
      border-bottom: none;
      margin-right: 5px;
    }
    .tab.active {
      background: #fff;
      border-color: #ddd;
      border-radius: 5px 5px 0 0;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    .has-overrides {
      border-left: 4px solid #FF9800;
    }
  `],
  template: `
    <h1>Angular Form Builder</h1>
    <p>Drag and drop sections and fields to build your form. Each section and field keeps its original reference ID.</p>

    <div class="container">
      <!-- Catalog Panel -->
      <div class="catalog-panel">
        <div class="catalog">
          <div class="catalog-header">Sections <span class="add-new" (click)="addNewSection()">+</span></div>
          <div id="section-catalog" cdkDropList [cdkDropListData]="catalogData.sections" 
               [cdkDropListConnectedTo]="getConnectedDropListIds()">
            <div class="section-catalog-item" *ngFor="let section of catalogData.sections" cdkDrag 
                 [cdkDragData]="{ id: section.id, type: 'section' }">
              <div class="catalog-item-details">
                {{ section.label || section.name }}
                <span class="catalog-item-id">ID: {{ section.id }}</span>
              </div>
              <div class="item-actions">
                <span class="override-item" (click)="openOverridePanel(section, 'section')">🔄</span>
                <span class="edit-item" (click)="openPropertiesPanel(section, 'catalog-section')">✏️</span>
                <span class="remove-item" (click)="removeCatalogItem(section.id, 'section')">🗑️</span>
              </div>
            </div>
          </div>
        </div>
        
        <div class="catalog">
          <div class="catalog-header">Fields <span class="add-new" (click)="addNewField()">+</span></div>
          <div id="field-catalog" cdkDropList [cdkDropListData]="catalogData.fields"
               [cdkDropListConnectedTo]="getConnectedDropListIds()">
            <div class="field-catalog-item" *ngFor="let field of catalogData.fields" cdkDrag
                 [cdkDragData]="{ id: field.id, type: 'field' }">
              <div class="catalog-item-details">
                {{ field.label || field.name }} <span class="field-type">({{ field.type }})</span>
                <span class="catalog-item-id">ID: {{ field.id }}</span>
              </div>
              <div class="item-actions">
                <span class="override-item" (click)="openOverridePanel(field, 'field')">🔄</span>
                <span class="edit-item" (click)="openPropertiesPanel(field, 'catalog-field')">✏️</span>
                <span class="remove-item" (click)="removeCatalogItem(field.id, 'field')">🗑️</span>
              </div>
            </div>
          </div>
        </div>
        
        <div>
          <h3>Import/Export Catalogs</h3>
          <div>
            <input type="file" #importFile accept=".json" (change)="importCatalogFile($event)">
          </div>
          <button class="btn-secondary" (click)="exportCatalog()">Export Catalogs</button>
          <p>Or edit JSON directly:</p>
          <textarea [(ngModel)]="jsonEditor" rows="10" style="width: 100%"></textarea>
          <button class="btn-warning" (click)="applyJson()">Apply JSON</button>
        </div>
      </div>
      
      <!-- Form Container -->
      <div class="form-container" cdkDropList [cdkDropListData]="formData" 
           cdkDropListId="main-form-container"
           (cdkDropListDropped)="dropIntoForm($event)">
        <div class="empty-message" *ngIf="formData.length === 0">
          Drag sections from the catalog to begin building your form.
        </div>

        <div *ngFor="let section of formData; let i = index">
          <div class="section" [id]="section.instanceId" [attr.data-id]="section.instanceId" 
               [attr.data-reference-id]="section.referenceId"
               [class.has-overrides]="hasOverrides(section)">
            <div class="section-header">
              <div class="section-title">
                {{ section.label }}
                <span class="section-id">Ref ID: {{ section.referenceId }} | Instance ID: {{ section.instanceId }}</span>
              </div>
              <div>
                <span class="override-item" (click)="openInstanceOverridePanel(section, 'section')">🔄</span>
                <span class="edit-item" (click)="openPropertiesPanel(section, 'section')">✏️</span>
                <span class="remove-item" (click)="removeFormItem(i)">🗑️</span>
              </div>
            </div>
            <div class="section-drop-area" cdkDropList 
                 [cdkDropListData]="section" 
                 [id]="'drop-' + section.instanceId"
                 (cdkDropListDropped)="dropIntoSection($event, section)">
              <div class="empty-message" *ngIf="section.fields.length === 0 && section.subSections.length === 0">
                Drop fields or sections here
              </div>
              
              <!-- Fields in this section -->
              <div *ngFor="let field of section.fields; let j = index" class="field-item" 
                   [attr.data-id]="field.instanceId" [attr.data-reference-id]="field.referenceId"
                   [class.has-overrides]="hasOverrides(field)">
                {{ field.label }} <span class="field-type">({{ field.type }})</span>
                <span class="field-id">Ref ID: {{ field.referenceId }} | Instance ID: {{ field.instanceId }}</span>
                <div class="item-actions">
                  <span class="override-item" (click)="openInstanceOverridePanel(field, 'field')">🔄</span>
                  <span class="edit-item" (click)="openPropertiesPanel(field, 'field')">✏️</span>
                  <span class="remove-item" (click)="removeFieldFromSection(section, j)">🗑️</span>
                </div>
              </div>
              
              <!-- Nested sections -->
              <ng-container *ngFor="let subsection of section.subSections; let k = index">
                <div class="nested-section" [id]="subsection.instanceId" [attr.data-id]="subsection.instanceId" 
                     [attr.data-reference-id]="subsection.referenceId"
                     [class.has-overrides]="hasOverrides(subsection)">
                  <div class="section-header">
                    <div class="section-title">
                      {{ subsection.label }}
                      <span class="section-id">Ref ID: {{ subsection.referenceId }} | Instance ID: {{ subsection.instanceId }}</span>
                    </div>
                    <div>
                      <span class="override-item" (click)="openInstanceOverridePanel(subsection, 'section')">🔄</span>
                      <span class="edit-item" (click)="openPropertiesPanel(subsection, 'section')">✏️</span>
                      <span class="remove-item" (click)="removeSubsectionFromSection(section, k)">🗑️</span>
                    </div>
                  </div>
                  <div class="nested-section-drop-area" cdkDropList 
                       [cdkDropListData]="subsection" 
                       [id]="'drop-' + subsection.instanceId"
                       (cdkDropListDropped)="dropIntoSubsection($event, subsection)">
                    <div class="empty-message" *ngIf="subsection.fields.length === 0">
                      Drop fields here
                    </div>
                    
                    <!-- Fields in the subsection -->
                    <div *ngFor="let subfield of subsection.fields; let m = index" class="field-item" 
                         [attr.data-id]="subfield.instanceId" [attr.data-reference-id]="subfield.referenceId"
                         [class.has-overrides]="hasOverrides(subfield)">
                      {{ subfield.label }} <span class="field-type">({{ subfield.type }})</span>
                      <span class="field-id">Ref ID: {{ subfield.referenceId }} | Instance ID: {{ subfield.instanceId }}</span>
                      <div class="item-actions">
                        <span class="override-item" (click)="openInstanceOverridePanel(subfield, 'field')">🔄</span>
                        <span class="edit-item" (click)="openPropertiesPanel(subfield, 'field')">✏️</span>
                        <span class="remove-item" (click)="removeFieldFromSection(subsection, m)">🗑️</span>
                      </div>
                    </div>
                  </div>
                </div>
              </ng-container>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="buttons">
      <button (click)="generateJson()">Generate Form JSON</button>
      <button class="btn-danger" (click)="clearForm()">Clear Form</button>
      <button class="btn-secondary" (click)="exportAll()">Export Everything</button>
    </div>
    
    <div *ngIf="showJsonOutput">
      <h3>JSON Output</h3>
      <div class="json-output">{{ jsonOutput }}</div>
    </div>
    
    <!-- Properties Panel -->
    <div class="properties-panel" *ngIf="showPropertiesPanel">
      <div class="properties-header">
        Edit Properties <span class="close-panel" (click)="closePropertiesPanel()">×</span>
      </div>
      
      <div class="id-display" *ngIf="currentItemType !== 'catalog-section' && currentItemType !== 'catalog-field'">
        Reference ID: <span>{{ currentItem?.referenceId }}</span>
      </div>
      <div class="id-display">
        {{ currentItemType === 'catalog-section' || currentItemType === 'catalog-field' ? 'ID' : 'Instance ID' }}: 
        <span>{{ currentItemType === 'catalog-section' || currentItemType === 'catalog-field' ? currentItem?.id : currentItem?.instanceId }}</span>
      </div>
      
      <div class="property-field">
        <label for="prop-name">Name:</label>
        <input type="text" id="prop-name" [(ngModel)]="currentItem.name">
      </div>
      <div class="property-field">
        <label for="prop-label">Label:</label>
        <input type="text" id="prop-label" [(ngModel)]="currentItem.label">
      </div>
      <div class="property-field" *ngIf="currentItemType === 'field' || currentItemType === 'catalog-field'">
        <label for="prop-type">Type:</label>
        <select id="prop-type" [(ngModel)]="currentItem.type">
          <option value="text">Text</option>
          <option value="email">Email</option>
          <option value="number">Number</option>
          <option value="date">Date</option>
          <option value="select">Select</option>
          <option value="checkbox">Checkbox</option>
        </select>
      </div>
      <div class="property-field">
        <label for="prop-required">Required:</label>
        <input type="checkbox" id="prop-required" [(ngModel)]="currentItem.required">
      </div>
      <div class="property-field">
        <label for="prop-visible">Visible:</label>
        <input type="checkbox" id="prop-visible" [(ngModel)]="currentItem.visible">
      </div>
      <div class="property-field">
        <label for="prop-editable">Editable:</label>
        <input type="checkbox" id="prop-editable" [(ngModel)]="currentItem.editable">
      </div>
      
      <button (click)="saveProperties()">Save</button>
    </div>
    
    <!-- Override Panel -->
    <div class="properties-panel" *ngIf="showOverridePanel">
      <div class="properties-header">
        Override Properties <span class="close-panel" (click)="closeOverridePanel()">×</span>
      </div>
      
      <div class="id-display">
        Reference ID: <span>{{ currentOverrideItem?.referenceId || currentOverrideItem?.id }}</span>
      </div>
      
      <p style="color: #777; font-style: italic; margin-bottom: 15px;">
        Override only what needs to be different from the catalog definition. Leave unchanged to use catalog values.
      </p>
      
      <div class="property-field">
        <label for="override-name">Name:</label>
        <input type="text" id="override-name" [(ngModel)]="overrideValues.name">
      </div>
      <div class="property-field">
        <label for="override-label">Label:</label>
        <input type="text" id="override-label" [(ngModel)]="overrideValues.label">
      </div>
      <div class="property-field" *ngIf="currentOverrideType === 'field'">
        <label for="override-type">Type:</label>
        <select id="override-type" [(ngModel)]="overrideValues.type">
          <option value="text">Text</option>
          <option value="email">Email</option>
          <option value="number">Number</option>
          <option value="date">Date</option>
          <option value="select">Select</option>
          <option value="checkbox">Checkbox</option>
        </select>
      </div>
      <div class="property-field">
        <label for="override-required">Required:</label>
        <input type="checkbox" id="override-required" [(ngModel)]="overrideValues.required">
      </div>
      <div class="property-field">
        <label for="override-visible">Visible:</label>
        <input type="checkbox" id="override-visible" [(ngModel)]="overrideValues.visible">
      </div>
      <div class="property-field">
        <label for="override-editable">Editable:</label>
        <input type="checkbox" id="override-editable" [(ngModel)]="overrideValues.editable">
      </div>
      
      <div *ngIf="customOverrideProperties.length > 0">
        <h4>Custom Properties</h4>
        <div class="custom-property-row" *ngFor="let prop of customOverrideProperties; let i = index">
          <input type="text" [(ngModel)]="prop.key" placeholder="Property name" [disabled]="true">
          <input type="text" [(ngModel)]="prop.value" placeholder="Value">
          <span class="remove-prop" (click)="removeCustomOverride(i)">×</span>
        </div>
      </div>
      
      <div class="buttons">
        <button (click)="saveOverrides()">Save Overrides</button>
        <button class="btn-warning" (click)="clearOverrides()">Clear Overrides</button>
      </div>
    </div>
  `
})
export class FormBuilderComponent implements OnInit {
  @ViewChild('importFile') importFile!: ElementRef;

  // Data structures
  formData: any[] = [];
  catalogData = {
    sections: [
      {
        id: "SEC001",
        name: "Basic Info",
        label: "Basic Information",
        description: "Basic information about the entity",
        required: true,
        visible: true,
        editable: true
      },
      {
        id: "SEC002",
        name: "Contact Details",
        label: "Contact Information",
        description: "Contact information for the entity",
        required: false,
        visible: true,
        editable: true
      },
      {
        id: "SEC003",
        name: "Additional Info",
        label: "Additional Information",
        description: "Additional information about the entity",
        required: false,
        visible: true,
        editable: true
      }
    ],
    fields: [
      {
        id: "FLD001",
        name: "Full Name",
        label: "Full Name",
        type: "text",
        description: "Full name of the person",
        required: true,
        visible: true,
        editable: true,
        minLength: 2,
        maxLength: 100
      },
      {
        id: "FLD002",
        name: "Email",
        label: "Email Address",
        type: "email",
        description: "Email address for contact",
        required: true,
        visible: true,
        editable: true
      },
      {
        id: "FLD003",
        name: "Date of Birth",
        label: "Date of Birth",
        type: "date",
        description: "Date of birth",
        required: false,
        visible: true,
        editable: true
      },
      {
        id: "FLD004",
        name: "Status",
        label: "Current Status",
        type: "select",
        description: "Current status of the entity",
        required: true,
        visible: true,
        editable: true,
        options: ["Active", "Inactive", "Pending"]
      },
      {
        id: "FLD005",
        name: "ID",
        label: "Identification Number",
        type: "number",
        description: "Unique identification number",
        required: true,
        visible: true,
        editable: true,
        minValue: 1000,
        maxValue: 9999
      }
    ]
  };

  // Panel states and current items
  showPropertiesPanel = false;
  showOverridePanel = false;
  currentItem: any = null;
  currentItemType = '';
  currentOverrideItem: any = null;
  currentOverrideType = '';
  customOverrideProperties: { key: string, value: any }[] = [];
  overrideValues: any = {};

  // JSON import/export
  jsonEditor = '';
  jsonOutput = '';
  showJsonOutput = false;

  // Counters for IDs
  instanceCounter = 1;
  sectionCounter = 1;
  fieldCounter = 1;

  constructor() { }

  ngOnInit(): void {
    // Initialize counters based on the catalog data
    this.updateCounters();
    
    // Initialize the JSON editor with the catalog data
    this.jsonEditor = JSON.stringify(this.catalogData, null, 2);
  }

  // Helper method to get all connected drop list IDs
  getConnectedDropListIds(): string[] {
    const ids = ['main-form-container'];
    
    // Add IDs for all sections
    this.formData.forEach(section => {
      ids.push('drop-' + section.instanceId);
      
      // Add IDs for all subsections
      section.subSections?.forEach((subsection: any) => {
        ids.push('drop-' + subsection.instanceId);
      });
    });
    
    return ids;
  }

  // Drag and drop handlers
  dropIntoForm(event: CdkDragDrop<any[]>): void {
    if (event.previousContainer === event.container) {
      // Reordering within the form container
      moveItemInArray(event.container.data, event.previousIndex, event.currentIndex);
    } else {
      // Dropping a catalog item into the form
      const dragData = event.item.data;
      
      if (dragData.type === 'section') {
        const catalogSection = this.catalogData.sections.find(s => s.id === dragData.id);
        if (catalogSection) {
          const instanceId = "instance_" + this.instanceCounter++;
          
          const sectionData = {
            instanceId: instanceId,
            referenceId: dragData.id,
            type: "section",
            name: catalogSection.name,
            label: catalogSection.label || catalogSection.name,
            fields: [],
            subSections: [],
            overrideProperties: {}
          };
          
          this.formData.push(sectionData);
        }
      }
    }
  }

  dropIntoSection(event: CdkDragDrop<any>, section: any): void {
    if (event.previousContainer !== event.container) {
      // Dropping from catalog into a section
      const dragData = event.item.data;
      
      if (dragData.type === 'section') {
        // Add a subsection
        const catalogSection = this.catalogData.sections.find(s => s.id === dragData.id);
        if (catalogSection) {
          const instanceId = "instance_" + this.instanceCounter++;
          
          const subSectionData = {
            instanceId: instanceId,
            referenceId: dragData.id,
            type: "section",
            name: catalogSection.name,
            label: catalogSection.label || catalogSection.name,
            fields: [],
            subSections: [],
            overrideProperties: {}
          };
          
          if (!section.subSections) {
            section.subSections = [];
          }
          
          section.subSections.push(subSectionData);
        }
      } else if (dragData.type === 'field') {
        // Add a field
        const catalogField = this.catalogData.fields.find(f => f.id === dragData.id);
        if (catalogField) {
          const instanceId = "instance_" + this.instanceCounter++;
          
          const fieldData = {
            instanceId: instanceId,
            referenceId: dragData.id,
            type: catalogField.type,
            name: catalogField.name,
            label: catalogField.label || catalogField.name,
            overrideProperties: {}
          };
          
          if (!section.fields) {
            section.fields = [];
          }
          
          section.fields.push(fieldData);
        }
      }
    }
  }

  dropIntoSubsection(event: CdkDragDrop<any>, subsection: any): void {
    if (event.previousContainer !== event.container) {
      // Dropping from catalog into a subsection
      const dragData = event.item.data;
      
      if (dragData.type === 'field') {
        // Add a field to subsection
        const catalogField = this.catalogData.fields.find(f => f.id === dragData.id);
        if (catalogField) {
          const instanceId = "instance_" + this.instanceCounter++;
          
          const fieldData = {
            instanceId: instanceId,
            referenceId: dragData.id,
            type: catalogField.type,
            name: catalogField.name,
            label: catalogField.label || catalogField.name,
            overrideProperties: {}
          };
          
          if (!subsection.fields) {
            subsection.fields = [];
          }
          
          subsection.fields.push(fieldData);
        }
      }
    }
  }

  // Add new section to catalog
  addNewSection(): void {
    const sectionId = "SEC" + String(this.sectionCounter++).padStart(3, '0');
    
    const newSection = {
      id: sectionId,
      name: "New Section",
      label: "New Section",
      description: "",
      required: false,
      visible: true,
      editable: true
    };
    
    this.catalogData.sections.push(newSection);
    this.openPropertiesPanel(newSection, 'catalog-section');
  }

  // Add new field to catalog
  addNewField(): void {
    const fieldId = "FLD" + String(this.fieldCounter++).padStart(3, '0');
    
    const newField = {
      id: fieldId,
      name: "New Field",
      label: "New Field",
      type: "text",
      description: "",
      required: false,
      visible: true,
      editable: true
    };
    
    this.catalogData.fields.push(newField);
    this.openPropertiesPanel(newField, 'catalog-field');
  }

  // Remove item from catalog
  removeCatalogItem(id: string, type: string): void {
    if (type === 'section') {
      this.catalogData.sections = this.catalogData.sections.filter(s => s.id !== id);
    } else {
      this.catalogData.fields = this.catalogData.fields.filter(f => f.id !== id);
    }
  }

  // Remove item from form
  removeFormItem(index: number): void {
    this.formData.splice(index, 1);
  }

  // Remove field from section
  removeFieldFromSection(section: any, index: number): void {
    section.fields.splice(index, 1);
  }

  // Remove subsection from section
  removeSubsectionFromSection(section: any, index: number): void {
    section.subSections.splice(index, 1);
  }

  // Open properties panel
  openPropertiesPanel(item: any, itemType: string): void {
    this.currentItem = { ...item };
    this.currentItemType = itemType;
    this.showPropertiesPanel = true;
  }

  // Close properties panel
  closePropertiesPanel(): void {
    this.showPropertiesPanel = false;
    this.currentItem = null;
  }

  // Save properties
  saveProperties(): void {
    if (!this.currentItem) return;
    
    const { name, label, type, required, visible, editable } = this.currentItem;
    
    if (this.currentItemType === 'catalog-section' || this.currentItemType === 'catalog-field') {
      // Updating a catalog item
      const targetArray = this.currentItemType === 'catalog-section' 
        ? this.catalogData.sections 
        : this.catalogData.fields;
      
      const index = targetArray.findIndex(item => item.id === this.currentItem.id);
      if (index !== -1) {
        targetArray[index] = { ...targetArray[index], name, label, type, required, visible, editable };
      }
    } else {
      // Updating a form instance
      const itemId = this.currentItem.instanceId;
      const referenceId = this.currentItem.referenceId;
      
      // Find the item to update
      const updateItem = (items: any[]) => {
        for (let i = 0; i < items.length; i++) {
          if (items[i].instanceId === itemId) {
            // Get the catalog item
            const catalogItem = this.currentItemType === 'section'
              ? this.catalogData.sections.find(s => s.id === referenceId)
              : this.catalogData.fields.find(f => f.id === referenceId);
            
            // Only create overrides if different from catalog
            if (catalogItem) {
              const overrides: any = {};
              
              if (name !== catalogItem.name) overrides.name = name;
              if (label !== catalogItem.label) overrides.label = label;
              if (type && type !== catalogItem.type) overrides.type = type;
              if (required !== catalogItem.required) overrides.required = required;
              if (visible !== catalogItem.visible) overrides.visible = visible;
              if (editable !== catalogItem.editable) overrides.editable = editable;
              
              // Update the item
              items[i] = { 
                ...items[i], 
                name, 
                label, 
                required, 
                visible, 
                editable,
                type: type || items[i].type,
                overrideProperties: overrides 
              };
              
              return true;
            }
            
            return false;
          }
          
          // Check in fields
          if (items[i].fields) {
            const found = updateItem(items[i].fields);
            if (found) return true;
          }
          
          // Check in subsections
          if (items[i].subSections) {
            const found = updateItem(items[i].subSections);
            if (found) return true;
          }
        }
        
        return false;
      };
      
      updateItem(this.formData);
    }
    
    this.closePropertiesPanel();
  }

  // Open override panel
  openOverridePanel(item: any, type: string): void {
    this.currentOverrideItem = item;
    this.currentOverrideType = type;
    
    // Initialize override values with catalog values
    this.overrideValues = {
      name: item.name,
      label: item.label,
      type: item.type,
      required: item.required,
      visible: item.visible,
      editable: item.editable
    };
    
    // Load custom properties
    this.customOverrideProperties = [];
    Object.entries(item).forEach(([key, value]) => {
      if (!['id', 'name', 'label', 'type', 'required', 'visible', 'editable', 'description'].includes(key)) {
        this.customOverrideProperties.push({ key, value });
      }
    });
    
    this.showOverridePanel = true;
  }

  // Open override panel for instance
  openInstanceOverridePanel(item: any, type: string): void {
    this.currentOverrideItem = item;
    this.currentOverrideType = type;
    
    // Find the catalog item
    const catalogItem = type === 'section'
      ? this.catalogData.sections.find(s => s.id === item.referenceId)
      : this.catalogData.fields.find(f => f.id === item.referenceId);
    
    if (catalogItem) {
      // Initialize override values with existing overrides or catalog values
      this.overrideValues = {
        name: item.overrideProperties?.name || catalogItem.name,
        label: item.overrideProperties?.label || catalogItem.label,
        type: item.overrideProperties?.type || catalogItem.type,
        required: item.overrideProperties?.required !== undefined 
                 ? item.overrideProperties.required 
                 : catalogItem.required,
        visible: item.overrideProperties?.visible !== undefined 
                ? item.overrideProperties.visible 
                : catalogItem.visible,
        editable: item.overrideProperties?.editable !== undefined 
                 ? item.overrideProperties.editable 
                 : catalogItem.editable
      };
      
      // Load custom properties
      this.customOverrideProperties = [];
      Object.entries(catalogItem).forEach(([key, value]) => {
        if (!['id', 'name', 'label', 'type', 'required', 'visible', 'editable', 'description'].includes(key)) {
          const overrideValue = item.overrideProperties ? item.overrideProperties[key] : undefined;
          this.customOverrideProperties.push({ 
            key, 
            value: overrideValue !== undefined ? overrideValue : value 
          });
        }
      });
    }
    
    this.showOverridePanel = true;
  }

  // Close override panel
  closeOverridePanel(): void {
    this.showOverridePanel = false;
    this.currentOverrideItem = null;
    this.customOverrideProperties = [];
  }

  // Save overrides
  saveOverrides(): void {
    if (!this.currentOverrideItem) return;
    
    const item = this.currentOverrideItem;
    
    if (!item.overrideProperties) {
      item.overrideProperties = {};
    }
    
    // If it's a catalog item being used as a template
    if (!item.instanceId) {
      // We don't modify catalog items directly, just close the panel
      this.closeOverridePanel();
      return;
    }
    
    // Find the catalog item
    const catalogItem = this.currentOverrideType === 'section'
      ? this.catalogData.sections.find(s => s.id === item.referenceId)
      : this.catalogData.fields.find(f => f.id === item.referenceId);
    
    if (catalogItem) {
      // Compare with catalog and add overrides only if different
      const { name, label, type, required, visible, editable } = this.overrideValues;
      
      if (name !== catalogItem.name) item.overrideProperties.name = name;
      else delete item.overrideProperties.name;
      
      if (label !== catalogItem.label) item.overrideProperties.label = label;
      else delete item.overrideProperties.label;
      
      if (type && type !== catalogItem.type) item.overrideProperties.type = type;
      else delete item.overrideProperties.type;
      
      if (required !== catalogItem.required) item.overrideProperties.required = required;
      else delete item.overrideProperties.required;
      
      if (visible !== catalogItem.visible) item.overrideProperties.visible = visible;
      else delete item.overrideProperties.visible;
      
      if (editable !== catalogItem.editable) item.overrideProperties.editable = editable;
      else delete item.overrideProperties.editable;
      
      // Process custom properties
      this.customOverrideProperties.forEach(prop => {
        if (JSON.stringify(prop.value) !== JSON.stringify(catalogItem[prop.key])) {
          item.overrideProperties[prop.key] = prop.value;
        } else {
          delete item.overrideProperties[prop.key];
        }
      });
      
      // Update the display properties
      item.name = item.overrideProperties.name || catalogItem.name;
      item.label = item.overrideProperties.label || catalogItem.label;
      if (this.currentOverrideType === 'field') {
        item.type = item.overrideProperties.type || catalogItem.type;
      }
    }
    
    this.closeOverridePanel();
  }

  // Clear overrides
  clearOverrides(): void {
    if (!this.currentOverrideItem) return;
    
    const item = this.currentOverrideItem;
    
    // Clear all overrides
    item.overrideProperties = {};
    
    // Reset to catalog values
    if (item.instanceId) {
      const catalogItem = this.currentOverrideType === 'section'
        ? this.catalogData.sections.find(s => s.id === item.referenceId)
        : this.catalogData.fields.find(f => f.id === item.referenceId);
      
      if (catalogItem) {
        item.name = catalogItem.name;
        item.label = catalogItem.label;
        if (this.currentOverrideType === 'field') {
          item.type = catalogItem.type;
        }
      }
    }
    
    this.closeOverridePanel();
  }

  // Remove custom override property
  removeCustomOverride(index: number): void {
    this.customOverrideProperties.splice(index, 1);
  }

  // Helper to check if an item has overrides
  hasOverrides(item: any): boolean {
    return item && item.overrideProperties && Object.keys(item.overrideProperties).length > 0;
  }

  // Generate JSON output
  generateJson(): void {
    const prepareJson = (items: any[]) => {
      return items.map(item => {
        const jsonItem: any = {
          sectionId: item.referenceId,
          instanceId: item.instanceId
        };
        
        // Add override properties if they exist
        if (Object.keys(item.overrideProperties || {}).length > 0) {
          jsonItem.overrideProperties = { ...item.overrideProperties };
        }
        
        // Add fields if they exist
        if (item.fields && item.fields.length > 0) {
          jsonItem.fields = item.fields.map((field: any) => ({
            fieldId: field.referenceId,
            instanceId: field.instanceId,
            overrideProperties: Object.keys(field.overrideProperties || {}).length > 0 ? 
              { ...field.overrideProperties } : undefined
          })).filter((f: any) => f.overrideProperties || true);
        }
        
        // Add subsections if they exist
        if (item.subSections && item.subSections.length > 0) {
          jsonItem.subSections = prepareJson(item.subSections);
        }
        
        return jsonItem;
      });
    };
    
    const jsonData = prepareJson(this.formData);
    this.jsonOutput = JSON.stringify(jsonData, null, 2);
    this.showJsonOutput = true;
  }

  // Clear form
  clearForm(): void {
    this.formData = [];
    this.showJsonOutput = false;
  }

  // Export catalog as JSON
  exportCatalog(): void {
    const jsonData = JSON.stringify(this.catalogData, null, 2);
    this.downloadJson(jsonData, 'form_catalog.json');
  }

  // Export everything (catalog + form)
  exportAll(): void {
    const formJson = this.generateFormJson();
    
    const exportData = {
      catalog: this.catalogData,
      form: formJson
    };
    
    const jsonData = JSON.stringify(exportData, null, 2);
    this.downloadJson(jsonData, 'form_complete.json');
  }

  // Helper to generate form JSON without displaying it
  private generateFormJson(): any {
    const prepareJson = (items: any[]) => {
      return items.map(item => {
        const jsonItem: any = {
          sectionId: item.referenceId,
          instanceId: item.instanceId
        };
        
        // Add override properties if they exist
        if (Object.keys(item.overrideProperties || {}).length > 0) {
          jsonItem.overrideProperties = { ...item.overrideProperties };
        }
        
        // Add fields if they exist
        if (item.fields && item.fields.length > 0) {
          jsonItem.fields = item.fields.map((field: any) => ({
            fieldId: field.referenceId,
            instanceId: field.instanceId,
            overrideProperties: Object.keys(field.overrideProperties || {}).length > 0 ? 
              { ...field.overrideProperties } : undefined
          })).filter((f: any) => f.overrideProperties || true);
        }
        
        // Add subsections if they exist
        if (item.subSections && item.subSections.length > 0) {
          jsonItem.subSections = prepareJson(item.subSections);
        }
        
        return jsonItem;
      });
    };
    
    return prepareJson(this.formData);
  }

  // Apply JSON from editor
  applyJson(): void {
    try {
      const json = this.jsonEditor;
      if (!json) {
        alert('Please enter JSON first');
        return;
      }
      
      const parsedData = JSON.parse(json);
      
      // Validate the JSON format
      if (!parsedData.sections || !parsedData.fields) {
        alert('Invalid catalog JSON format. Must contain "sections" and "fields" arrays.');
        return;
      }
      
      // Update catalog data
      this.catalogData = parsedData;
      
      // Update counters
      this.updateCounters();
    } catch (err) {
      alert('Error parsing JSON: ' + (err as Error).message);
    }
  }

  // Import catalog from file
  importCatalogFile(event: any): void {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e: any) => {
      try {
        const json = JSON.parse(e.target.result);
        this.jsonEditor = JSON.stringify(json, null, 2);
      } catch (err) {
        alert('Error parsing JSON file: ' + (err as Error).message);
      }
    };
    reader.readAsText(file);
  }

  // Helper function to download JSON
  private downloadJson(jsonData: string, filename: string): void {
    const blob = new Blob([jsonData], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.download = filename;
    a.href = url;
    a.click();
    URL.revokeObjectURL(url);
  }

  // Helper function to update counters based on catalog data
  private updateCounters(): void {
    // Get highest section ID
    let maxSectionId = 0;
    this.catalogData.sections.forEach(section => {
      const idNum = parseInt(section.id.replace('SEC', ''));
      if (idNum > maxSectionId) maxSectionId = idNum;
    });
    this.sectionCounter = maxSectionId + 1;
    
    // Get highest field ID
    let maxFieldId = 0;
    this.catalogData.fields.forEach(field => {
      const idNum = parseInt(field.id.replace('FLD', ''));
      if (idNum > maxFieldId) maxFieldId = idNum;
    });
    this.fieldCounter = maxFieldId + 1;
  }
}  
