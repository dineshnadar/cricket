import { Component, ViewChild, ViewContainerRef, inject, effect } from '@angular/core';
import { FormGroup } from '@angular/forms';
import { ProfileBuilderService } from './profile-builder.service';
import { WidgetConfig, SubMenuItem } from './widget-config';

@Component({
  selector: 'app-party-builder',
  template: `
    <div class="profile-selector">
      <button *ngFor="let profile of profileService.profiles(); let i = index"
              (click)="profileService.setActiveProfile(i)"
              [class.active]="i === profileService.activeProfileIndex()">
        Profile {{ i + 1 }}
      </button>
      <button (click)="profileService.addNewProfile()">Add New Profile</button>
    </div>
    <div class="party-builder" *ngIf="profileService.getActiveProfile()">
      <app-left-menu></app-left-menu>
      <div #widgetContainer></div>
    </div>
    <button (click)="validateAll()">Validate All</button>
    <button (click)="loadAllWidgets()">Load All Widgets</button>
    <button (click)="loadNextIncompleteWidget()">Next Incomplete Widget</button>
  `
})
export class PartyBuilderComponent {
  @ViewChild('widgetContainer', { read: ViewContainerRef, static: false })
  widgetContainer!: ViewContainerRef;

  profileService = inject(ProfileBuilderService);

  constructor() {
    effect(() => {
      const activeWidgetName = this.profileService.getActiveWidgetName()();
      if (activeWidgetName) {
        this.loadComponent(activeWidgetName);
      }
    });
  }

  async loadComponent(widgetName: string) {
    this.widgetContainer.clear();
    const widgetConfig = this.profileService.findWidgetByName(widgetName);

    if (widgetConfig) {
      if (widgetConfig.component) {
        await this.loadWidgetComponent(widgetConfig, widgetName);
      } else if (this.hasSubMenu(widgetConfig)) {
        const firstSubMenuItem = this.getFirstSubMenuItem(widgetConfig);
        if (firstSubMenuItem && firstSubMenuItem.component) {
          await this.loadWidgetComponent(firstSubMenuItem, firstSubMenuItem.name);
        }
      }
    }
  }

  private async loadWidgetComponent(widget: WidgetConfig | SubMenuItem, widgetName: string) {
    if (widget.component) {
      const component = await widget.component();
      const componentRef = this.widgetContainer.createComponent(component);
      const activeProfile = this.profileService.getActiveProfile();
      if (activeProfile) {
        const widgetForm = activeProfile.get(widgetName) as FormGroup;
        if (componentRef.instance.setFormGroup) {
          componentRef.instance.setFormGroup(widgetForm);
        }
      }
      // Set the widget status to 'in-progress' after loading
      this.profileService.setWidgetStatus(widgetName, 'in-progress');
    }
  }

  private hasSubMenu(widget: WidgetConfig | SubMenuItem): boolean {
    return this.profileService.getSubMenuItems(widget).length > 0;
  }

  private getFirstSubMenuItem(widget: WidgetConfig | SubMenuItem): SubMenuItem | undefined {
    const subMenuItems = this.profileService.getSubMenuItems(widget);
    return subMenuItems[0];
  }

  validateAll() {
    const isValid = this.profileService.validateAllWidgets();
    console.log(isValid ? 'All widgets are valid' : 'There are validation errors');
    console.log('Completion percentage:', this.profileService.getCompletionPercentage());
  }

  loadAllWidgets() {
    this.profileService.loadAllWidgets();
  }

  loadNextIncompleteWidget() {
    const nextWidgetName = this.profileService.getNextIncompleteWidget();
    if (nextWidgetName) {
      this.profileService.setActiveWidget(nextWidgetName);
    } else {
      console.log('All widgets are complete!');
    }
  }
}

-----------

import { Component, inject, Signal } from '@angular/core';
import { NgFor, NgIf, NgClass } from '@angular/common';
import { ProfileBuilderService } from './profile-builder.service';
import { WidgetConfig, SubMenuItem, WidgetState } from './widget-config';

interface MenuItemWithState extends WidgetConfig {
  state: WidgetState;
  subItems?: MenuItemWithState[];
}

@Component({
  selector: 'app-left-menu',
  standalone: true,
  imports: [NgFor, NgIf, NgClass],
  template: `
    <nav>
      <ul>
        <ng-container *ngFor="let widget of visibleWidgets()">
          <li>
            <ng-container *ngTemplateOutlet="menuItem; context: { $implicit: widget }"></ng-container>
          </li>
        </ng-container>
      </ul>
    </nav>

    <ng-template #menuItem let-item>
      <div [ngClass]="getItemClasses(item.state)" (click)="setActiveWidget(item.name)">
        {{ item.label }}
        <span *ngIf="item.state.hasError" class="error-indicator">!</span>
        <span *ngIf="item.state.status === 'completed'" class="completion-indicator">✓</span>
        <span *ngIf="item.state.status === 'in-progress'" class="in-progress-indicator">⋯</span>
      </div>
      <ul *ngIf="item.subItems?.length">
        <li *ngFor="let subItem of item.subItems">
          <ng-container *ngTemplateOutlet="menuItem; context: { $implicit: subItem }"></ng-container>
        </li>
      </ul>
    </ng-template>
  `,
  styles: [`
    ul { list-style-type: none; padding-left: 20px; }
    li { margin-bottom: 5px; }
    .menu-item { 
      cursor: pointer; 
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 5px;
      border-radius: 4px;
    }
    .active { background-color: #e0e0e0; font-weight: bold; }
    .visited { text-decoration: underline; }
    .error { color: red; }
    .acknowledged { font-style: italic; }
    .completed { color: green; }
    .in-progress { color: orange; }
    .error-indicator, .completion-indicator, .in-progress-indicator { 
      font-weight: bold; 
      margin-left: 5px; 
    }
    .error-indicator { color: red; }
    .completion-indicator { color: green; }
    .in-progress-indicator { color: orange; }
  `]
})
export class LeftMenuComponent {
  private profileService = inject(ProfileBuilderService);

  visibleWidgets: Signal<MenuItemWithState[]> = this.profileService.getVisibleWidgets;

  getItemClasses(state: WidgetState): { [key: string]: boolean } {
    return {
      'menu-item': true,
      'active': state.active,
      'visited': state.visited,
      'error': state.hasError,
      'acknowledged': state.acknowledged,
      [state.status]: true
    };
  }

  setActiveWidget(widgetName: string): void {
    this.profileService.setActiveWidget(widgetName);
  }
}

----------

import { Injectable, signal, computed, WritableSignal, inject } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { HttpClient } from '@angular/common/http';
import { firstValueFrom } from 'rxjs';
import { WIDGET_CONFIG, WidgetConfig, WidgetState, SubMenuItem } from './widget-config';

@Injectable({ providedIn: 'root' })
export class ProfileBuilderService {
  private fb = inject(FormBuilder);
  private http = inject(HttpClient);

  private profiles: WritableSignal<FormGroup[]> = signal([]);
  private activeProfileIndex: WritableSignal<number | null> = signal(null);
  private profileWidgetStates: WritableSignal<Record<string, WidgetState>[]> = signal([]);
  private activeWidgetName: WritableSignal<string | null> = signal(null);
  private isLoading: WritableSignal<boolean> = signal(false);
  private dynamicSubMenus: WritableSignal<Record<string, SubMenuItem[]>> = signal({});

  private initialWidgetState: WidgetState = {
    hasError: false,
    errorMessage: '',
    visited: false,
    acknowledged: false,
    active: false,
    status: 'pending'
  };

  constructor() {
    this.loadDynamicSubMenus();
  }

  private async loadDynamicSubMenus() {
    for (const widget of WIDGET_CONFIG) {
      await this.loadSubMenusRecursively(widget);
    }
  }

  private async loadSubMenusRecursively(item: WidgetConfig | SubMenuItem) {
    if (typeof item.subMenu === 'function') {
      const subMenus = await item.subMenu();
      this.dynamicSubMenus.update(current => ({ ...current, [item.name]: subMenus }));
      for (const subItem of subMenus) {
        await this.loadSubMenusRecursively(subItem);
      }
    } else if (item.subMenu === 'dynamic' || item.subMenu === 'api') {
      const subMenus = await this.fetchDynamicSubMenu(item.name);
      this.dynamicSubMenus.update(current => ({ ...current, [item.name]: subMenus }));
      for (const subItem of subMenus) {
        await this.loadSubMenusRecursively(subItem);
      }
    } else if (Array.isArray(item.subMenu)) {
      for (const subItem of item.subMenu) {
        await this.loadSubMenusRecursively(subItem);
      }
    }
  }

  private async fetchDynamicSubMenu(widgetName: string): Promise<SubMenuItem[]> {
    try {
      const response = await firstValueFrom(this.http.get<SubMenuItem[]>(`/api/sub-menu/${widgetName}`));
      return response || [];
    } catch (error) {
      console.error(`Error fetching dynamic sub-menu for ${widgetName}:`, error);
      return [];
    }
  }

  getVisibleWidgets = computed(() => {
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfileWidgetStates) return [];

    const processWidgets = (items: (WidgetConfig | SubMenuItem)[]): (WidgetConfig | SubMenuItem & { state: WidgetState, subItems?: any[] })[] => {
      return items.map(item => {
        if (!item.visible) return null;
        const subItems = this.getSubMenuItems(item);
        const processedSubItems = subItems.length ? processWidgets(subItems) : undefined;
        return {
          ...item,
          state: activeProfileWidgetStates[item.name] || this.initialWidgetState,
          subItems: processedSubItems?.filter(Boolean)
        };
      }).filter(Boolean);
    };

    return processWidgets(WIDGET_CONFIG);
  });

  addNewProfile() {
    const newProfileForm = this.createProfileFormGroup();
    this.profiles.update(profiles => [...profiles, newProfileForm]);

    const newProfileWidgetStates = this.createInitialWidgetStates();
    this.profileWidgetStates.update(states => [...states, newProfileWidgetStates]);

    this.setActiveProfile(this.profiles().length - 1);
  }

  private createProfileFormGroup(): FormGroup {
    return this.fb.group({
      id: [''],
      name: [''],
      // ... other profile fields
    });
  }

  private createInitialWidgetStates(): Record<string, WidgetState> {
    const initializeStates = (items: (WidgetConfig | SubMenuItem)[]): Record<string, WidgetState> => {
      return items.reduce((acc, item) => {
        acc[item.name] = { ...this.initialWidgetState };
        const subItems = this.getSubMenuItems(item);
        return { ...acc, ...initializeStates(subItems) };
      }, {} as Record<string, WidgetState>);
    };

    return initializeStates(WIDGET_CONFIG);
  }

  setActiveProfile(index: number) {
    if (index >= 0 && index < this.profiles().length) {
      this.activeProfileIndex.set(index);
      this.resetWidgetStates();
      this.loadInitialWidget();
    } else {
      console.error('Invalid profile index');
    }
  }

  getActiveProfile(): FormGroup | null {
    const index = this.activeProfileIndex();
    return index !== null ? this.profiles()[index] : null;
  }

  getActiveProfileWidgetStates(): Record<string, WidgetState> | null {
    const index = this.activeProfileIndex();
    return index !== null ? this.profileWidgetStates()[index] : null;
  }

  setActiveWidget(widgetName: string) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[activeProfileIndex] };

      // Deactivate all widgets
      Object.keys(profileStates).forEach(key => {
        profileStates[key] = { ...profileStates[key], active: false };
      });

      // Activate the selected widget and its parents
      this.activateWidgetAndParents(widgetName, profileStates);

      newAllStates[activeProfileIndex] = profileStates;
      return newAllStates;
    });

    this.activeWidgetName.set(widgetName);

    // If the widget doesn't have a component, activate its first sub-item
    const widget = this.findWidgetByName(widgetName);
    if (widget && !widget.component) {
      const subItems = this.getSubMenuItems(widget);
      if (subItems.length > 0) {
        this.setActiveWidget(subItems[0].name); // Recursive call for first sub-item
      }
    } else if (widget && widget.component) {
      // Set the status to 'in-progress' when the widget is loaded
      this.setWidgetStatus(widgetName, 'in-progress');
    }
  }

  private activateWidgetAndParents(widgetName: string, profileStates: Record<string, WidgetState>) {
    const activateRecursively = (items: (WidgetConfig | SubMenuItem)[]): boolean => {
      for (const item of items) {
        if (item.name === widgetName) {
          profileStates[item.name] = { ...profileStates[item.name], active: true, visited: true };
          return true;
        }
        const subItems = this.getSubMenuItems(item);
        if (activateRecursively(subItems)) {
          profileStates[item.name] = { ...profileStates[item.name], active: true, visited: true };
          return true;
        }
      }
      return false;
    };

    activateRecursively(WIDGET_CONFIG);
  }

  setWidgetStatus(widgetName: string, status: WidgetState['status']) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[activeProfileIndex] };

      profileStates[widgetName] = {
        ...profileStates[widgetName],
        status: status
      };

      // Update parent statuses
      this.updateParentStates(widgetName, profileStates);

      newAllStates[activeProfileIndex] = profileStates;
      return newAllStates;
    });
  }

  getSubMenuItems(item: WidgetConfig | SubMenuItem): SubMenuItem[] {
    if (Array.isArray(item.subMenu)) {
      return item.subMenu;
    } else if (this.dynamicSubMenus()[item.name]) {
      return this.dynamicSubMenus()[item.name];
    }
    return [];
  }

  findWidgetByName(name: string): WidgetConfig | SubMenuItem | undefined {
    const find = (items: (WidgetConfig | SubMenuItem)[]): WidgetConfig | SubMenuItem | undefined => {
      for (const item of items) {
        if (item.name === name) return item;
        const subItems = this.getSubMenuItems(item);
        const found = find(subItems);
        if (found) return found;
      }
    };
    return find(WIDGET_CONFIG);
  }

  
  private updateParentStates(widgetName: string, profileStates: Record<string, WidgetState>) {
    const updateRecursively = (items: (WidgetConfig | SubMenuItem)[]): boolean => {
      for (const item of items) {
        if (item.name === widgetName) {
          const subItems = this.getSubMenuItems(item);
          if (subItems.length === 0) {
            // If there are no sub-items, don't update the parent
            return false;
          }
          
          const childStates = subItems.map(subItem => profileStates[subItem.name]);
          this.updateParentState(item.name, childStates, profileStates);
          return true;
        }
        
        const subItems = this.getSubMenuItems(item);
        if (updateRecursively(subItems)) {
          this.updateParentState(item.name, subItems.map(subItem => profileStates[subItem.name]), profileStates);
          return true;
        }
      }
      return false;
    };

    updateRecursively(WIDGET_CONFIG);
  }

  private updateParentState(parentName: string, childStates: WidgetState[], profileStates: Record<string, WidgetState>) {
    const allChildrenCompleted = childStates.every(state => state.status === 'completed');
    const anyChildError = childStates.some(state => state.status === 'error');
    const allChildrenAcknowledged = childStates.every(state => state.acknowledged);
    const anyChildVisited = childStates.some(state => state.visited);

    let newStatus: WidgetState['status'] = 'pending';
    if (allChildrenCompleted) newStatus = 'completed';
    else if (anyChildError) newStatus = 'error';
    else if (childStates.some(state => state.status === 'in-progress')) newStatus = 'in-progress';

    profileStates[parentName] = {
      ...profileStates[parentName],
      status: newStatus,
      acknowledged: allChildrenAcknowledged,
      visited: anyChildVisited || profileStates[parentName].visited,
      hasError: anyChildError
    };
  }


  resetWidgetStates() {
    const index = this.activeProfileIndex();
    if (index !== null) {
      this.profileWidgetStates.update(allStates => {
        const newAllStates = [...allStates];
        newAllStates[index] = this.createInitialWidgetStates();
        return newAllStates;
      });
    }
  }

  loadInitialWidget() {
    const visibleWidgets = this.getVisibleWidgets()();
    if (visibleWidgets.length > 0) {
      this.setActiveWidget(visibleWidgets[0].name);
    }
  }

  validateAllWidgets(): boolean {
    const activeProfile = this.getActiveProfile();
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfile || !activeProfileWidgetStates) return false;

    let isValid = true;
    const validateRecursively = (items: (WidgetConfig | SubMenuItem)[]) => {
      items.forEach(widget => {
        if (widget.visible) {
          const widgetForm = activeProfile.get(widget.name);
          const widgetValid = widgetForm?.valid ?? false;
          this.updateWidgetState(widget.name, { 
            hasError: !widgetValid, 
            status: widgetValid ? 'completed' : 'error' 
          });
          isValid = isValid && widgetValid;
          
          const subItems = this.getSubMenuItems(widget);
          validateRecursively(subItems);
        }
      });
    };

    validateRecursively(WIDGET_CONFIG);
    return isValid;
  }

  loadAllWidgets() {
    const loadRecursively = (items: (WidgetConfig | SubMenuItem)[]) => {
      items.forEach(widget => {
        if (widget.visible) {
          this.updateWidgetState(widget.name, { visited: true, status: 'in-progress' });
          const subItems = this.getSubMenuItems(widget);
          loadRecursively(subItems);
        }
      });
    };

    loadRecursively(WIDGET_CONFIG);
  }

  getNextIncompleteWidget(): string | null {
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfileWidgetStates) return null;

    const findIncompleteRecursively = (items: (WidgetConfig | SubMenuItem)[]): string | null => {
      for (const widget of items) {
        if (widget.visible && activeProfileWidgetStates[widget.name]?.status !== 'completed') {
          return widget.name;
        }
        const subItems = this.getSubMenuItems(widget);
        const incompleteSubWidget = findIncompleteRecursively(subItems);
        if (incompleteSubWidget) return incompleteSubWidget;
      }
      return null;
    };

    return findIncompleteRecursively(WIDGET_CONFIG);
  }

  getCompletionPercentage(): number {
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfileWidgetStates) return 0;

    let totalWidgets = 0;
    let completedWidgets = 0;

    const countRecursively = (items: (WidgetConfig | SubMenuItem)[]) => {
      items.forEach(widget => {
        if (widget.visible) {
          totalWidgets++;
          if (activeProfileWidgetStates[widget.name]?.status === 'completed') {
            completedWidgets++;
          }
          const subItems = this.getSubMenuItems(widget);
          countRecursively(subItems);
        }
      });
    };

    countRecursively(WIDGET_CONFIG);
    return totalWidgets === 0 ? 0 : (completedWidgets / totalWidgets) * 100;
  }

  acknowledgeWidget(widgetName: string) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[activeProfileIndex] };

      this.acknowledgeWidgetRecursively(widgetName, profileStates);
      this.updateParentStates(widgetName, profileStates);

      newAllStates[activeProfileIndex] = profileStates;
      return newAllStates;
    });
  }

  private acknowledgeWidgetRecursively(widgetName: string, profileStates: Record<string, WidgetState>) {
    const widget = this.findWidgetByName(widgetName);
    if (widget) {
      profileStates[widgetName] = {
        ...profileStates[widgetName],
        acknowledged: true
      };

      const subItems = this.getSubMenuItems(widget);
      subItems.forEach(subItem => {
        this.acknowledgeWidgetRecursively(subItem.name, profileStates);
      });
    }
  }

  updateWidgetState(widgetName: string, update: Partial<WidgetState>) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[activeProfileIndex] };

      profileStates[widgetName] = {
        ...profileStates[widgetName],
        ...update
      };

      this.updateParentStates(widgetName, profileStates);

      newAllStates[activeProfileIndex] = profileStates;
      return newAllStates;
    });
  }

  getIsLoading(): WritableSignal<boolean> {
    return this.isLoading;
  }

  getActiveWidgetName(): Signal<string | null> {
    return this.activeWidgetName.asReadonly();
  }

  async createOrEditProfile(partyId?: string) {
    this.isLoading.set(true);
    try {
      let profileData: any = {};
      const metadataData = await this.fetchMetadata();

      if (partyId) {
        // Editing existing profile
        profileData = await this.fetchPartyData(partyId);
        const existingProfileIndex = this.findProfileIndexByPartyId(partyId);

        if (existingProfileIndex !== -1) {
          // Update existing profile
          this.updateProfile(existingProfileIndex, profileData, metadataData);
          this.setActiveProfile(existingProfileIndex);
        } else {
          // Profile not found, create new
          this.addNewProfile();
          const newProfileIndex = this.profiles().length - 1;
          this.updateProfile(newProfileIndex, profileData, metadataData);
        }
      } else {
        // Creating new profile
        this.addNewProfile();
        const newProfileIndex = this.profiles().length - 1;
        this.updateProfile(newProfileIndex, profileData, metadataData);
      }
    } catch (error) {
      console.error('Error in createOrEditProfile:', error);
      // Handle error (e.g., show user notification)
    } finally {
      this.isLoading.set(false);
    }
  }

  private updateProfile(index: number, profileData: any, metadataData: any) {
    const profileForm = this.profiles()[index];
    if (profileForm) {
      // Update form with new data
      profileForm.patchValue(profileData);

      // Update widget states based on the new data
      this.updateWidgetStatesFromProfileData(index, profileData);

      // You might want to add logic here to handle metadata
      // For example, updating visibility of widgets based on metadata
    }
  }

  private updateWidgetStatesFromProfileData(profileIndex: number, profileData: any) {
    const updateStatesRecursively = (items: (WidgetConfig | SubMenuItem)[]) => {
      items.forEach(widget => {
        if (profileData[widget.name]) {
          this.updateWidgetState(widget.name, { 
            visited: true,
            status: 'in-progress'
          });
        }
        const subItems = this.getSubMenuItems(widget);
        updateStatesRecursively(subItems);
      });
    };

    updateStatesRecursively(WIDGET_CONFIG);
  }

  private findProfileIndexByPartyId(partyId: string): number {
    return this.profiles().findIndex(profile => profile.get('id')?.value === partyId);
  }

  private async fetchMetadata(): Promise<any> {
    try {
      return await firstValueFrom(this.http.get('/api/metadata'));
    } catch (error) {
      console.error('Error fetching metadata:', error);
      return {};
    }
  }

  private async fetchPartyData(partyId: string): Promise<any> {
    try {
      return await firstValueFrom(this.http.get(`/api/party/${partyId}`));
    } catch (error) {
      console.error(`Error fetching party data for ID ${partyId}:`, error);
      return {};
    }
  }
}

---------------

import { Component, inject, Signal, computed } from '@angular/core';
import { NgFor, NgIf, NgClass } from '@angular/common';
import { ProfileBuilderService } from './profile-builder.service';
import { WidgetConfig, SubMenuItem, WidgetState } from './widget-config';

interface MenuItemWithState extends WidgetConfig {
  state: WidgetState;
  subMenuItems?: MenuItemWithState[];
}

@Component({
  selector: 'app-left-menu',
  standalone: true,
  imports: [NgFor, NgIf, NgClass],
  template: `
    <nav>
      <ul>
        <ng-container *ngFor="let widget of visibleWidgets()">
          <li>
            <ng-container *ngTemplateOutlet="menuItem; context: { $implicit: widget }"></ng-container>
          </li>
        </ng-container>
      </ul>
    </nav>

    <ng-template #menuItem let-item>
      <div [ngClass]="getItemClasses(item.state)" (click)="setActiveWidget(item.name)">
        {{ item.label }}
        <span *ngIf="item.state.hasError" class="error-indicator">!</span>
        <span *ngIf="item.state.status === 'completed'" class="completion-indicator">✓</span>
        <span *ngIf="item.state.status === 'in-progress'" class="in-progress-indicator">⋯</span>
      </div>
      <ul *ngIf="item.subMenuItems?.length">
        <li *ngFor="let subItem of item.subMenuItems">
          <ng-container *ngTemplateOutlet="menuItem; context: { $implicit: subItem }"></ng-container>
        </li>
      </ul>
    </ng-template>
  `,
  styles: [/* ... styles remain the same ... */]
})
export class LeftMenuComponent {
  private profileService = inject(ProfileBuilderService);

  visibleWidgets: Signal<MenuItemWithState[]> = computed(() => {
    const widgets = this.profileService.getVisibleWidgets();
    return this.mapToMenuItemWithState(widgets());
  });

  private mapToMenuItemWithState(items: (WidgetConfig | SubMenuItem)[]): MenuItemWithState[] {
    return items.map(item => {
      const subMenuItems = this.profileService.getSubMenuItems(item);
      return {
        ...item,
        state: this.profileService.getActiveProfileWidgetStates()?.[item.name] || this.profileService['initialWidgetState'],
        subMenuItems: subMenuItems.length ? this.mapToMenuItemWithState(subMenuItems) : undefined
      };
    });
  }

  getItemClasses(state: WidgetState): { [key: string]: boolean } {
    return {
      'menu-item': true,
      'active': state.active,
      'visited': state.visited,
      'error': state.hasError,
      'acknowledged': state.acknowledged,
      [state.status]: true
    };
  }

  setActiveWidget(widgetName: string): void {
    this.profileService.setActiveWidget(widgetName);
  }
}
