import { Component, ViewChild, ViewContainerRef, inject, effect, Signal } from '@angular/core';
import { FormGroup } from '@angular/forms';
import { ProfileBuilderService } from './profile-builder.service';
import { WidgetConfig, SubMenuItem } from './widget-config';

@Component({
  selector: 'app-party-builder',
  template: `
    <app-left-menu></app-left-menu>
    <div #widgetContainer></div>
  `
})
export class PartyBuilderComponent {
  @ViewChild('widgetContainer', { read: ViewContainerRef, static: false })
  widgetContainer!: ViewContainerRef;

  private profileService = inject(ProfileBuilderService);

  constructor() {
    effect(() => {
      const activeWidgetName = this.profileService.activeWidgetName();
      if (activeWidgetName) {
        this.loadComponent(activeWidgetName);
      }
    });
  }

  async loadComponent(widgetName: string) {
    this.widgetContainer.clear();
    const widgetConfig = this.profileService.findWidgetByName(widgetName);

    if (widgetConfig) {
      if (widgetConfig.component) {
        await this.loadWidgetComponent(widgetConfig, widgetName);
      } else if (this.hasSubMenu(widgetConfig)) {
        const firstSubMenuItem = this.getFirstSubMenuItem(widgetConfig);
        if (firstSubMenuItem && firstSubMenuItem.component) {
          await this.loadWidgetComponent(firstSubMenuItem, firstSubMenuItem.name);
        }
      }
    }
  }

  private async loadWidgetComponent(widget: WidgetConfig | SubMenuItem, widgetName: string) {
    if (widget.component) {
      const component = await widget.component();
      const componentRef = this.widgetContainer.createComponent(component);
      const activeProfile = this.profileService.getActiveProfile();
      if (activeProfile) {
        const widgetForm = activeProfile.get(widgetName) as FormGroup;
        if (componentRef.instance.setFormGroup) {
          componentRef.instance.setFormGroup(widgetForm);
        }
      }
      // Set the widget status to 'in-progress' after loading
      this.profileService.setWidgetStatus(widgetName, 'in-progress');
    }
  }

  private hasSubMenu(widget: WidgetConfig | SubMenuItem): boolean {
    return this.profileService.getSubMenuItems(widget).length > 0;
  }

  private getFirstSubMenuItem(widget: WidgetConfig | SubMenuItem): SubMenuItem | undefined {
    const subMenuItems = this.profileService.getSubMenuItems(widget);
    return subMenuItems[0];
  }
}

----------

import { Component, inject, Signal, computed } from '@angular/core';
import { NgFor, NgIf, NgClass } from '@angular/common';
import { ProfileBuilderService } from './profile-builder.service';
import { WidgetConfig, SubMenuItem, WidgetState } from './widget-config';

interface MenuItemWithState extends WidgetConfig {
  state: WidgetState;
  subItems?: MenuItemWithState[];
  classes: { [key: string]: boolean };
}

@Component({
  selector: 'app-left-menu',
  standalone: true,
  imports: [NgFor, NgIf, NgClass],
  template: `
    <nav>
      <ul>
        <ng-container *ngFor="let widget of menuItems()">
          <li>
            <ng-container *ngTemplateOutlet="menuItem; context: { $implicit: widget }"></ng-container>
          </li>
        </ng-container>
      </ul>
    </nav>

    <ng-template #menuItem let-item>
      <div [ngClass]="item.classes" (click)="setActiveWidget(item.name)">
        {{ item.label }}
        <span *ngIf="item.state.hasError" class="error-indicator">!</span>
        <span *ngIf="item.state.status === 'completed'" class="completion-indicator">✓</span>
        <span *ngIf="item.state.status === 'in-progress'" class="in-progress-indicator">⋯</span>
      </div>
      <ul *ngIf="item.subItems?.length">
        <li *ngFor="let subItem of item.subItems">
          <ng-container *ngTemplateOutlet="menuItem; context: { $implicit: subItem }"></ng-container>
        </li>
      </ul>
    </ng-template>
  `,
  styles: [`
    ul { list-style-type: none; padding-left: 20px; }
    li { margin-bottom: 5px; }
    .menu-item { 
      cursor: pointer; 
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 5px;
      border-radius: 4px;
    }
    .active { background-color: #e0e0e0; font-weight: bold; }
    .visited { text-decoration: underline; }
    .error { color: red; }
    .acknowledged { font-style: italic; }
    .completed { color: green; }
    .in-progress { color: orange; }
    .error-indicator, .completion-indicator, .in-progress-indicator { 
      font-weight: bold; 
      margin-left: 5px; 
    }
    .error-indicator { color: red; }
    .completion-indicator { color: green; }
    .in-progress-indicator { color: orange; }
  `]
})
export class LeftMenuComponent {
  private profileService = inject(ProfileBuilderService);

  menuItems: Signal<MenuItemWithState[]> = computed(() => {
    const visibleWidgets = this.profileService.getVisibleWidgets()();
    const activeProfileWidgetStates = this.profileService.getActiveProfileWidgetStates();
    return this.processMenuItems(visibleWidgets, activeProfileWidgetStates);
  });

  private processMenuItems(
    items: (WidgetConfig | SubMenuItem)[],
    widgetStates: Record<string, WidgetState> | null
  ): MenuItemWithState[] {
    return items.map(item => {
      const state = widgetStates?.[item.name] || this.profileService['initialWidgetState'];
      const subItems = this.profileService.getSubMenuItems(item);
      
      return {
        ...item,
        state,
        subItems: subItems.length ? this.processMenuItems(subItems, widgetStates) : undefined,
        classes: this.getItemClasses(state)
      };
    });
  }

  private getItemClasses(state: WidgetState): { [key: string]: boolean } {
    return {
      'menu-item': true,
      'active': state.active,
      'visited': state.visited,
      'error': state.hasError,
      'acknowledged': state.acknowledged,
      [state.status]: true
    };
  }

  setActiveWidget(widgetName: string): void {
    this.profileService.setActiveWidget(widgetName);
  }
}

-------------

import { Injectable, signal, computed, inject, WritableSignal } from '@angular/core';
import { FormBuilder, FormGroup } from '@angular/forms';
import { HttpClient } from '@angular/common/http';
import { firstValueFrom } from 'rxjs';
import { WIDGET_CONFIG, WidgetConfig, WidgetState, SubMenuItem } from './widget-config';

@Injectable({ providedIn: 'root' })
export class ProfileBuilderService {
  private fb = inject(FormBuilder);
  private http = inject(HttpClient);

  private profiles: WritableSignal<FormGroup[]> = signal([]);
  private activeProfileIndex: WritableSignal<number | null> = signal(null);
  private profileWidgetStates: WritableSignal<Record<string, WidgetState>[]> = signal([]);
  private activeWidgetName: WritableSignal<string | null> = signal(null);
  private isLoading: WritableSignal<boolean> = signal(false);
  private dynamicSubMenus: WritableSignal<Record<string, SubMenuItem[]>> = signal({});

  private initialWidgetState: WidgetState = {
    hasError: false,
    errorMessage: '',
    visited: false,
    acknowledged: false,
    active: false,
    status: 'pending'
  };

  constructor() {
    this.loadDynamicSubMenus();
  }

  private async loadDynamicSubMenus() {
    for (const widget of WIDGET_CONFIG) {
      await this.loadSubMenusRecursively(widget);
    }
  }

  private async loadSubMenusRecursively(item: WidgetConfig | SubMenuItem) {
    if (typeof item.subMenu === 'function') {
      const subMenus = await item.subMenu();
      this.dynamicSubMenus.update(current => ({ ...current, [item.name]: subMenus }));
      for (const subItem of subMenus) {
        await this.loadSubMenusRecursively(subItem);
      }
    } else if (item.subMenu === 'dynamic' || item.subMenu === 'api') {
      const subMenus = await this.fetchDynamicSubMenu(item.name);
      this.dynamicSubMenus.update(current => ({ ...current, [item.name]: subMenus }));
      for (const subItem of subMenus) {
        await this.loadSubMenusRecursively(subItem);
      }
    } else if (Array.isArray(item.subMenu)) {
      for (const subItem of item.subMenu) {
        await this.loadSubMenusRecursively(subItem);
      }
    }
  }

  private async fetchDynamicSubMenu(widgetName: string): Promise<SubMenuItem[]> {
    try {
      const response = await firstValueFrom(this.http.get<SubMenuItem[]>(`/api/sub-menu/${widgetName}`));
      return response || [];
    } catch (error) {
      console.error(`Error fetching dynamic sub-menu for ${widgetName}:`, error);
      return [];
    }
  }

  addNewProfile() {
    const newProfileForm = this.createProfileFormGroup();
    this.profiles.update(profiles => [...profiles, newProfileForm]);

    const newProfileWidgetStates = this.createInitialWidgetStates();
    this.profileWidgetStates.update(states => [...states, newProfileWidgetStates]);

    this.setActiveProfile(this.profiles().length - 1);
  }

  private createProfileFormGroup(): FormGroup {
    return this.fb.group({
      id: [''],
      name: [''],
      // ... other profile fields
    });
  }

  private createInitialWidgetStates(): Record<string, WidgetState> {
    const initializeStates = (items: (WidgetConfig | SubMenuItem)[]): Record<string, WidgetState> => {
      return items.reduce((acc, item) => {
        acc[item.name] = { ...this.initialWidgetState };
        const subItems = this.getSubMenuItems(item);
        return { ...acc, ...initializeStates(subItems) };
      }, {} as Record<string, WidgetState>);
    };

    return initializeStates(WIDGET_CONFIG);
  }

  setActiveProfile(index: number) {
    if (index >= 0 && index < this.profiles().length) {
      this.activeProfileIndex.set(index);
      this.resetWidgetStates();
      this.loadInitialWidget();
    } else {
      console.error('Invalid profile index');
    }
  }

  getActiveProfile(): FormGroup | null {
    const index = this.activeProfileIndex();
    return index !== null ? this.profiles()[index] : null;
  }

  getActiveProfileWidgetStates(): Record<string, WidgetState> | null {
    const index = this.activeProfileIndex();
    return index !== null ? this.profileWidgetStates()[index] : null;
  }

  setActiveWidget(widgetName: string) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[activeProfileIndex] };

      // Deactivate all widgets
      Object.keys(profileStates).forEach(key => {
        profileStates[key] = { ...profileStates[key], active: false };
      });

      // Activate the selected widget and its parents
      this.activateWidgetAndParents(widgetName, profileStates);

      newAllStates[activeProfileIndex] = profileStates;
      return newAllStates;
    });

    this.activeWidgetName.set(widgetName);

    // If the widget doesn't have a component, activate its first sub-item
    const widget = this.findWidgetByName(widgetName);
    if (widget && !widget.component) {
      const subItems = this.getSubMenuItems(widget);
      if (subItems.length > 0) {
        this.setActiveWidget(subItems[0].name); // Recursive call for first sub-item
      }
    } else if (widget && widget.component) {
      // Set the status to 'in-progress' when the widget is loaded
      this.setWidgetStatus(widgetName, 'in-progress');
    }
  }

  private activateWidgetAndParents(widgetName: string, profileStates: Record<string, WidgetState>) {
    const widget = this.findWidgetByName(widgetName);
    if (!widget) return;

    // Activate the widget itself
    profileStates[widgetName] = {
      ...profileStates[widgetName],
      active: true,
      visited: true,
    };

    // Activate all parent widgets
    const parents = this.getParentWidgets(widgetName);
    parents.forEach(parent => {
      profileStates[parent.name] = {
        ...profileStates[parent.name],
        active: true,
        visited: true,
      };
    });
  }

  setWidgetStatus(widgetName: string, status: WidgetState['status']) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[activeProfileIndex] };

      profileStates[widgetName] = {
        ...profileStates[widgetName],
        status: status
      };

      // Update parent statuses
      this.updateParentStates(widgetName, profileStates);

      newAllStates[activeProfileIndex] = profileStates;
      return newAllStates;
    });
  }

  getVisibleWidgets = computed(() => {
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfileWidgetStates) return [];

    const getVisibleWidgetsRecursively = (items: (WidgetConfig | SubMenuItem)[]): (WidgetConfig | SubMenuItem & { state: WidgetState })[] => {
      return items.flatMap(item => {
        if (!item.visible) return [];
        const subItems = this.getSubMenuItems(item);
        const visibleSubItems = getVisibleWidgetsRecursively(subItems);
        return [
          { ...item, state: activeProfileWidgetStates[item.name] || this.initialWidgetState },
          ...visibleSubItems
        ];
      });
    };

    return getVisibleWidgetsRecursively(WIDGET_CONFIG);
  });

  getSubMenuItems(item: WidgetConfig | SubMenuItem): SubMenuItem[] {
    if (Array.isArray(item.subMenu)) {
      return item.subMenu;
    } else if (this.dynamicSubMenus()[item.name]) {
      return this.dynamicSubMenus()[item.name];
    }
    return [];
  }

  findWidgetByName(name: string): WidgetConfig | SubMenuItem | undefined {
    const find = (items: (WidgetConfig | SubMenuItem)[]): WidgetConfig | SubMenuItem | undefined => {
      for (const item of items) {
        if (item.name === name) return item;
        const subItems = this.getSubMenuItems(item);
        const found = find(subItems);
        if (found) return found;
      }
    };
    return find(WIDGET_CONFIG);
  }

  private getParentWidgets(widgetName: string): (WidgetConfig | SubMenuItem)[] {
    const result: (WidgetConfig | SubMenuItem)[] = [];
    const findParent = (items: (WidgetConfig | SubMenuItem)[], parent?: WidgetConfig | SubMenuItem) => {
      for (const item of items) {
        if (item.name === widgetName && parent) {
          result.push(parent);
          return true;
        }
        const subItems = this.getSubMenuItems(item);
        if (subItems.length && findParent(subItems, item)) {
          if (parent) result.push(parent);
          return true;
        }
      }
      return false;
    };
    findParent(WIDGET_CONFIG);
    return result.reverse();
  }

  private updateParentStates(widgetName: string, profileStates: Record<string, WidgetState>) {
    const parents = this.getParentWidgets(widgetName);
    parents.forEach(parent => {
      const childStates = this.getChildWidgetStates(parent.name, profileStates);
      const allChildrenCompleted = childStates.every(state => state.status === 'completed');
      const anyChildError = childStates.some(state => state.status === 'error');
      const allChildrenAcknowledged = childStates.every(state => state.acknowledged);
      const anyChildVisited = childStates.some(state => state.visited);

      let newStatus: WidgetState['status'] = 'pending';
      if (allChildrenCompleted) newStatus = 'completed';
      else if (anyChildError) newStatus = 'error';
      else if (childStates.some(state => state.status === 'in-progress')) newStatus = 'in-progress';

      profileStates[parent.name] = {
        ...profileStates[parent.name],
        status: newStatus,
        acknowledged: allChildrenAcknowledged,
        visited: anyChildVisited || profileStates[parent.name].visited,
        hasError: anyChildError
      };
    });
  }

  private getChildWidgetStates(widgetName: string, profileStates: Record<string, WidgetState>): WidgetState[] {
    const result: WidgetState[] = [];
    const widget = this.findWidgetByName(widgetName);
    if (widget) {
      const subItems = this.getSubMenuItems(widget);
      subItems.forEach(item => {
        if (profileStates[item.name]) {
          result.push(profileStates[item.name]);
        }
        result.push(...this.getChildWidgetStates(item.name, profileStates));
      });
    }
    return result;
  }

  getIsLoading(): WritableSignal<boolean> {
    return this.isLoading;
  }

validateAllWidgets(): boolean {
    const activeProfile = this.getActiveProfile();
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfile || !activeProfileWidgetStates) return false;

    let isValid = true;
    const visibleWidgets = this.getVisibleWidgets()();

    visibleWidgets.forEach(widget => {
      const widgetForm = activeProfile.get(widget.name);
      const widgetValid = widgetForm?.valid ?? false;
      this.updateWidgetState(widget.name, { 
        hasError: !widgetValid, 
        status: widgetValid ? 'completed' : 'error' 
      });
      isValid = isValid && widgetValid;
    });

    return isValid;
  }

  loadAllWidgets() {
    const visibleWidgets = this.getVisibleWidgets()();

    visibleWidgets.forEach(widget => {
      this.updateWidgetState(widget.name, { visited: true, status: 'in-progress' });
    });
  }

  getNextIncompleteWidget(): string | null {
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfileWidgetStates) return null;

    const visibleWidgets = this.getVisibleWidgets()();
    const incompleteWidget = visibleWidgets.find(widget => 
      activeProfileWidgetStates[widget.name]?.status !== 'completed'
    );

    return incompleteWidget ? incompleteWidget.name : null;
  }

  getCompletionPercentage(): number {
    const activeProfileWidgetStates = this.getActiveProfileWidgetStates();
    if (!activeProfileWidgetStates) return 0;

    const visibleWidgets = this.getVisibleWidgets()();
    const completedWidgets = visibleWidgets.filter(widget => 
      activeProfileWidgetStates[widget.name]?.status === 'completed'
    );

    return (completedWidgets.length / visibleWidgets.length) * 100;
  }

  acknowledgeWidget(widgetName: string) {
    const activeProfileIndex = this.activeProfileIndex();
    if (activeProfileIndex === null) return;

    this.profileWidgetStates.update(allStates => {
      const newAllStates = [...allStates];
      const profileStates = { ...newAllStates[activeProfileIndex] };

      // Acknowledge the widget and its children
      this.acknowledgeWidgetRecursively(widgetName, profileStates);

      // Update parent states
      this.updateParentStates(widgetName, profileStates);

      newAllStates[activeProfileIndex] = profileStates;
      return newAllStates;
    });
  }

  private acknowledgeWidgetRecursively(widgetName: string, profileStates: Record<string, WidgetState>) {
    profileStates[widgetName] = {
      ...profileStates[widgetName],
      acknowledged: true
    };

    const widget = this.findWidgetByName(widgetName);
    if (widget) {
      const subItems = this.getSubMenuItems(widget);
      subItems.forEach(subItem => {
        this.acknowledgeWidgetRecursively(subItem.name, profileStates);
      });
    }
  }

  // Additional methods for profile management, data fetching, etc. would go here
}
